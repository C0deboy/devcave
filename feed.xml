<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://devcave.pl/feed.xml" rel="self" type="application/atom+xml" /><link href="https://devcave.pl/" rel="alternate" type="text/html" /><updated>2019-03-16T15:24:55+01:00</updated><id>https://devcave.pl/feed.xml</id><title type="html">devcave.pl</title><subtitle>Devcave - blog programisty na tematy związane z branżą IT, a szczególnie z programowaniem. Pracuję głownie z językami Java i Javascript, ale na blogu nie zabraknie tematów ogólnych ;)</subtitle><entry><title type="html">Optymalizowanie kodu</title><link href="https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze" rel="alternate" type="text/html" title="Optymalizowanie kodu" /><published>2019-03-16T09:00:00+01:00</published><updated>2019-03-16T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze</id><content type="html" xml:base="https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 67, 68&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Optimize judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Adhere to generally accepted naming conventions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;optymalizacja---robić-czy-nie&quot;&gt;Optymalizacja - robić czy nie?&lt;/h1&gt;

&lt;p&gt;Są co najmniej 3 znane cytaty odnośnie optymalizacji:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.&lt;br /&gt;
—William A. Wulf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.&lt;br /&gt;
—Donald E. Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We follow two rules in the matter of optimization:
Rule 1. Don’t do it.&lt;br /&gt;
Rule 2 (for experts only). Don’t do it yet—that is, not until you have a perfectly clear and unoptimized solution.&lt;br /&gt;
—M. A. Jackson&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wszystkie 3 cytaty poprzedzają język programowania Java o co najmniej dwie dekady, jednak nadal są aktualne i mówią świętą prawdę o optymalizacji - łatwiej jest nią narobić więcej szkód niż dobra, szczególnie jeśli mowa o przedwczesnej optymalizacji.&lt;/p&gt;

&lt;p&gt;Nie warto poświęcać dobrego designu na rzecz wydajności - lepiej jest pisać dobre programy niż szybkie. Jeśli dobry program nie jest wystarczająco wydajny, jego architektura pozwoli go później zoptymalizować. Dobre programy przestrzegają zasady enkapsulacji danych, więc pojedyncze decyzje mogą być zmienione bez wpływu na pozostałą część systemu.&lt;/p&gt;

&lt;p&gt;Nie znaczy to też, że powinniśmy ignorować problemy wydajnościowe, dopóki nie skończymy programu. Problemy implementacyjne mogą być naprawione późniejszą optymalizacją, ale wszechobecne wady architektury ograniczające wydajność mogą nie być możliwe do naprawy bez przepisywania całego systemu od nowa.&lt;/p&gt;

&lt;p&gt;Najtrudniej wprowadzić zamianę w komponentach, które zawierają interakcje pomiędzy komponentami a światem zewnętrznym np. API czy formaty przesyłania danych. Mogą też narzucić znaczne ograniczenia wydajności, dlatego te części systemy trzeba zaprojektować z największą starannością.&lt;/p&gt;

&lt;p&gt;Więc nie możemy całkiem przestać myśleć o optymalizacji. Zawsze trzeba rozważać konsekwencje naszych wyborów np. tworzac typ mutowalny, możemy wymuszać na kliencie wiele zbędnych kopi defensywnych. Podobnie, używając dziedziczenia w publicznej klasie zamiast kompozycji, zszywamy daną klasę z nadklasa na zawsze, co może skutkować ograniczeniami podklasy. Tak samo używając w API typu implementacji zamiast interfejsu, wymuszamy tylko jedną konkretną implementację, mimo to, że w przyszłości mogłaby być napisana bardziej wydajna wersja. Jeśli system jest używany tylko wewnętrznie i możemy całkowicie przebudowywać kod, to nie ma to aż takiego znaczenia, ale po co sobie utrudniać życie?&lt;/p&gt;

&lt;p&gt;Na szczęście zazwyczaj dobry design idzie w parze z dobrą wydajnością lub z łatwą możliwością na jej poprawę. Kiedy zaprojektowaliśmy czysty i dobrze ustrukturyzowany kod, to wtedy może być czas na rozważanie optymalizacji, która w dobrze zaprojektowanym systemie jest łatwa do wprowadzenia. Nigdy nie powinniśmy skupiać się na optymalizacji kosztem spaczonego designu.&lt;/p&gt;

&lt;p&gt;W określeniu, gdzie powinniśmy skupić naszą uwagę podczas optymalizowania systemu, mogą nam pomóc profilery. Te narzędzia dają nam takie informacje jak np. czas, w jakim każda metoda się wykonuje i jak wiele razy to miało miejsce. Innym narzędziem, o którym warto wspomnieć, jest framework do benchmarków &lt;a href=&quot;https://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, którym możemy zmierzyć wydajność poszczególnych kawałków kodu. Warto skorzystać z tego narzędzia, aby porównać zoptymalizowany kod, czy aby na pewno wydajność jest lepsza, czy tylko nam się tak wydaje.&lt;/p&gt;

&lt;h1 id=&quot;konwencje-nazewnicze-w-javie&quot;&gt;Konwencje nazewnicze w Javie&lt;/h1&gt;

&lt;p&gt;Ten temat jest dosyć rozwlekle opisany w książce, jednak myślę, że tu nie ma co się rozdrabniać - podam same konkrety.&lt;/p&gt;

&lt;p&gt;W Javie (jak i w każdym innym języku) mamy powszechnie uznawane konwencje nazewnicze, których należy się trzymać.&lt;/p&gt;

&lt;p&gt;Można powiedzieć, że dzielą się na dwie grupy - typograficzne i gramatyczne.&lt;/p&gt;

&lt;p&gt;Nazwy pakietów i modułów powinny być zwięzłe i składać się wyłącznie z małych liter. Zalecane też są opisowe skróty np. &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;utilities&lt;/code&gt; lub akronimy. Nazwa pakietu, który będzie używany poza naszą organizacją, powinna zaczynać się od odwróconej nazwy domeny np. &lt;code class=&quot;highlighter-rouge&quot;&gt;com.google&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Klasy i interfejsy włączając w to enumy i adnotacje powinny zaczynać się wielką literą i dalej CamelCase. Często dyskusji podlega problem, czy akronimy powinny być całe pisane wielkimi literami, czy nie. Według mnie nie - tylko pierwsza litera powinna być pisana z dużej, szczególnie gdy mamy w nazwie dwa akronimy. Wolałbyś widzieć klasę nazwaną &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTPURL&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;HttpUrl&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Metody i pola obowiązują te same zasady tyle, że zaczynamy małą literą.&lt;/p&gt;

&lt;p&gt;Wyjątkiem od tej zasady są pola stałe (&lt;code class=&quot;highlighter-rouge&quot;&gt;static final&lt;/code&gt; + niemutowalne), które powinny być zapisane dużymi literami, a poszczególne słowa oddzielone podłogą. Stałymi są również wartości enumów.&lt;/p&gt;

&lt;p&gt;Zmienne lokalne mają już większą dowolność co do nazwy, ale powinny być opisowe i oczywiście zaczynać się z małej litery.&lt;/p&gt;

&lt;p&gt;Nazwy parametru typu składają się z jednej dużej litery. Najczęściej używa się:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; dla jakiegoś typu (jeśli jest więcej niż jeden, to kolejno &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;T1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;T2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;T3&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; dla typu elementu kolekcji&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; dla typu klucza i wartości mapy&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; dla typu wyjątku.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; dla typu zwracanego przez funkcję&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Podsumowując:&lt;/p&gt;

&lt;table class=&quot;post-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Element&lt;/th&gt;
      &lt;th&gt;Przykład&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pakiet lub moduł&lt;/td&gt;
      &lt;td&gt;org.junit.jupiter.api, com.google.common.collect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Klasa lub Interfejs&lt;/td&gt;
      &lt;td&gt;Stream, FutureTask, LinkedHashMap, HttpClient&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Metoda lub pole&lt;/td&gt;
      &lt;td&gt;remove, groupingBy, getCrc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stała&lt;/td&gt;
      &lt;td&gt;PI, MIN_VALUE, NEGATIVE_INFINITY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Zmienna lokalna&lt;/td&gt;
      &lt;td&gt;i, denom, houseNum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parametr typu&lt;/td&gt;
      &lt;td&gt;T, E, K, V, X, R, U, V, T1, T2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Odnośnie konwencji gramatycznych, które nie są już tak bardzo konieczne jak te typograficzne, to zazwyczaj nazwy klas instancjonowalnych są rzeczownikiem w liczbie pojedynczej jak np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PriorityQueue&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;ChessPiece&lt;/code&gt;. Z kolei nazwy nieinstancjonowalnych klasy typu utility często są w liczbie mnogiej np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt;. Interfejsy zazwyczaj nazywane są tak jak klasy np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;, ale też z końcówkami &lt;code class=&quot;highlighter-rouge&quot;&gt;able&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;ible&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Accessible&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Metody, które:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;wykonują jakieś akcje standardowo są czasownikami np. &lt;code class=&quot;highlighter-rouge&quot;&gt;append&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;drawImage&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;zwracają &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt; zazwyczaj zaczynają się od &lt;code class=&quot;highlighter-rouge&quot;&gt;is&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;has&lt;/code&gt; + rzeczownik np. &lt;code class=&quot;highlighter-rouge&quot;&gt;isDigit&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isProbablePrime&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isEmpty&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isEnabled&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;hasSiblings&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;zwracają jakąś daną zazwyczaj zaczynają się od &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; lub bezpośrednio nazwa tej danej np. &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;getTime&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;konwertują obiekt w inny zazwyczaj nazywają się &lt;code class=&quot;highlighter-rouge&quot;&gt;toType&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;toArray&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;zwracają inny widok zazwyczaj nazywają sie &lt;code class=&quot;highlighter-rouge&quot;&gt;asType&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;asList&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;są statycznymi fabrykami zazwyczaj nazywają się &lt;code class=&quot;highlighter-rouge&quot;&gt;from&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;of&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;instance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;newInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getType&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;newType&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 67, 68 z rozdziału 9: General Programming Minimize the scope of local variables Prefer for-each loops to traditional for loops Know and use the libraries Avoid float and double if exact answers are required Prefer primitive types to boxed primitives Avoid strings where other types are more appropriate Beware the performance of string concatenation Refer to objects by their interfaces Prefer interfaces to reflection Use native methods judiciously Optimize judiciously Adhere to generally accepted naming conventions Optymalizacja - robić czy nie? Są co najmniej 3 znane cytaty odnośnie optymalizacji: More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity. —William A. Wulf We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. —Donald E. Knuth We follow two rules in the matter of optimization: Rule 1. Don’t do it. Rule 2 (for experts only). Don’t do it yet—that is, not until you have a perfectly clear and unoptimized solution. —M. A. Jackson Wszystkie 3 cytaty poprzedzają język programowania Java o co najmniej dwie dekady, jednak nadal są aktualne i mówią świętą prawdę o optymalizacji - łatwiej jest nią narobić więcej szkód niż dobra, szczególnie jeśli mowa o przedwczesnej optymalizacji. Nie warto poświęcać dobrego designu na rzecz wydajności - lepiej jest pisać dobre programy niż szybkie. Jeśli dobry program nie jest wystarczająco wydajny, jego architektura pozwoli go później zoptymalizować. Dobre programy przestrzegają zasady enkapsulacji danych, więc pojedyncze decyzje mogą być zmienione bez wpływu na pozostałą część systemu. Nie znaczy to też, że powinniśmy ignorować problemy wydajnościowe, dopóki nie skończymy programu. Problemy implementacyjne mogą być naprawione późniejszą optymalizacją, ale wszechobecne wady architektury ograniczające wydajność mogą nie być możliwe do naprawy bez przepisywania całego systemu od nowa. Najtrudniej wprowadzić zamianę w komponentach, które zawierają interakcje pomiędzy komponentami a światem zewnętrznym np. API czy formaty przesyłania danych. Mogą też narzucić znaczne ograniczenia wydajności, dlatego te części systemy trzeba zaprojektować z największą starannością. Więc nie możemy całkiem przestać myśleć o optymalizacji. Zawsze trzeba rozważać konsekwencje naszych wyborów np. tworzac typ mutowalny, możemy wymuszać na kliencie wiele zbędnych kopi defensywnych. Podobnie, używając dziedziczenia w publicznej klasie zamiast kompozycji, zszywamy daną klasę z nadklasa na zawsze, co może skutkować ograniczeniami podklasy. Tak samo używając w API typu implementacji zamiast interfejsu, wymuszamy tylko jedną konkretną implementację, mimo to, że w przyszłości mogłaby być napisana bardziej wydajna wersja. Jeśli system jest używany tylko wewnętrznie i możemy całkowicie przebudowywać kod, to nie ma to aż takiego znaczenia, ale po co sobie utrudniać życie? Na szczęście zazwyczaj dobry design idzie w parze z dobrą wydajnością lub z łatwą możliwością na jej poprawę. Kiedy zaprojektowaliśmy czysty i dobrze ustrukturyzowany kod, to wtedy może być czas na rozważanie optymalizacji, która w dobrze zaprojektowanym systemie jest łatwa do wprowadzenia. Nigdy nie powinniśmy skupiać się na optymalizacji kosztem spaczonego designu. W określeniu, gdzie powinniśmy skupić naszą uwagę podczas optymalizowania systemu, mogą nam pomóc profilery. Te narzędzia dają nam takie informacje jak np. czas, w jakim każda metoda się wykonuje i jak wiele razy to miało miejsce. Innym narzędziem, o którym warto wspomnieć, jest framework do benchmarków JMH, którym możemy zmierzyć wydajność poszczególnych kawałków kodu. Warto skorzystać z tego narzędzia, aby porównać zoptymalizowany kod, czy aby na pewno wydajność jest lepsza, czy tylko nam się tak wydaje. Konwencje nazewnicze w Javie Ten temat jest dosyć rozwlekle opisany w książce, jednak myślę, że tu nie ma co się rozdrabniać - podam same konkrety. W Javie (jak i w każdym innym języku) mamy powszechnie uznawane konwencje nazewnicze, których należy się trzymać. Można powiedzieć, że dzielą się na dwie grupy - typograficzne i gramatyczne. Nazwy pakietów i modułów powinny być zwięzłe i składać się wyłącznie z małych liter. Zalecane też są opisowe skróty np. util zamiast utilities lub akronimy. Nazwa pakietu, który będzie używany poza naszą organizacją, powinna zaczynać się od odwróconej nazwy domeny np. com.google. Klasy i interfejsy włączając w to enumy i adnotacje powinny zaczynać się wielką literą i dalej CamelCase. Często dyskusji podlega problem, czy akronimy powinny być całe pisane wielkimi literami, czy nie. Według mnie nie - tylko pierwsza litera powinna być pisana z dużej, szczególnie gdy mamy w nazwie dwa akronimy. Wolałbyś widzieć klasę nazwaną HTTPURL czy HttpUrl? Metody i pola obowiązują te same zasady tyle, że zaczynamy małą literą. Wyjątkiem od tej zasady są pola stałe (static final + niemutowalne), które powinny być zapisane dużymi literami, a poszczególne słowa oddzielone podłogą. Stałymi są również wartości enumów. Zmienne lokalne mają już większą dowolność co do nazwy, ale powinny być opisowe i oczywiście zaczynać się z małej litery. Nazwy parametru typu składają się z jednej dużej litery. Najczęściej używa się: T dla jakiegoś typu (jeśli jest więcej niż jeden, to kolejno T, U, V lub T1, T2, T3) E dla typu elementu kolekcji K i V dla typu klucza i wartości mapy X dla typu wyjątku. R dla typu zwracanego przez funkcję Podsumowując: Element Przykład Pakiet lub moduł org.junit.jupiter.api, com.google.common.collect Klasa lub Interfejs Stream, FutureTask, LinkedHashMap, HttpClient Metoda lub pole remove, groupingBy, getCrc Stała PI, MIN_VALUE, NEGATIVE_INFINITY Zmienna lokalna i, denom, houseNum Parametr typu T, E, K, V, X, R, U, V, T1, T2 Odnośnie konwencji gramatycznych, które nie są już tak bardzo konieczne jak te typograficzne, to zazwyczaj nazwy klas instancjonowalnych są rzeczownikiem w liczbie pojedynczej jak np. Thread, PriorityQueue czy ChessPiece. Z kolei nazwy nieinstancjonowalnych klasy typu utility często są w liczbie mnogiej np. Collectors czy Collections. Interfejsy zazwyczaj nazywane są tak jak klasy np. Collection czy Comparator, ale też z końcówkami able lub ible np. Runnable, Iterable czy Accessible. Metody, które: wykonują jakieś akcje standardowo są czasownikami np. append lub drawImage zwracają boolean zazwyczaj zaczynają się od is lub has + rzeczownik np. isDigit, isProbablePrime, isEmpty, isEnabled lub hasSiblings zwracają jakąś daną zazwyczaj zaczynają się od get lub bezpośrednio nazwa tej danej np. size, hashCode lub getTime. konwertują obiekt w inny zazwyczaj nazywają się toType np. toString lub toArray. zwracają inny widok zazwyczaj nazywają sie asType np. asList. są statycznymi fabrykami zazwyczaj nazywają się from, of, valueOf, instance, getInstance, newInstance, getType lub newType.</summary></entry><entry><title type="html">Refleksja i metody natywne</title><link href="https://devcave.pl/effective-java/refleksja-i-metody-natywne" rel="alternate" type="text/html" title="Refleksja i metody natywne" /><published>2019-03-09T09:00:00+01:00</published><updated>2019-03-09T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/refleksja-i-metody-natywne</id><content type="html" xml:base="https://devcave.pl/effective-java/refleksja-i-metody-natywne">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 65, 66&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Prefer interfaces to reflection
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Use native methods judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;preferuj-interfejsy-zamiast-bezpośredniej-refleksji&quot;&gt;Preferuj interfejsy zamiast bezpośredniej refleksji&lt;/h1&gt;

&lt;p&gt;Refleksja, którą w Javie mamy w pakiecie &lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;, umożliwia uzyskać dostęp do konstruktorów, metod i pól każdej klasy, a także do ich nazw, typów, sygnatur itd.&lt;/p&gt;

&lt;p&gt;Dzięki temu możemy manipulować niemal każdym elementem klasy. Możemy również budować instancje, wywoływać metody czy nawet uzyskać dostęp do pól, które są zadeklarowane jako &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ponadto refleksja pozwala jednej klasie użyć drugiej, mimo że ta druga nie istniała podczas kompilacji tej pierwszej.&lt;/p&gt;

&lt;p&gt;Jest to zatem potężne narzędzie, jednak ma swoją cenę:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tracimy wszystkie zalety sprawdzania typów i wyjątków. Jeśli spróbujemy wywołać metodę nieistniejącą metodę refleksją, to program wysypie się dopiero w &lt;em&gt;runtime&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;Kod refleksji jest zazwyczaj paskudny i rozwlekły - ciężko się go piszę i czyta&lt;/li&gt;
  &lt;li&gt;Wydajność jest dużo gorsza w porównaniu ze zwykłym wywoływaniem metod&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Są aplikacje, które wręcz polegają na refleksji. Są to między innymi narzędzia analizy kodu czy frameworki &lt;em&gt;dependency injection&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Można jednak czerpać korzyści z refleksji, jednocześnie redukując przy tym jej koszt poprzez używanie refleksji w ograniczonej formie.&lt;/p&gt;

&lt;p&gt;Kiedy program musi używać klasy, która jeszcze nie jest dostępna w czasie kompilacji, możemy posłużyć się istniejącym interfejsem lub nadklasą, by odnosić się do tej klasy. Możemy wtedy utworzyć instancję refleksją i używać jej przez interfejs lub nadklasę.&lt;/p&gt;

&lt;p&gt;Dla przykładu program, który tworzy instancje &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&amp;lt;String&amp;gt;&lt;/code&gt;, której klasa jest podawana jako pierwszy argument w cmd. Pozostałe argumenty lądują w tym secie i są printowane na konsolę. Kolejność, w jakiej będą pokazane, zależy od implementacji setu np. jeśli podamy &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; to kolejność będzie losowa, a gdy &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt; to będzie alfabetycznie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Reflective instantiation with interface access&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Translate the class name into a Class object&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Unchecked cast!&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class not found.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Get the constructor&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NoSuchMethodException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No parameterless constructor&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Instantiate the set&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IllegalAccessException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor not accessible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InstantiationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class not instantiable.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InvocationTargetException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor threw &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassCastException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class doesn't implement Set&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Exercise the set&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Np. dla argumentów &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.TreeSet b c d g i s a&lt;/code&gt; dostalibyśmy w wyniku &lt;code class=&quot;highlighter-rouge&quot;&gt;[a, b, c, d, g, i, s]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ten przykład pokazuję też jak kod refleksji jest rozwlekły i ile wymaga boilerplateru - generuje aż 6 różnych wyjątków. Można by je jednak zredukować, łapiąc &lt;code class=&quot;highlighter-rouge&quot;&gt;ReflectiveOperationException&lt;/code&gt;, który jest nadklasą wyjątków refleksji i został dodany w Javie 7. Używając refleksji dostajemy też wiele &lt;em&gt;unchecked cast warning&lt;/em&gt;. Więc ignorując poszczególne wyjątki otrzymalibyśmy taki kod:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Reflective instantiation with interface access&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Translate the class name into a Class object&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Unchecked cast!&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Get the constructor&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Instantiate the set&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Exercise the set&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReflectiveOperationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor not accessible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie jest już aż tak rozwlekły, ale nadal nie należy do najpiękniejszych.&lt;/p&gt;

&lt;p&gt;Podsumowując, refleksja to potężne narzędzie do specyficznych zastosowań i ma kilka wad. Jeśli jednak musimy jej użyć, powinniśmy (jeśli jest tylko taka możliwość) ograniczyć jej użycie do stworzenia instancji klasy, a później już operować na interfejsie czy nadklasie, która jest dostępna w czasie kompilacji.&lt;/p&gt;

&lt;h1 id=&quot;metody-natywne&quot;&gt;Metody natywne&lt;/h1&gt;

&lt;p&gt;Java Native Interface (JNI) pozwala na wywoływanie natywnych metod, które są napisane w natywnych dla danego systemu językach jak C czy C++. Może to być wykorzystane w celu uzyskania dostępu do specyficznych funkcji systemu jak np. rejestry czy do użycia bibliotek, które są napisane w natywnych językach. W natywnych językach mogą też być napisane części systemu, które są krytyczne pod względem wydajności i które później wywołamy z Javy.&lt;/p&gt;

&lt;p&gt;Obecnie jednak nie potrzebujemy używania natywnego kodu do większości specyficznych części systemu, bo Java wspiera już wiele z nich sama z siebie. Dla przykładu w Javie 9 dodano &lt;code class=&quot;highlighter-rouge&quot;&gt;process API&lt;/code&gt;, które daje nam wygodny dostęp do procesów systemu operacyjnego.&lt;/p&gt;

&lt;p&gt;Również pisanie natywnych metod w celu zapewnienia lepszej wydajności w wielu przypadkach nie jest już zalecane. JVM stał się dużo szybszy, niż to miało miejsce w pierwszych wersjach Javy i obecnie można uzyskać porównywalną wydajność w Javie. Na przykład, historycznie w Javie 1.1, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt; polegał wtedy na szybkiej bibliotece napisanej w C, a w Javie 3 zmieniono implementację na Javę i doprowadzono do tego, że była szybsza niż oryginalna, natywna implementacja.&lt;/p&gt;

&lt;p&gt;Wywoływanie metod natywnych wiąże się z kosztowną komunikacją między kodem działającym na JVM a tym natywnym. Używając natywnych metod uzależniamy się od systemu i aplikacja staje się mniej przenośna między systemami. Aplikacje takie są też mniej bezpieczne i trudniejsze w debugowaniu.&lt;/p&gt;

&lt;p&gt;Jeśli nigdy nie spotkałeś się z metodami natywnymi, to polecam: &lt;a href=&quot;https://www.baeldung.com/jni&quot;&gt;Guide to JNI (Java Native Interface)&lt;/a&gt;&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 65, 66 z rozdziału 9: General Programming Minimize the scope of local variables Prefer for-each loops to traditional for loops Know and use the libraries Avoid float and double if exact answers are required Prefer primitive types to boxed primitives Avoid strings where other types are more appropriate Beware the performance of string concatenation Refer to objects by their interfaces Prefer interfaces to reflection Use native methods judiciously Optimize judiciously Adhere to generally accepted naming conventions Preferuj interfejsy zamiast bezpośredniej refleksji Refleksja, którą w Javie mamy w pakiecie java.lang.reflect, umożliwia uzyskać dostęp do konstruktorów, metod i pól każdej klasy, a także do ich nazw, typów, sygnatur itd. Dzięki temu możemy manipulować niemal każdym elementem klasy. Możemy również budować instancje, wywoływać metody czy nawet uzyskać dostęp do pól, które są zadeklarowane jako private. Ponadto refleksja pozwala jednej klasie użyć drugiej, mimo że ta druga nie istniała podczas kompilacji tej pierwszej. Jest to zatem potężne narzędzie, jednak ma swoją cenę: tracimy wszystkie zalety sprawdzania typów i wyjątków. Jeśli spróbujemy wywołać metodę nieistniejącą metodę refleksją, to program wysypie się dopiero w runtime. Kod refleksji jest zazwyczaj paskudny i rozwlekły - ciężko się go piszę i czyta Wydajność jest dużo gorsza w porównaniu ze zwykłym wywoływaniem metod Są aplikacje, które wręcz polegają na refleksji. Są to między innymi narzędzia analizy kodu czy frameworki dependency injection. Można jednak czerpać korzyści z refleksji, jednocześnie redukując przy tym jej koszt poprzez używanie refleksji w ograniczonej formie. Kiedy program musi używać klasy, która jeszcze nie jest dostępna w czasie kompilacji, możemy posłużyć się istniejącym interfejsem lub nadklasą, by odnosić się do tej klasy. Możemy wtedy utworzyć instancję refleksją i używać jej przez interfejs lub nadklasę. Dla przykładu program, który tworzy instancje Set&amp;lt;String&amp;gt;, której klasa jest podawana jako pierwszy argument w cmd. Pozostałe argumenty lądują w tym secie i są printowane na konsolę. Kolejność, w jakiej będą pokazane, zależy od implementacji setu np. jeśli podamy HashSet to kolejność będzie losowa, a gdy TreeSet to będzie alfabetycznie: // Reflective instantiation with interface access public static void main(String[] args) { // Translate the class name into a Class object Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cl = null; try { cl = (Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt;) // Unchecked cast! Class.forName(args[0]); } catch (ClassNotFoundException e) { fatalError(&quot;Class not found.&quot;); } // Get the constructor Constructor&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cons = null; try { cons = cl.getDeclaredConstructor(); } catch (NoSuchMethodException e) { fatalError(&quot;No parameterless constructor&quot;); } // Instantiate the set Set&amp;lt;String&amp;gt; s = null; try { s = cons.newInstance(); } catch (IllegalAccessException e) { fatalError(&quot;Constructor not accessible&quot;); } catch (InstantiationException e) { fatalError(&quot;Class not instantiable.&quot;); } catch (InvocationTargetException e) { fatalError(&quot;Constructor threw &quot; + e.getCause()); } catch (ClassCastException e) { fatalError(&quot;Class doesn't implement Set&quot;); } // Exercise the set s.addAll(Arrays.asList(args).subList(1, args.length)); System.out.println(s); } private static void fatalError(String msg) { System.err.println(msg); System.exit(1); } Np. dla argumentów java.util.TreeSet b c d g i s a dostalibyśmy w wyniku [a, b, c, d, g, i, s]. Ten przykład pokazuję też jak kod refleksji jest rozwlekły i ile wymaga boilerplateru - generuje aż 6 różnych wyjątków. Można by je jednak zredukować, łapiąc ReflectiveOperationException, który jest nadklasą wyjątków refleksji i został dodany w Javie 7. Używając refleksji dostajemy też wiele unchecked cast warning. Więc ignorując poszczególne wyjątki otrzymalibyśmy taki kod: // Reflective instantiation with interface access public static void main(String[] args) { // Translate the class name into a Class object Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cl; Set&amp;lt;String&amp;gt; s = null; try { cl = (Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt;) // Unchecked cast! Class.forName(args[0]); // Get the constructor Constructor&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cons; cons = cl.getDeclaredConstructor(); // Instantiate the set s = cons.newInstance(); // Exercise the set s.addAll(Arrays.asList(args).subList(1, args.length)); } catch (ReflectiveOperationException e) { System.err.println(&quot;Constructor not accessible&quot;); System.exit(1); } System.out.println(s); } Nie jest już aż tak rozwlekły, ale nadal nie należy do najpiękniejszych. Podsumowując, refleksja to potężne narzędzie do specyficznych zastosowań i ma kilka wad. Jeśli jednak musimy jej użyć, powinniśmy (jeśli jest tylko taka możliwość) ograniczyć jej użycie do stworzenia instancji klasy, a później już operować na interfejsie czy nadklasie, która jest dostępna w czasie kompilacji. Metody natywne Java Native Interface (JNI) pozwala na wywoływanie natywnych metod, które są napisane w natywnych dla danego systemu językach jak C czy C++. Może to być wykorzystane w celu uzyskania dostępu do specyficznych funkcji systemu jak np. rejestry czy do użycia bibliotek, które są napisane w natywnych językach. W natywnych językach mogą też być napisane części systemu, które są krytyczne pod względem wydajności i które później wywołamy z Javy. Obecnie jednak nie potrzebujemy używania natywnego kodu do większości specyficznych części systemu, bo Java wspiera już wiele z nich sama z siebie. Dla przykładu w Javie 9 dodano process API, które daje nam wygodny dostęp do procesów systemu operacyjnego. Również pisanie natywnych metod w celu zapewnienia lepszej wydajności w wielu przypadkach nie jest już zalecane. JVM stał się dużo szybszy, niż to miało miejsce w pierwszych wersjach Javy i obecnie można uzyskać porównywalną wydajność w Javie. Na przykład, historycznie w Javie 1.1, BigInteger polegał wtedy na szybkiej bibliotece napisanej w C, a w Javie 3 zmieniono implementację na Javę i doprowadzono do tego, że była szybsza niż oryginalna, natywna implementacja. Wywoływanie metod natywnych wiąże się z kosztowną komunikacją między kodem działającym na JVM a tym natywnym. Używając natywnych metod uzależniamy się od systemu i aplikacja staje się mniej przenośna między systemami. Aplikacje takie są też mniej bezpieczne i trudniejsze w debugowaniu. Jeśli nigdy nie spotkałeś się z metodami natywnymi, to polecam: Guide to JNI (Java Native Interface)</summary></entry><entry><title type="html">Wybieraj właściwe typy</title><link href="https://devcave.pl/effective-java/wybieraj-wlasciwe-typy" rel="alternate" type="text/html" title="Wybieraj właściwe typy" /><published>2019-03-02T09:00:00+01:00</published><updated>2019-03-02T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/wybieraj-wlasciwe-typy</id><content type="html" xml:base="https://devcave.pl/effective-java/wybieraj-wlasciwe-typy">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 60, 61, 62, 63, 64&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Avoid float and double if exact answers are required
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Prefer primitive types to boxed primitives
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Avoid strings where other types are more appropriate
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Beware the performance of string concatenation
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Refer to objects by their interfaces
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;unikaj-float-i-double-kiedy-potrzebujesz-precyzji&quot;&gt;Unikaj float i double kiedy potrzebujesz precyzji&lt;/h1&gt;

&lt;p&gt;Typy &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; były zaprojektowane początkowo do naukowych obliczeń. Skupiają się na jak najlepszej wydajności, jednak nie dostarczają one dokładnych wyników. Przykładowo nie powinny być stosowane w obliczeniach walutowych, bo nie jest możliwe precyzyjne reprezentowania 0.1 lub innej ujemnej potęgi 10 jako &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dla przykładu, mając 1.03 zł i odejmując od tego 42 gr, dostalibyśmy w wyniku 0.6100000000000001.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.03&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 0.6100000000000001&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Inny przykład - mając 1 zł i odejmując od tego 9 razy coś za 10 gr zostałoby nam 0.09999999999999998 zł.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.00&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 0.09999999999999998&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Może się zdawać, że ten problem można by rozwiązać, po prostu zaokrąglając wyniki, jednak nie jest to prawda - nie zawsze by to działało.&lt;/p&gt;

&lt;p&gt;Rozwiązanie jest prostsze - tam gdzie jest wymagana precyzja, używaj - &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, lub &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Najlepiej jest używać konstruktora &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, który przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; - wtedy unikamy wprowadzania niedokładnych wartości do obliczeń.&lt;/p&gt;

&lt;p&gt;Używanie &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt; ma jednak dwie wady:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jest dużo mniej wygodne niż używanie prymitywnych typów&lt;/li&gt;
  &lt;li&gt;jest też od nich mniej wydajne&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jednak tym drugim w większości wypadków nie ma się co przejmować.&lt;/p&gt;

&lt;h1 id=&quot;preferuj-typy-prymitywne&quot;&gt;Preferuj typy prymitywne&lt;/h1&gt;

&lt;p&gt;Ten temat już był i dobrze go opisałem w poście &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;Unikaj nadmiarowego tworzenia obiektów&lt;/a&gt;, wyjaśniając i pokazując na przykładzie, dlaczego powinniśmy preferować typy prymitywne zamiast ich odpowiedników klasowych (&lt;em&gt;boxed primitives&lt;/em&gt;).&lt;/p&gt;

&lt;h1 id=&quot;unikaj-używania-stringów-tam-gdzie-istnieją-lepsze-alternatywy&quot;&gt;Unikaj używania stringów tam, gdzie istnieją lepsze alternatywy&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; został zaprojektowany by reprezentować tekst, jednak jest tendencja, by go używać do innych celów, podczas gdy mamy do tego lepsze alternatywy.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; często dostajemy w żądaniach z przeglądarki, czytając plik i z wielu innych źródeł - jest to naturalne, jednak nie powinniśmy tego zostawiać w tej postaci, jeśli istnieje lub możemy stworzyć odpowiedni typ reprezentujący te dane. Niby jest to oczywiste, ale i tak często &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; jest nadużywane.&lt;/p&gt;

&lt;p&gt;Kolejną złą praktyką jest używanie stringów zamiast enumów - opisywałem to w temacie &lt;a href=&quot;/effective-java/enums&quot;&gt;Enumy - kilka dobrych praktyk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Przed użyciem &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; warto się zastanowić czy nie ma lepszej alternatywy dla danego zastosowania.&lt;/p&gt;

&lt;h1 id=&quot;wydajność-konkatenacji-stringów&quot;&gt;Wydajność konkatenacji stringów&lt;/h1&gt;

&lt;p&gt;Jak pewnie Ci wiadomo &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; w Javie jest niemutowalny, więc każde użycie operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; między stringami (konkatenacja) tworzy nowy obiekt &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;. Jest to całkowicie w porządku w przypadku łączeniu kilku stringów o stałej długości, jednak mało wydajne przy budowaniu dużych ciągów tekstu, szczególnie w pętli. Przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Inappropriate use of string concatenation - Performs poorly!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineForItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// String concatenation&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu dla każdej iteracji pętli tworzy się niepotrzebnie nowy &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, przez co metoda jest mało wydajna. Rozwiązaniem tutaj jest użycie klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;, która jest mutowalnym odpowiednikiem klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LINE_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineForItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W prostych przypadkach nie ma sensu używać &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a ponieważ kompilator Javy automatycznie robi to za nas (taka automatyczna optymalizacja z jego strony). Użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a w prostych przypadkach tylko źle wpływa na czytelność kodu. Lepiej jest użyć wtedy po prostu operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;. Jednak w przypadku pętli i w bardziej złożonych operacjach konkatenacji, kompilator Javy nie jest w stanie podmienić jej na użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a, więc w takich przypadkach warto go użyć.&lt;/p&gt;

&lt;h1 id=&quot;odnoś-się-do-obiektów-po-ich-interfejsach&quot;&gt;Odnoś się do obiektów po ich interfejsach&lt;/h1&gt;

&lt;p&gt;Podobny rada była w poście &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Projektowanie metod&lt;/a&gt;, gdzie była mowa o używaniu interfejsów w typie parametrów. Ten temat rozszerza tę radę do wszystkich możliwych miejsc deklaracji typu - parametry, wartości zwracane, zmienne czy pola. Jeśli istnieje odpowiedni interfejs, to bez względu na miejsce deklaracji, zawsze powinniśmy deklarować typ jako interfejs zamiast konkretnej klasy.&lt;/p&gt;

&lt;p&gt;Jedyny moment, gdzie musimy odnieść się do klasy konkretnej, jest tam, gdzie tworzymy ten obiekt konstruktorem.&lt;/p&gt;

&lt;p&gt;Zatem miejmy w nawyku taki kod:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Good - uses interface as type&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A nie taki:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bad - uses class as type!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dostajemy dzięki temu bardziej zwięzły kod, ale co ważniejsze - większą elastyczność. Możemy w każdej chwili zmienić implementację, a cały kod dookoła będzie dalej się kompilował:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I prawdopodobnie działał. Jest jednak jeden wyjątek od tej zasady. Jeśli konkretna implementacja oferuję jakąś specjalną funkcjonalność, która nie jest zagwarantowana przez interfejs i kod polega na tej funkcjonalności, to nie powinniśmy używać ogólnego interfejsu jako deklaracji typu.&lt;/p&gt;

&lt;p&gt;Przykładem tutaj mogłoby być to, że nasz kod polegałby na sortowaniu zapewnionym przez &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;. Wtedy byłoby nieodpowiednie zadeklarowanie typu tej zmiennej jako &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt; ponieważ interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt; sam w sobie nie daję żadnej gwarancji odnośnie sortowania.&lt;/p&gt;

&lt;p&gt;Oczywiście jest wiele przypadków, gdzie klasy nie mają swoich interfejsów, szczególnie tzw. &lt;em&gt;value classes&lt;/em&gt; jak np. &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt;. Wtedy naturalnie będziemy używać konkretnych klas i nie ma w tym nic złego. Postarajmy się wtedy używać po prostu klasę najwyżej w hierarchii, która ma wymaganą przez nas funkcjonalność.&lt;/p&gt;

&lt;p&gt;Czasem musimy zrobić też użytek z metod, które występują w klasie konkretnej, a nie ma ich na interfejsie - wtedy też użyjemy klasy konkretnej jako deklaracji typu i nie ma w tym nic złego.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 60, 61, 62, 63, 64 z rozdziału 9: General Programming Minimize the scope of local variables Prefer for-each loops to traditional for loops Know and use the libraries Avoid float and double if exact answers are required Prefer primitive types to boxed primitives Avoid strings where other types are more appropriate Beware the performance of string concatenation Refer to objects by their interfaces Prefer interfaces to reflection Use native methods judiciously Optimize judiciously Adhere to generally accepted naming conventions Unikaj float i double kiedy potrzebujesz precyzji Typy float i double były zaprojektowane początkowo do naukowych obliczeń. Skupiają się na jak najlepszej wydajności, jednak nie dostarczają one dokładnych wyników. Przykładowo nie powinny być stosowane w obliczeniach walutowych, bo nie jest możliwe precyzyjne reprezentowania 0.1 lub innej ujemnej potęgi 10 jako float lub double. Dla przykładu, mając 1.03 zł i odejmując od tego 42 gr, dostalibyśmy w wyniku 0.6100000000000001. System.out.println(1.03 - 0.42); // 0.6100000000000001 Inny przykład - mając 1 zł i odejmując od tego 9 razy coś za 10 gr zostałoby nam 0.09999999999999998 zł. System.out.println(1.00 - 9 * 0.10); // 0.09999999999999998 Może się zdawać, że ten problem można by rozwiązać, po prostu zaokrąglając wyniki, jednak nie jest to prawda - nie zawsze by to działało. Rozwiązanie jest prostsze - tam gdzie jest wymagana precyzja, używaj - BigDecimal, int, lub long. Najlepiej jest używać konstruktora BigDecimal, który przyjmuje String - wtedy unikamy wprowadzania niedokładnych wartości do obliczeń. Używanie BigDecimal ma jednak dwie wady: jest dużo mniej wygodne niż używanie prymitywnych typów jest też od nich mniej wydajne Jednak tym drugim w większości wypadków nie ma się co przejmować. Preferuj typy prymitywne Ten temat już był i dobrze go opisałem w poście Unikaj nadmiarowego tworzenia obiektów, wyjaśniając i pokazując na przykładzie, dlaczego powinniśmy preferować typy prymitywne zamiast ich odpowiedników klasowych (boxed primitives). Unikaj używania stringów tam, gdzie istnieją lepsze alternatywy String został zaprojektowany by reprezentować tekst, jednak jest tendencja, by go używać do innych celów, podczas gdy mamy do tego lepsze alternatywy. String często dostajemy w żądaniach z przeglądarki, czytając plik i z wielu innych źródeł - jest to naturalne, jednak nie powinniśmy tego zostawiać w tej postaci, jeśli istnieje lub możemy stworzyć odpowiedni typ reprezentujący te dane. Niby jest to oczywiste, ale i tak często String jest nadużywane. Kolejną złą praktyką jest używanie stringów zamiast enumów - opisywałem to w temacie Enumy - kilka dobrych praktyk. Przed użyciem String warto się zastanowić czy nie ma lepszej alternatywy dla danego zastosowania. Wydajność konkatenacji stringów Jak pewnie Ci wiadomo String w Javie jest niemutowalny, więc każde użycie operatora + między stringami (konkatenacja) tworzy nowy obiekt String. Jest to całkowicie w porządku w przypadku łączeniu kilku stringów o stałej długości, jednak mało wydajne przy budowaniu dużych ciągów tekstu, szczególnie w pętli. Przykład: // Inappropriate use of string concatenation - Performs poorly! public String statement() { String result = &quot;&quot;; for (int i = 0; i &amp;lt; numItems(); i++) result += lineForItem(i); // String concatenation return result; } Tu dla każdej iteracji pętli tworzy się niepotrzebnie nowy String, przez co metoda jest mało wydajna. Rozwiązaniem tutaj jest użycie klasy StringBuilder, która jest mutowalnym odpowiednikiem klasy String: public String statement() { StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH); for (int i = 0; i &amp;lt; numItems(); i++) b.append(lineForItem(i)); return b.toString(); } W prostych przypadkach nie ma sensu używać StringBuilder-a ponieważ kompilator Javy automatycznie robi to za nas (taka automatyczna optymalizacja z jego strony). Użycie StringBuilder-a w prostych przypadkach tylko źle wpływa na czytelność kodu. Lepiej jest użyć wtedy po prostu operatora +. Jednak w przypadku pętli i w bardziej złożonych operacjach konkatenacji, kompilator Javy nie jest w stanie podmienić jej na użycie StringBuilder-a, więc w takich przypadkach warto go użyć. Odnoś się do obiektów po ich interfejsach Podobny rada była w poście Projektowanie metod, gdzie była mowa o używaniu interfejsów w typie parametrów. Ten temat rozszerza tę radę do wszystkich możliwych miejsc deklaracji typu - parametry, wartości zwracane, zmienne czy pola. Jeśli istnieje odpowiedni interfejs, to bez względu na miejsce deklaracji, zawsze powinniśmy deklarować typ jako interfejs zamiast konkretnej klasy. Jedyny moment, gdzie musimy odnieść się do klasy konkretnej, jest tam, gdzie tworzymy ten obiekt konstruktorem. Zatem miejmy w nawyku taki kod: // Good - uses interface as type Set&amp;lt;Son&amp;gt; sonSet = new LinkedHashSet&amp;lt;&amp;gt;(); A nie taki: // Bad - uses class as type! LinkedHashSet&amp;lt;Son&amp;gt; sonSet = new LinkedHashSet&amp;lt;&amp;gt;(); Dostajemy dzięki temu bardziej zwięzły kod, ale co ważniejsze - większą elastyczność. Możemy w każdej chwili zmienić implementację, a cały kod dookoła będzie dalej się kompilował: Set&amp;lt;Son&amp;gt; sonSet = new HashSet&amp;lt;&amp;gt;(); I prawdopodobnie działał. Jest jednak jeden wyjątek od tej zasady. Jeśli konkretna implementacja oferuję jakąś specjalną funkcjonalność, która nie jest zagwarantowana przez interfejs i kod polega na tej funkcjonalności, to nie powinniśmy używać ogólnego interfejsu jako deklaracji typu. Przykładem tutaj mogłoby być to, że nasz kod polegałby na sortowaniu zapewnionym przez LinkedHashSet. Wtedy byłoby nieodpowiednie zadeklarowanie typu tej zmiennej jako Set ponieważ interfejs Set sam w sobie nie daję żadnej gwarancji odnośnie sortowania. Oczywiście jest wiele przypadków, gdzie klasy nie mają swoich interfejsów, szczególnie tzw. value classes jak np. String czy BigInteger. Wtedy naturalnie będziemy używać konkretnych klas i nie ma w tym nic złego. Postarajmy się wtedy używać po prostu klasę najwyżej w hierarchii, która ma wymaganą przez nas funkcjonalność. Czasem musimy zrobić też użytek z metod, które występują w klasie konkretnej, a nie ma ich na interfejsie - wtedy też użyjemy klasy konkretnej jako deklaracji typu i nie ma w tym nic złego.</summary></entry><entry><title type="html">Zasięg zmiennych, pętle i biblioteki</title><link href="https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki" rel="alternate" type="text/html" title="Zasięg zmiennych, pętle i biblioteki" /><published>2019-02-23T09:00:00+01:00</published><updated>2019-02-23T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki</id><content type="html" xml:base="https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 57, 58, 59&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Minimize the scope of local variables
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Prefer for-each loops to traditional for loops
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Know and use the libraries
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;W tym rozdziale jest zawarta kolejna porcja dobrych praktyk dla featureów Javy. Będzie też o refleksji, natywnych metodach i optymalizacji.
Jednak to potem, najpierw trzy pierwsze tematy:&lt;/p&gt;

&lt;h1 id=&quot;minimalizowanie-zasięgu-zmiennych&quot;&gt;Minimalizowanie zasięgu zmiennych&lt;/h1&gt;

&lt;p&gt;Dlaczego jest to ważne? Ano sprawia, że kod jest bardziej czytelny i mniej podatny na błedy.&lt;/p&gt;

&lt;p&gt;Zmienne powinny być deklarowane najbliżej pierwszego użycia. W przeciwnym wypadku będzie to zaśmiecać inny niepowiązany kawałek kodu i wprowadzać chaos.&lt;/p&gt;

&lt;p&gt;Deklarując zmienną zbyt wcześnie, nie tylko sprawiamy, że zasięg zaczyna się zbyt wcześnie, ale też kończy zbyt późno. Raczej nie powinno się rozdzielać deklaracji od zainicializowania, jedynym wyjątkiem tutaj jest try catch, gdzie jest to wymuszone.&lt;/p&gt;

&lt;p&gt;Pętle oferują dodatkową możliwość na zmniejszenie zasięgu zmiennych. Możemy w nich zadeklarować zmienne pętli, w rezultacie ograniczając ich zasięg tylko do pętli.&lt;/p&gt;

&lt;p&gt;Jednak preferowany sposób na iterowanie po kolekcji to:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Preferred idiom for iterating over a collection or array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do Something with e&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli potrzebujemy dostępu do iteratora, np. żeby wywołać metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt; to:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Idiom for iterating when you need the iterator&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e and i&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dlaczego te są preferowane, a nie pętle while? Prosty przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// BUG!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Druga pętla przez przypadek używa pierwszego iteratora, który nadal jest w zasięgu. Kod kompiluje się i wykonuje bez błędu.&lt;/p&gt;

&lt;p&gt;W przypadku zwykłych pętli nie ma takiej opcji:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e and i&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Compile-time error - cannot find symbol i&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e2 and i2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu inny przykład na minimalizowanie zasięgu zmiennej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expensiveComputation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with i;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Deklarujmy 2 zmienne pętli, aby uniknąć kosztownego i niepotrzebnego obliczania &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; w każdej iteracji pętli jednocześnie ograniczając jej zasięg tylko do pętli.&lt;/p&gt;

&lt;p&gt;Ostatnią ogólną dobrą techniką minimalizowania zasięgu zmiennych jest utrzymywanie metod krótkich i konkretnych. Jeśli połączone są 2 czynności w jednej metodzie i mają zmienne wymieszane między sobą, to dobrze jest je rozdzielić.&lt;/p&gt;

&lt;h1 id=&quot;preferuj-pętle-for-each&quot;&gt;Preferuj pętle for-each&lt;/h1&gt;

&lt;p&gt;Lekcja w tym temacie jest dosyć oczywista i wydaje mi się, że powszechnie stosowana, więc tylko na szybko - używaj zawsze for-each, jeśli nie potrzebujesz dostępu do indexu.&lt;/p&gt;

&lt;p&gt;Redukuje to boilerplate, zmniejsza szum, przez co kod jest bardziej czytelny, oraz nie mamy możliwości popełnienia błędu:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The preferred idiom for iterating over collections and arrays&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co jest ważne - nie ma tu utraty wydajności czy jakiegoś innego skutku ubocznego - kod kompiluje się do niemal identycznej tradycyjnej pętli.&lt;/p&gt;

&lt;p&gt;Te pętle też są łatwiejsze w użyciu w przypadku zagnieżdżonych pętli. Ze zwykłymi pętlami można zrobić następujący błąd:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Can you spot the bug?&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLUB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIAMOND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEART&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEUCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIVE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEVEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EIGHT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;NINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JACK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QUEEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Widzisz go? Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt; dla &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; jest wywoływana w złym miejscu. Powinna być wywołana wcześniej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Fixed, but ugly - you can do better!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Teraz działa, jednak jest to mało czytelne - dużo lepiej jest używać po prostu for-each:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Preferred idiom for nested iteration on collections and arrays&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jednak są 3 sytuacje, kiedy nie zrobimy z nich użytku:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gdy chcemy usunąć elementy z kolekcji. Wtedy musimy skorzystać z iteratora lub lepiej - użyć dodanej w Javie 8 metody &lt;code class=&quot;highlighter-rouge&quot;&gt;removeIf&lt;/code&gt; do kolekcji.&lt;/li&gt;
  &lt;li&gt;Gdy chcemy podmienić jakieś elementy&lt;/li&gt;
  &lt;li&gt;Współbieżne iterowanie&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Warto zaznaczyć fakt, że możemy iterować pętlą for-each po każdym obiekcie, który implementuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;poznaj-i-używaj-biblioteki&quot;&gt;Poznaj i używaj biblioteki&lt;/h1&gt;

&lt;p&gt;Trzeci temat mówi o ważności znajomości bibliotek i o tym, by nie wynajdować koła na nowo.&lt;/p&gt;

&lt;p&gt;Weźmy na przykład, że chcemy wygenerować losowe liczby od 0 do n. Natykając się na tak powszechny problem, możesz być niemal pewny, że ktoś już stworzył do tego dobrze działający algorytm.&lt;/p&gt;

&lt;p&gt;By napisać samemu taki algorytm, musiałbyś sporo wiedzieć o pseudolosowych generatorach liczb, teorii liczb i kodzie uzupełnień do dwóch. Na szczęście ten problem mamy już rozwiązany w Javie.&lt;/p&gt;

&lt;p&gt;Od Javy 7 nie powinniśmy już używać do tego klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Random&lt;/code&gt;. Dla większości użyć dobrym wyborem jest &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalRandom&lt;/code&gt;. Produkuje lepszej jakości liczby losowe i jest dużo szybszy od poprzednika. Dla &lt;code class=&quot;highlighter-rouge&quot;&gt;ForkJoinPool&lt;/code&gt; i współbieżnych streamów używaj &lt;code class=&quot;highlighter-rouge&quot;&gt;SplittableRandom&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Drugą przewagą bibliotek jest to, że nie musisz tracić czasu na rzeźbienie rozwiązań dla niepowiązanych zbytnio z aplikacją powszechnym problemów, a możesz skupić się na tworzeniu aplikacji i jej funkcjonalności.&lt;/p&gt;

&lt;p&gt;Kolejną przewagą jest to, że biblioteki najczęściej są cały czas rozwijane (czasem przez całe zespoły) i testowane przez tysiące użytkowników, więc dostajemy solidne, wydajne i przetestowane rozwiązanie niemal za darmo.&lt;/p&gt;

&lt;p&gt;Mimo tylu zalet dużo programistów nadal nie używa bibliotek w pełni - czemu? Najprawdopodobniej
 dlatego, że ich do końca nie znają. Dlatego ważne jest, żeby zaznajamiać się z każdymi nowościami wchodzącymi do Javy i innych bibliotek. Często wprowadzane jest wiele usprawnień, które znacznie poprawiają choćby czytelność i kod klienta.&lt;/p&gt;

&lt;p&gt;Kompletnie podstawowym zestawem bibliotek każdego programisty powinny być przynajmniej te z:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java.lang&lt;/li&gt;
  &lt;li&gt;java.util&lt;/li&gt;
  &lt;li&gt;java.io&lt;/li&gt;
  &lt;li&gt;collections  framkework&lt;/li&gt;
  &lt;li&gt;biblioteka stremów&lt;/li&gt;
  &lt;li&gt;java.util.concurrent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeśli nie możesz znaleźć czegoś w bibliotekach Javy, następnym dobrym wyborem mogą być biblioteki firm trzecich jak np. googlowska &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Podsumowując, zmierzając się z jakimiś powszechnym problemem, nie wynajduj koła na nowo - używaj bibliotek w jak najbardziej efektywny sposób, a do rzeźbienia czegoś samemu zabieraj się tylko wtedy, gdy żadna biblioteka nie spełnia twoich potrzeb.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 57, 58, 59 z rozdziału 9: General Programming Minimize the scope of local variables Prefer for-each loops to traditional for loops Know and use the libraries Avoid float and double if exact answers are required Prefer primitive types to boxed primitives Avoid strings where other types are more appropriate Beware the performance of string concatenation Refer to objects by their interfaces Prefer interfaces to reflection Use native methods judiciously Optimize judiciously Adhere to generally accepted naming conventions W tym rozdziale jest zawarta kolejna porcja dobrych praktyk dla featureów Javy. Będzie też o refleksji, natywnych metodach i optymalizacji. Jednak to potem, najpierw trzy pierwsze tematy: Minimalizowanie zasięgu zmiennych Dlaczego jest to ważne? Ano sprawia, że kod jest bardziej czytelny i mniej podatny na błedy. Zmienne powinny być deklarowane najbliżej pierwszego użycia. W przeciwnym wypadku będzie to zaśmiecać inny niepowiązany kawałek kodu i wprowadzać chaos. Deklarując zmienną zbyt wcześnie, nie tylko sprawiamy, że zasięg zaczyna się zbyt wcześnie, ale też kończy zbyt późno. Raczej nie powinno się rozdzielać deklaracji od zainicializowania, jedynym wyjątkiem tutaj jest try catch, gdzie jest to wymuszone. Pętle oferują dodatkową możliwość na zmniejszenie zasięgu zmiennych. Możemy w nich zadeklarować zmienne pętli, w rezultacie ograniczając ich zasięg tylko do pętli. Jednak preferowany sposób na iterowanie po kolekcji to: // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Something with e } Jeśli potrzebujemy dostępu do iteratora, np. żeby wywołać metodę remove() to: // Idiom for iterating when you need the iterator for (Iterator&amp;lt;Element&amp;gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do something with e and i } Dlaczego te są preferowane, a nie pętle while? Prosty przykład: Iterator&amp;lt;Element&amp;gt; i = c.iterator(); while (i.hasNext()) { doSomething(i.next()); } ... Iterator&amp;lt;Element&amp;gt; i2 = c2.iterator(); while (i.hasNext()) { // BUG! doSomethingElse(i2.next()); } Druga pętla przez przypadek używa pierwszego iteratora, który nadal jest w zasięgu. Kod kompiluje się i wykonuje bez błędu. W przypadku zwykłych pętli nie ma takiej opcji: for (Iterator&amp;lt;Element&amp;gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do something with e and i } ... // Compile-time error - cannot find symbol i for (Iterator&amp;lt;Element&amp;gt; i2 = c2.iterator(); i.hasNext(); ) { Element e2 = i2.next(); ... // Do something with e2 and i2 } Tu inny przykład na minimalizowanie zasięgu zmiennej: for (int i = 0, n = expensiveComputation(); i &amp;lt; n; i++) { ... // Do something with i; } Deklarujmy 2 zmienne pętli, aby uniknąć kosztownego i niepotrzebnego obliczania n w każdej iteracji pętli jednocześnie ograniczając jej zasięg tylko do pętli. Ostatnią ogólną dobrą techniką minimalizowania zasięgu zmiennych jest utrzymywanie metod krótkich i konkretnych. Jeśli połączone są 2 czynności w jednej metodzie i mają zmienne wymieszane między sobą, to dobrze jest je rozdzielić. Preferuj pętle for-each Lekcja w tym temacie jest dosyć oczywista i wydaje mi się, że powszechnie stosowana, więc tylko na szybko - używaj zawsze for-each, jeśli nie potrzebujesz dostępu do indexu. Redukuje to boilerplate, zmniejsza szum, przez co kod jest bardziej czytelny, oraz nie mamy możliwości popełnienia błędu: // The preferred idiom for iterating over collections and arrays for (Element e : elements) { ... // Do something with e } Co jest ważne - nie ma tu utraty wydajności czy jakiegoś innego skutku ubocznego - kod kompiluje się do niemal identycznej tradycyjnej pętli. Te pętle też są łatwiejsze w użyciu w przypadku zagnieżdżonych pętli. Ze zwykłymi pętlami można zrobić następujący błąd: // Can you spot the bug? enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection&amp;lt;Suit&amp;gt; suits = Arrays.asList(Suit.values()); static Collection&amp;lt;Rank&amp;gt; ranks = Arrays.asList(Rank.values()); List&amp;lt;Card&amp;gt; deck = new ArrayList&amp;lt;&amp;gt;(); for (Iterator&amp;lt;Suit&amp;gt; i = suits.iterator(); i.hasNext(); ) for (Iterator&amp;lt;Rank&amp;gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); Widzisz go? Metoda next() dla i jest wywoływana w złym miejscu. Powinna być wywołana wcześniej: // Fixed, but ugly - you can do better! for (Iterator&amp;lt;Suit&amp;gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator&amp;lt;Rank&amp;gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } Teraz działa, jednak jest to mało czytelne - dużo lepiej jest używać po prostu for-each: // Preferred idiom for nested iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); Jednak są 3 sytuacje, kiedy nie zrobimy z nich użytku: Gdy chcemy usunąć elementy z kolekcji. Wtedy musimy skorzystać z iteratora lub lepiej - użyć dodanej w Javie 8 metody removeIf do kolekcji. Gdy chcemy podmienić jakieś elementy Współbieżne iterowanie Warto zaznaczyć fakt, że możemy iterować pętlą for-each po każdym obiekcie, który implementuje Iterable. Poznaj i używaj biblioteki Trzeci temat mówi o ważności znajomości bibliotek i o tym, by nie wynajdować koła na nowo. Weźmy na przykład, że chcemy wygenerować losowe liczby od 0 do n. Natykając się na tak powszechny problem, możesz być niemal pewny, że ktoś już stworzył do tego dobrze działający algorytm. By napisać samemu taki algorytm, musiałbyś sporo wiedzieć o pseudolosowych generatorach liczb, teorii liczb i kodzie uzupełnień do dwóch. Na szczęście ten problem mamy już rozwiązany w Javie. Od Javy 7 nie powinniśmy już używać do tego klasy Random. Dla większości użyć dobrym wyborem jest ThreadLocalRandom. Produkuje lepszej jakości liczby losowe i jest dużo szybszy od poprzednika. Dla ForkJoinPool i współbieżnych streamów używaj SplittableRandom. Drugą przewagą bibliotek jest to, że nie musisz tracić czasu na rzeźbienie rozwiązań dla niepowiązanych zbytnio z aplikacją powszechnym problemów, a możesz skupić się na tworzeniu aplikacji i jej funkcjonalności. Kolejną przewagą jest to, że biblioteki najczęściej są cały czas rozwijane (czasem przez całe zespoły) i testowane przez tysiące użytkowników, więc dostajemy solidne, wydajne i przetestowane rozwiązanie niemal za darmo. Mimo tylu zalet dużo programistów nadal nie używa bibliotek w pełni - czemu? Najprawdopodobniej dlatego, że ich do końca nie znają. Dlatego ważne jest, żeby zaznajamiać się z każdymi nowościami wchodzącymi do Javy i innych bibliotek. Często wprowadzane jest wiele usprawnień, które znacznie poprawiają choćby czytelność i kod klienta. Kompletnie podstawowym zestawem bibliotek każdego programisty powinny być przynajmniej te z: java.lang java.util java.io collections framkework biblioteka stremów java.util.concurrent Jeśli nie możesz znaleźć czegoś w bibliotekach Javy, następnym dobrym wyborem mogą być biblioteki firm trzecich jak np. googlowska Guava. Podsumowując, zmierzając się z jakimiś powszechnym problemem, nie wynajduj koła na nowo - używaj bibliotek w jak najbardziej efektywny sposób, a do rzeźbienia czegoś samemu zabieraj się tylko wtedy, gdy żadna biblioteka nie spełnia twoich potrzeb.</summary></entry><entry><title type="html">Vargargi, nulle i Optionale</title><link href="https://devcave.pl/effective-java/vargargi-nulle-i-optionale" rel="alternate" type="text/html" title="Vargargi, nulle i Optionale" /><published>2019-02-16T09:00:00+01:00</published><updated>2019-02-16T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/vargargi-nulle-i-optionale</id><content type="html" xml:base="https://devcave.pl/effective-java/vargargi-nulle-i-optionale">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 53, 54, 55, 56&lt;/i&gt; z rozdziału 8:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Methods&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 49: Check parameters for validity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 50: Make defensive copies when needed
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 51: Design method signatures carefully
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 52: Use overloading judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 53: Use varargs judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 54: Return empty collections or arrays, not nulls
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 55: Return optionals judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 56: Write doc comments for all exposed API elements
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;używanie-vararg&quot;&gt;Używanie vararg&lt;/h1&gt;

&lt;p&gt;Co to są varargs? Jest to po prostu zmienna ilość parametrów zadeklarowana jako jeden argument. Można to porównać do tablicy - może przechowaywać zero lub więcej argumentów. 
Pod spodem działa to tak że tworzona jest tablica wielkości liczby podanych elementów, a następnie te wartości są w niej umieszczane i do metody przekazywana jest tablica.&lt;/p&gt;

&lt;p&gt;Przykładowe proste użycie vargarg:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Simple use of varargs&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Vargarg deklaruje się za pomocą &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; dodanym do typu. I np. &lt;code class=&quot;highlighter-rouge&quot;&gt;sum(1, 2, 3)&lt;/code&gt; zwróci 6, a &lt;code class=&quot;highlighter-rouge&quot;&gt;sum()&lt;/code&gt; zero. Myślę, że działanie jest dosyć jasne.&lt;/p&gt;

&lt;p&gt;Varargs nie nadają się jednak w przypadku, gdy chcemy mieć przynajmniej jeden 
argument, np. chcąc policzyć minimum. Musielibyśmy wtedy dodać specjalne sprawdzenie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The WRONG way to use varargs to pass one or more arguments!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Too few arguments&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jednak to rozwiązanie nie jest dobre:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sprawdzenie odbywa się dopiero w runtime, więc nie widać błedu podczas pisania kodu&lt;/li&gt;
  &lt;li&gt;jest brzydkie i nadmiarowe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jest na to dużo lepszy sposób - zadeklarować metodę przyjmującą pierwszy argument, a jako drugi argument podać varargs:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The right way to use varargs to pass one or more arguments&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W super ekstremalnych warunkach (w których prawdopodobnie nigdy nie będziesz), gdzie liczy się wydajność i wiemy, że np. 90% wywołań ma mniej niż 3 argumenty, możemy użyć kilku przeciążeń metody, aby uniknąć nadmiarowego tworzenia tablic:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Statyczne fabryki dla &lt;code class=&quot;highlighter-rouge&quot;&gt;EnumSet&lt;/code&gt; w standardowej bibliotece używają tej techniki.&lt;/p&gt;

&lt;h1 id=&quot;zwracaj-puste-kolekcje-nie-nulle&quot;&gt;Zwracaj puste kolekcje, nie nulle&lt;/h1&gt;

&lt;p&gt;Czasem można spotkać metody podobne do tej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Returns null to indicate an empty collection. Don't do this!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @return a list containing all of the cheeses in the shop,
 *     or null if no cheeses are available for purchase.
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie ma powodu, aby traktować puste kolekcje w specjalny sposób i zwracać null, jeśli są puste. Na pewno nie jest to też dobra praktyka. Dodatkowo zmusza to klienta, by obsłużyć tę sytuację w miejscach, gdzie normalnie by tego nie robił:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheeses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheesdes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STILTON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Jolly good, just the thing.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Argumenty typu, że powinny być preferowane nulle, ponieważ wtedy nie alokujemy pamięci na pusty kontener, nie mają sensu w dzisiejszych aplikacjach. Martwienie się wydajnością na tym poziomie jest zbędną przedwczesną optymalizacją, która w 95% nie przyniesie żadnej korzyści.&lt;/p&gt;

&lt;p&gt;Ponadto używając niemutowalnych pustych kolekcji typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptyList&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptySet&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptyMap&lt;/code&gt; całkowicie eliminujemy ten problem, bo wtedy reużywamy jedną i tą samą pustą kolekcję.&lt;/p&gt;

&lt;p&gt;Podobnie wygląda sytuacja dla tablic, nie powinno się zwracać nulli zamiast pustej tablicy.&lt;/p&gt;

&lt;p&gt;Lekcja z tego tematu jest jasna - nie zwracaj nulli zamiast pustych kolekcji czy tablic. Pogarsza to tylko kod klienta i nie ma żadnych sensownych korzyści.&lt;/p&gt;

&lt;h1 id=&quot;zwracanie-optional&quot;&gt;Zwracanie Optional&lt;/h1&gt;

&lt;p&gt;Przed Java 8 mieliśmy dwa sposoby na pisanie metod, które nie mogłyby zwrócić danej wartości w określonych warunkach. Można było albo rzucić wyjątkiem, albo po prostu zwrócić null (jeśli zwracany typ nie był prymitywem). Żaden z nich nie był idealnym sposobem. Wyjątki powinny być stosowane tylko w wyjątkowych sytuacjach, a do tego rzucanie wyjątku jest nieco kosztowne, bo wraz z wyjątkiem tworzony jest cały stack trace.&lt;/p&gt;

&lt;p&gt;Zwracanie nulla nie ma tych wad, jednak tak samo wymaga od klienta specjalnego obsłużenia, które czasem nie jest oczywiste.&lt;/p&gt;

&lt;p&gt;Od Javy 8 jest też trzeci wbudowany sposób - klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;. Reprezentuje ona niemutowalny kontener, który może przetrzymywać pojedynczą referencję do obiektu (która nie jest nullem) lub nic, czyli może być pusty.&lt;/p&gt;

&lt;p&gt;Więc gdy metoda zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, ale jak pod jakimiś warunkami może nie być w stanie zwrócić &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, to wtedy może zadeklarować zwracany typ jako &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Metoda, która zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; jest nieco bardziej elastyczna i łatwiejsza w użyciu niż rzucanie i obsługa wyjątku czy zwracanie nulla + obsługa. Czasem może nie być oczywsite, że metoda może zwrócić null, zwłaszcza gdy nie mamy dostępu do dokumentacji lub jej po prostu nie ma. Dzięki &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; mamy tę informację bezpośrednio w API i jest jasne, że metoda może nie być w stanie zwrócić tej wartości.&lt;/p&gt;

&lt;p&gt;Przykładowe użycie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Returns maximum value in collection as an Optional&amp;lt;E&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        
    &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jak widać, jest to całkiem proste. Bez &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; metoda mogłaby rzucić &lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;, gdyby kolekcja z parametru była pusta, jednak wtedy kod klienta nie byłby tak czysty w użyciu, bo wymagałby boilerplatu try catch.&lt;/p&gt;

&lt;p&gt;Jest też wariant, który może przyjąć null: &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional.ofNullable(value)&lt;/code&gt; i zwraca pusty &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt;, jeśli został podany null.&lt;/p&gt;

&lt;p&gt;Użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; można spotkać w standardowej blibliotece np.  używając streamów.&lt;/p&gt;

&lt;p&gt;Czy zawsze jednak warto stosować &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; czy rzucenia wyjątkiem?&lt;/p&gt;

&lt;p&gt;Optionale są podobne w założeniu co rzucanie &lt;em&gt;checked exception&lt;/em&gt; - oba jasno informują klienta API, że wartość może być nie zwrócona, jednak te drugie wymagają od niego więcej boilerplate-u.&lt;/p&gt;

&lt;p&gt;Optionale oferują nam do dyspozycji kilka pomocnych metod, które pozwalają pisać zwięzły kod. Np.: możemy podać domyślną wartość:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Using an optional to provide a chosen default value&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastWordInLexicon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No words...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;lub rzucić wyjątkiem:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Using an optional to throw a chosen exception&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Toy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myToy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseThrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;TemperTantrumException:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;note&quot;&gt;Zauważ, że podawana jest referencja do konstruktora, więc wyjątek nie zostanie utworzony, dopóki nie zajdzie taka potrzeba.&lt;/p&gt;

&lt;p&gt;Inne przykłady to &lt;code class=&quot;highlighter-rouge&quot;&gt;orElseGet&lt;/code&gt;, który przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;, by uniknąć kosztu tworzenia obiektu zbyt wcześnie oraz &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;W Javie 9 dodano także &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresentOrElse&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Warto znać te inne metody, bo czasem można zwięźle zastąpić nimi zwykłe sprawdzania &lt;code class=&quot;highlighter-rouge&quot;&gt;isPresent&lt;/code&gt;. Dla przykładu metoda, która pokazuje ID parenta danego procesu lub N/A, jeśli go nie ma:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent PID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isPresent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;N/A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A tak wygląda to samo z wykorzystaniem metody &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent PID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;N/A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optionalów nie powinno się używać do opakowywania kolekcji, podobnie jak w przypadku zwracania null, gdy są puste.&lt;/p&gt;

&lt;p&gt;Odpowiadając wreszcie na pytanie - Optionale są bardzo dobrą alternatywą dla nulli i rzucania wyjątków, gdy metoda nie może zwrócić danej wartości. Jedyna opcja gdzie mógłoby to być nieodpowiednie, to w sytuacjach, gdzie wydajność jest krytyczna i takie mikro optymalizacje mają sens, ale w 95% przypadkach tak nie jest.&lt;/p&gt;

&lt;h1 id=&quot;dokumentacja&quot;&gt;Dokumentacja&lt;/h1&gt;

&lt;p&gt;Jeśli publiczne API ma być użyteczne, powinno być udokumentowane, dlatego zwieńczeniem naszej pracy powinna być dokumentacja.&lt;/p&gt;

&lt;p&gt;W Javie mamy narzędzie Javadoc, które ułatwia nam to, generując dokumentację API automatycznie z kodu źródłowego.&lt;/p&gt;

&lt;p&gt;Konwencje dokumentacji nie są częścią języka, jednak są swojego rodzaju API, które każdy programista powinien znać. Te konwencje są opisane na stronie &lt;a href=&quot;https://www.oracle.com/technetwork/articles/java/index-137868.html&quot;&gt;How to Write Doc Comments&lt;/a&gt; jednak nie była ona updatowana od Javy 4 i nie ma opisanych kilku tagów dodanych w Javie:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;9 - {@index}&lt;/li&gt;
  &lt;li&gt;8 - {@implSpec}&lt;/li&gt;
  &lt;li&gt;5 - {@literal}, {@code}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Publiczne API powinno mieć udokumentowane co najmniej każdą publiczną klasę, interfejs, konstruktor, metodę i pole.&lt;/p&gt;

&lt;p&gt;Resztę szczegółów z tego tematu pozwoliłem sobie pominąć - jakby ktoś chciał zobaczyć przykłady i wprowadzenie w temat to odsyłam do &lt;a href=&quot;https://www.baeldung.com/javadoc&quot;&gt;Introduction to Javadoc&lt;/a&gt;&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 53, 54, 55, 56 z rozdziału 8: Methods Item 49: Check parameters for validity Item 50: Make defensive copies when needed Item 51: Design method signatures carefully Item 52: Use overloading judiciously Item 53: Use varargs judiciously Item 54: Return empty collections or arrays, not nulls Item 55: Return optionals judiciously Item 56: Write doc comments for all exposed API elements Używanie vararg Co to są varargs? Jest to po prostu zmienna ilość parametrów zadeklarowana jako jeden argument. Można to porównać do tablicy - może przechowaywać zero lub więcej argumentów. Pod spodem działa to tak że tworzona jest tablica wielkości liczby podanych elementów, a następnie te wartości są w niej umieszczane i do metody przekazywana jest tablica. Przykładowe proste użycie vargarg: // Simple use of varargs static int sum(int... args) { int sum = 0; for (int arg : args) sum += arg; return sum; } Vargarg deklaruje się za pomocą ... dodanym do typu. I np. sum(1, 2, 3) zwróci 6, a sum() zero. Myślę, że działanie jest dosyć jasne. Varargs nie nadają się jednak w przypadku, gdy chcemy mieć przynajmniej jeden argument, np. chcąc policzyć minimum. Musielibyśmy wtedy dodać specjalne sprawdzenie: // The WRONG way to use varargs to pass one or more arguments! static int min(int... args) { if (args.length == 0) throw new IllegalArgumentException(&quot;Too few arguments&quot;); int min = args[0]; for (int i = 1; i &amp;lt; args.length; i++) if (args[i] &amp;lt; min) min = args[i]; return min; } Jednak to rozwiązanie nie jest dobre: sprawdzenie odbywa się dopiero w runtime, więc nie widać błedu podczas pisania kodu jest brzydkie i nadmiarowe. Jest na to dużo lepszy sposób - zadeklarować metodę przyjmującą pierwszy argument, a jako drugi argument podać varargs: // The right way to use varargs to pass one or more arguments static int min(int firstArg, int... remainingArgs) { int min = firstArg; for (int arg : remainingArgs) if (arg &amp;lt; min) min = arg; return min; } W super ekstremalnych warunkach (w których prawdopodobnie nigdy nie będziesz), gdzie liczy się wydajność i wiemy, że np. 90% wywołań ma mniej niż 3 argumenty, możemy użyć kilku przeciążeń metody, aby uniknąć nadmiarowego tworzenia tablic: public void foo() { } public void foo(int a1) { } public void foo(int a1, int a2) { } public void foo(int a1, int a2, int a3) { } public void foo(int a1, int a2, int a3, int... rest) { } Statyczne fabryki dla EnumSet w standardowej bibliotece używają tej techniki. Zwracaj puste kolekcje, nie nulle Czasem można spotkać metody podobne do tej: // Returns null to indicate an empty collection. Don't do this! private final List&amp;lt;Cheese&amp;gt; cheesesInStock = ...; /** * @return a list containing all of the cheeses in the shop, * or null if no cheeses are available for purchase. */ public List&amp;lt;Cheese&amp;gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList&amp;lt;&amp;gt;(cheesesInStock); } Nie ma powodu, aby traktować puste kolekcje w specjalny sposób i zwracać null, jeśli są puste. Na pewno nie jest to też dobra praktyka. Dodatkowo zmusza to klienta, by obsłużyć tę sytuację w miejscach, gdzie normalnie by tego nie robił: List&amp;lt;Cheese&amp;gt; cheeses = shop.getCheeses(); if (cheesdes != null &amp;amp;&amp;amp; cheeses.contains(Cheese.STILTON)) System.out.println(&quot;Jolly good, just the thing.&quot;); Argumenty typu, że powinny być preferowane nulle, ponieważ wtedy nie alokujemy pamięci na pusty kontener, nie mają sensu w dzisiejszych aplikacjach. Martwienie się wydajnością na tym poziomie jest zbędną przedwczesną optymalizacją, która w 95% nie przyniesie żadnej korzyści. Ponadto używając niemutowalnych pustych kolekcji typu Collections.emptyList, Collections.emptySet czy Collections.emptyMap całkowicie eliminujemy ten problem, bo wtedy reużywamy jedną i tą samą pustą kolekcję. Podobnie wygląda sytuacja dla tablic, nie powinno się zwracać nulli zamiast pustej tablicy. Lekcja z tego tematu jest jasna - nie zwracaj nulli zamiast pustych kolekcji czy tablic. Pogarsza to tylko kod klienta i nie ma żadnych sensownych korzyści. Zwracanie Optional Przed Java 8 mieliśmy dwa sposoby na pisanie metod, które nie mogłyby zwrócić danej wartości w określonych warunkach. Można było albo rzucić wyjątkiem, albo po prostu zwrócić null (jeśli zwracany typ nie był prymitywem). Żaden z nich nie był idealnym sposobem. Wyjątki powinny być stosowane tylko w wyjątkowych sytuacjach, a do tego rzucanie wyjątku jest nieco kosztowne, bo wraz z wyjątkiem tworzony jest cały stack trace. Zwracanie nulla nie ma tych wad, jednak tak samo wymaga od klienta specjalnego obsłużenia, które czasem nie jest oczywiste. Od Javy 8 jest też trzeci wbudowany sposób - klasa Optional&amp;lt;T&amp;gt;. Reprezentuje ona niemutowalny kontener, który może przetrzymywać pojedynczą referencję do obiektu (która nie jest nullem) lub nic, czyli może być pusty. Więc gdy metoda zwraca T, ale jak pod jakimiś warunkami może nie być w stanie zwrócić T, to wtedy może zadeklarować zwracany typ jako Optional&amp;lt;T&amp;gt;. Metoda, która zwraca Optional jest nieco bardziej elastyczna i łatwiejsza w użyciu niż rzucanie i obsługa wyjątku czy zwracanie nulla + obsługa. Czasem może nie być oczywsite, że metoda może zwrócić null, zwłaszcza gdy nie mamy dostępu do dokumentacji lub jej po prostu nie ma. Dzięki Optional mamy tę informację bezpośrednio w API i jest jasne, że metoda może nie być w stanie zwrócić tej wartości. Przykładowe użycie: // Returns maximum value in collection as an Optional&amp;lt;E&amp;gt; public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; Optional&amp;lt;E&amp;gt; max(Collection&amp;lt;E&amp;gt; c) { if (c.isEmpty()) return Optional.empty(); E result = null; for (E e : c) if (result == null || e.compareTo(result) &amp;gt; 0) result = Objects.requireNonNull(e); return Optional.of(result); } Jak widać, jest to całkiem proste. Bez Optional metoda mogłaby rzucić IllegalArgumentException, gdyby kolekcja z parametru była pusta, jednak wtedy kod klienta nie byłby tak czysty w użyciu, bo wymagałby boilerplatu try catch. Jest też wariant, który może przyjąć null: Optional.ofNullable(value) i zwraca pusty Optional, jeśli został podany null. Użycie Optional można spotkać w standardowej blibliotece np. używając streamów. Czy zawsze jednak warto stosować Optional zamiast null czy rzucenia wyjątkiem? Optionale są podobne w założeniu co rzucanie checked exception - oba jasno informują klienta API, że wartość może być nie zwrócona, jednak te drugie wymagają od niego więcej boilerplate-u. Optionale oferują nam do dyspozycji kilka pomocnych metod, które pozwalają pisać zwięzły kod. Np.: możemy podać domyślną wartość: // Using an optional to provide a chosen default value String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;); lub rzucić wyjątkiem: // Using an optional to throw a chosen exception Toy myToy = max(toys).orElseThrow(TemperTantrumException::new); Zauważ, że podawana jest referencja do konstruktora, więc wyjątek nie zostanie utworzony, dopóki nie zajdzie taka potrzeba. Inne przykłady to orElseGet, który przyjmuje Supplier&amp;lt;T&amp;gt;, by uniknąć kosztu tworzenia obiektu zbyt wcześnie oraz filter, map, flatMap czy ifPresent. W Javie 9 dodano także or i ifPresentOrElse. Warto znać te inne metody, bo czasem można zwięźle zastąpić nimi zwykłe sprawdzania isPresent. Dla przykładu metoda, która pokazuje ID parenta danego procesu lub N/A, jeśli go nie ma: Optional&amp;lt;ProcessHandle&amp;gt; parentProcess = ph.parent(); System.out.println(&quot;Parent PID: &quot; + (parentProcess.isPresent() ? String.valueOf(parentProcess.get().pid()) : &quot;N/A&quot;)); A tak wygląda to samo z wykorzystaniem metody map: System.out.println(&quot;Parent PID: &quot; + ph.parent().map(h -&amp;gt; String.valueOf(h.pid())).orElse(&quot;N/A&quot;)); Optionalów nie powinno się używać do opakowywania kolekcji, podobnie jak w przypadku zwracania null, gdy są puste. Odpowiadając wreszcie na pytanie - Optionale są bardzo dobrą alternatywą dla nulli i rzucania wyjątków, gdy metoda nie może zwrócić danej wartości. Jedyna opcja gdzie mógłoby to być nieodpowiednie, to w sytuacjach, gdzie wydajność jest krytyczna i takie mikro optymalizacje mają sens, ale w 95% przypadkach tak nie jest. Dokumentacja Jeśli publiczne API ma być użyteczne, powinno być udokumentowane, dlatego zwieńczeniem naszej pracy powinna być dokumentacja. W Javie mamy narzędzie Javadoc, które ułatwia nam to, generując dokumentację API automatycznie z kodu źródłowego. Konwencje dokumentacji nie są częścią języka, jednak są swojego rodzaju API, które każdy programista powinien znać. Te konwencje są opisane na stronie How to Write Doc Comments jednak nie była ona updatowana od Javy 4 i nie ma opisanych kilku tagów dodanych w Javie: 9 - {@index} 8 - {@implSpec} 5 - {@literal}, {@code} Publiczne API powinno mieć udokumentowane co najmniej każdą publiczną klasę, interfejs, konstruktor, metodę i pole. Resztę szczegółów z tego tematu pozwoliłem sobie pominąć - jakby ktoś chciał zobaczyć przykłady i wprowadzenie w temat to odsyłam do Introduction to Javadoc</summary></entry><entry><title type="html">Projektowanie metod</title><link href="https://devcave.pl/effective-java/projektowanie-metod-i-przeciazenie" rel="alternate" type="text/html" title="Projektowanie metod" /><published>2019-02-09T09:00:00+01:00</published><updated>2019-02-09T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/projektowanie-metod-i-przeciazenie</id><content type="html" xml:base="https://devcave.pl/effective-java/projektowanie-metod-i-przeciazenie">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 51, 52&lt;/i&gt; z rozdziału 8:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Methods&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 49: Check parameters for validity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 50: Make defensive copies when needed
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 51: Design method signatures carefully
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 52: Use overloading judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 53: Use varargs judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 54: Return empty collections or arrays, not nulls
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 55: Return optionals judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 56: Write doc comments for all exposed API elements
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;projektowanie-metod&quot;&gt;Projektowanie metod&lt;/h1&gt;

&lt;p&gt;W tym temacie zebrane jest kilka wskazówek na temat projektowania API, aby było łatwiejsze w użyciu i bardziej odporne na błędy.&lt;/p&gt;

&lt;h2 id=&quot;nazwy-metod&quot;&gt;Nazwy metod&lt;/h2&gt;

&lt;p&gt;Nazwy metod oczywiście zawsze powinny przestrzegać konwencji nazewniczych, ale równie ważne jest dobranie dobrej nazwy metody. Nazwa powinna być zwięzła, łatwa w zrozumieniu i dobrze opisująca co się w niej dzieje. Dobrze jest też trzymać się podobnej konwencji w obrębie klasy/pakietu.&lt;/p&gt;

&lt;h2 id=&quot;argumenty-metod&quot;&gt;Argumenty metod&lt;/h2&gt;

&lt;p&gt;Powinniśmy unikać jak ognia przekazywania zbyt wielu argumentów do metody. Rozsądnym maximum są 4 parametry. Jeśli nie będziemy się tego trzymać, to nasze API stanie się toporne w użyciu, mało czytelne i nie obędzie się bez dokumentacji. Jest to szczególne ważne, jeśli metoda przyjmuje kilka argumentów tego samego typu.&lt;/p&gt;

&lt;p&gt;Aby poradzić sobie z problemem dużej ilości parametrów można np.:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;podzielić metodę na kilka mniejszych, które potrzebują tylko niektórych z nich, ale też trzeba mieć na uwadze to, aby nie naprodukować ich zbyt wiele&lt;/li&gt;
  &lt;li&gt;utworzyć dodatkową pomocniczą klasę, która zgrupuje powiązane ze sobą argumenty (zazwyczaj używa się do tego &lt;a href=&quot;/effective-java/klasy-wewnetrzne&quot;&gt;&lt;em&gt;static member class&lt;/em&gt;&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;skorzystać ze wzorca &lt;a href=&quot;/effective-java/wzorzec-projektowy-builder&quot;&gt;&lt;em&gt;builder&lt;/em&gt;&lt;/a&gt;, szczególnie jeśli niektóre parametry są opcjonalne.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;typy-argumentów&quot;&gt;Typy argumentów&lt;/h2&gt;

&lt;p&gt;Jeśli istnieje interfejs jakiegoś typu, to powinniśmy preferować jego użycie jako deklaracji typu argumentu do metody, zamiast klasy konkretnej. Dzięki temu metoda będzie bardziej elastyczna i będzie mogła przyjąć różne implementacje.&lt;/p&gt;

&lt;h2 id=&quot;enumy-zamiast-parametrów-typy-boolean&quot;&gt;Enumy zamiast parametrów typy boolean&lt;/h2&gt;

&lt;p&gt;Lepiej jest użyć dwuelementowego Enuma, niż booleana, chyba że znaczenie booleana jest jasne dzięki nazwie metody. Enumy są bardziej czytelne i łatwiej się nimi posługiwać. Ułatwiają też dodanie kolejnych opcji w późniejszym czasie.&lt;/p&gt;

&lt;p&gt;Dla przykładu, mając klasę &lt;code class=&quot;highlighter-rouge&quot;&gt;Thermometer&lt;/code&gt;, która ma operować na stopniach celsjusza lub farenhaita, zamiast konstruktora, który przyjmuje wartość &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, jeśli chcemy używać farenhaita:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thermometer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;lepiej by było stworzyć takiego enuma:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TemperatureScale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FAHRENHEIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CELSIUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;i jego podawać do konstruktora:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thermometer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TemperatureScale&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CELSIUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie dość, że jest to dużo bardziej czytelne, to nie ma później problemu, aby dodać np. kolejną jednostkę - &lt;code class=&quot;highlighter-rouge&quot;&gt;KELVIN&lt;/code&gt;. Ponadto możemy zrobić większy użytek z enumów dodając różne metody np. jedna z nich mogła by wspierać przekonwertowywanie jednostek.&lt;/p&gt;

&lt;h1 id=&quot;przeciążanie-metod---lepiej-tego-unikać&quot;&gt;Przeciążanie metod - lepiej tego unikać&lt;/h1&gt;

&lt;p&gt;Przeciążanie metod może być czasem dezorientujące. Przykład nieudolnego zastosowania - klasa która próbuje klasyfikować czy kolekcja jest setem, listą czy jakąś inną kolekcją za pomocą przeciążania metod:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Broken! - What does this program print?&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CollectionClassifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Set&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;List&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown Collection&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Intencją jest tutaj, aby program na podstawie typu w &lt;em&gt;runtime&lt;/em&gt; wybrał odpowiednie przeciążenie i zwrócił konkretny typ kolekcji. Mogłoby się wydawać, że program wyprintuje kolejno “Set”, “List” i “Unknown Collection” jednak tak się nie dzieje. Zamiast tego dostajemy 3 razy “Unknown Collection”.&lt;/p&gt;

&lt;p&gt;Jak to się dzieje? Wybór która przeciążana metoda powinna zostać wywołana dzieje się podczas kompilacji. Dla wszystkich 3 iteracji pętli typ elementu kolekcji jest taki sam - &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&amp;lt;?&amp;gt;&lt;/code&gt;. Podczas &lt;em&gt;runtime&lt;/em&gt; za każdym razem jest to inny typ, ale nie wpływa to na wybór przeciążenia - liczy się tu typ &lt;em&gt;compile-time&lt;/em&gt;, dlatego 3 razy wywoływane jest przeciążenie z &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&amp;lt;?&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Działa to dokładnie odwrotnie w przypadku nadpisywania metod. Wybór odpowiedniej nadpisanej metody dzieje się w &lt;em&gt;runtime&lt;/em&gt; i bazuje na typie, który widoczny jest w &lt;em&gt;runtime&lt;/em&gt;, a nie w &lt;em&gt;compile-time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wine&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SparklingWine&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sparkling wine&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Champagne&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SparklingWine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;champagne&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Overriding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wineList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SparklingWine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Champagne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wineList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu jako wynik dostaniemy zgodnie z założeniem kolejno: “wine”, “sparkling wine” i “champagne” mimo to, że typ &lt;em&gt;compile-time&lt;/em&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Wine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Takie zachowanie przeciążanych metod może wprowadzać niejasności w API co do kwestii, która metoda zostanie wywołana, jeśli mamy kilka przeciążeń, które przyjmują taką samą ilość parametrów, a ich typy są “wymienialne” ze sobą. Jeśli mamy taki przypadek najlepiej jest użyć po prostu innej nazwy metody. (Dla konstruktorów nie mamy opcji podania innej nazwy, ale można zastosować tutaj &lt;em&gt;&lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;static factory method&lt;/a&gt;&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Weźmy na przykład klasę &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectOutputStream&lt;/code&gt;. Posiada wariant metody &lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt; dla każdego typu prymitywnego. Zamiast przeciążać te metody, używa dla każdego z nich innej nazwy: np. &lt;code class=&quot;highlighter-rouge&quot;&gt;writeBoolean(boolean)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;writeInt(int)&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLong(long)&lt;/code&gt;. Podobnie jest w przypadku metody &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Często możemy się też spotkać z problemem przeciążania, gdy używamy referencji do metod. Weźmy przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Zarówno konstruktor &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt; jak i metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;sumbmit&lt;/code&gt; przyjmują &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, jednak wywołanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt; nie skompiluje się poprawnie. Wszystko przez to, że metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt; ma dodatkowe przeciążenie, które przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&amp;lt;T&amp;gt;&lt;/code&gt;. Mogłoby się wydawać, że nie powinno to zrobić żadnej różnicy, bo metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;println&lt;/code&gt; zawsze zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt;, więc ta referencja do metody nie mogłaby być &lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;. Ma to sens, jednak nie tak działa algorytm wyboru przeciążenia. Równie zaskakujące jest to, że nie byłoby problemu, gdyby metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;println&lt;/code&gt; nie miała własnych przeciążeń. To kombinacja przeciążeń referencji do metody i tej wywoływanej psuje ten algorytm.&lt;/p&gt;

&lt;p&gt;Dlatego nie powinno się tworzyć przeciążeń metod, które mogą przyjąć różne interfejsy funkcjonalne na tej samej pozycji. W powyższym przypadku trzeba by castować tę referencję na &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, aby kod się skompilował.&lt;/p&gt;

&lt;p&gt;Jedyne przeciążanie metod, które nie szkodzi jest wtedy, gdy wszystkie te metody robią dokładnie to samo. Można się tym spotkać w przypadku rozszerzania istniejących klas. Miało to miejsce np. w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, gdy został dodany interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;CharSequence&lt;/code&gt;. Standardowym sposobem, aby to osiągnąć, jest wywołanie w tym bardziej konkretnym przeciążeniu tego bardziej ogólnego. Tak też zrobiono w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Ensuring that 2 methods have identical behavior by forwarding&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contentEquals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contentEquals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Podsumowując, przeciążanie metod z taką samą ilością argumentów wprowadza niepotrzebny chaos, którego lepiej unikać.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 51, 52 z rozdziału 8: Methods Item 49: Check parameters for validity Item 50: Make defensive copies when needed Item 51: Design method signatures carefully Item 52: Use overloading judiciously Item 53: Use varargs judiciously Item 54: Return empty collections or arrays, not nulls Item 55: Return optionals judiciously Item 56: Write doc comments for all exposed API elements Projektowanie metod W tym temacie zebrane jest kilka wskazówek na temat projektowania API, aby było łatwiejsze w użyciu i bardziej odporne na błędy. Nazwy metod Nazwy metod oczywiście zawsze powinny przestrzegać konwencji nazewniczych, ale równie ważne jest dobranie dobrej nazwy metody. Nazwa powinna być zwięzła, łatwa w zrozumieniu i dobrze opisująca co się w niej dzieje. Dobrze jest też trzymać się podobnej konwencji w obrębie klasy/pakietu. Argumenty metod Powinniśmy unikać jak ognia przekazywania zbyt wielu argumentów do metody. Rozsądnym maximum są 4 parametry. Jeśli nie będziemy się tego trzymać, to nasze API stanie się toporne w użyciu, mało czytelne i nie obędzie się bez dokumentacji. Jest to szczególne ważne, jeśli metoda przyjmuje kilka argumentów tego samego typu. Aby poradzić sobie z problemem dużej ilości parametrów można np.: podzielić metodę na kilka mniejszych, które potrzebują tylko niektórych z nich, ale też trzeba mieć na uwadze to, aby nie naprodukować ich zbyt wiele utworzyć dodatkową pomocniczą klasę, która zgrupuje powiązane ze sobą argumenty (zazwyczaj używa się do tego static member class) skorzystać ze wzorca builder, szczególnie jeśli niektóre parametry są opcjonalne. Typy argumentów Jeśli istnieje interfejs jakiegoś typu, to powinniśmy preferować jego użycie jako deklaracji typu argumentu do metody, zamiast klasy konkretnej. Dzięki temu metoda będzie bardziej elastyczna i będzie mogła przyjąć różne implementacje. Enumy zamiast parametrów typy boolean Lepiej jest użyć dwuelementowego Enuma, niż booleana, chyba że znaczenie booleana jest jasne dzięki nazwie metody. Enumy są bardziej czytelne i łatwiej się nimi posługiwać. Ułatwiają też dodanie kolejnych opcji w późniejszym czasie. Dla przykładu, mając klasę Thermometer, która ma operować na stopniach celsjusza lub farenhaita, zamiast konstruktora, który przyjmuje wartość true, jeśli chcemy używać farenhaita: new Thermometer(true) lepiej by było stworzyć takiego enuma: public enum TemperatureScale { FAHRENHEIT, CELSIUS } i jego podawać do konstruktora: new Thermometer(TemperatureScale.CELSIUS) Nie dość, że jest to dużo bardziej czytelne, to nie ma później problemu, aby dodać np. kolejną jednostkę - KELVIN. Ponadto możemy zrobić większy użytek z enumów dodając różne metody np. jedna z nich mogła by wspierać przekonwertowywanie jednostek. Przeciążanie metod - lepiej tego unikać Przeciążanie metod może być czasem dezorientujące. Przykład nieudolnego zastosowania - klasa która próbuje klasyfikować czy kolekcja jest setem, listą czy jakąś inną kolekcją za pomocą przeciążania metod: // Broken! - What does this program print? public class CollectionClassifier { public static String classify(Set&amp;lt;?&amp;gt; s) { return &quot;Set&quot;; } public static String classify(List&amp;lt;?&amp;gt; lst) { return &quot;List&quot;; } public static String classify(Collection&amp;lt;?&amp;gt; c) { return &quot;Unknown Collection&quot;; } public static void main(String[] args) { Collection&amp;lt;?&amp;gt;[] collections = { new HashSet&amp;lt;String&amp;gt;(), new ArrayList&amp;lt;BigInteger&amp;gt;(), new HashMap&amp;lt;String, String&amp;gt;().values() }; for (Collection&amp;lt;?&amp;gt; c : collections) System.out.println(classify(c)); } } Intencją jest tutaj, aby program na podstawie typu w runtime wybrał odpowiednie przeciążenie i zwrócił konkretny typ kolekcji. Mogłoby się wydawać, że program wyprintuje kolejno “Set”, “List” i “Unknown Collection” jednak tak się nie dzieje. Zamiast tego dostajemy 3 razy “Unknown Collection”. Jak to się dzieje? Wybór która przeciążana metoda powinna zostać wywołana dzieje się podczas kompilacji. Dla wszystkich 3 iteracji pętli typ elementu kolekcji jest taki sam - Collection&amp;lt;?&amp;gt;. Podczas runtime za każdym razem jest to inny typ, ale nie wpływa to na wybór przeciążenia - liczy się tu typ compile-time, dlatego 3 razy wywoływane jest przeciążenie z Collection&amp;lt;?&amp;gt;. Działa to dokładnie odwrotnie w przypadku nadpisywania metod. Wybór odpowiedniej nadpisanej metody dzieje się w runtime i bazuje na typie, który widoczny jest w runtime, a nie w compile-time. Przykład: class Wine { String name() { return &quot;wine&quot;; } } class SparklingWine extends Wine { @Override String name() { return &quot;sparkling wine&quot;; } } class Champagne extends SparklingWine { @Override String name() { return &quot;champagne&quot;; } } public class Overriding { public static void main(String[] args) { List&amp;lt;Wine&amp;gt; wineList = List.of( new Wine(), new SparklingWine(), new Champagne()); for (Wine wine : wineList) System.out.println(wine.name()); } } Tu jako wynik dostaniemy zgodnie z założeniem kolejno: “wine”, “sparkling wine” i “champagne” mimo to, że typ compile-time to Wine. Takie zachowanie przeciążanych metod może wprowadzać niejasności w API co do kwestii, która metoda zostanie wywołana, jeśli mamy kilka przeciążeń, które przyjmują taką samą ilość parametrów, a ich typy są “wymienialne” ze sobą. Jeśli mamy taki przypadek najlepiej jest użyć po prostu innej nazwy metody. (Dla konstruktorów nie mamy opcji podania innej nazwy, ale można zastosować tutaj static factory method) Weźmy na przykład klasę ObjectOutputStream. Posiada wariant metody write dla każdego typu prymitywnego. Zamiast przeciążać te metody, używa dla każdego z nich innej nazwy: np. writeBoolean(boolean), writeInt(int) czy writeLong(long). Podobnie jest w przypadku metody read. Często możemy się też spotkać z problemem przeciążania, gdy używamy referencji do metod. Weźmy przykład: new Thread(System.out::println).start(); ExecutorService exec = Executors.newCachedThreadPool(); exec.submit(System.out::println); Zarówno konstruktor Thread jak i metoda sumbmit przyjmują Runnable, jednak wywołanie metody submit nie skompiluje się poprawnie. Wszystko przez to, że metoda submit ma dodatkowe przeciążenie, które przyjmuje Callable&amp;lt;T&amp;gt;. Mogłoby się wydawać, że nie powinno to zrobić żadnej różnicy, bo metoda println zawsze zwraca void, więc ta referencja do metody nie mogłaby być Callable. Ma to sens, jednak nie tak działa algorytm wyboru przeciążenia. Równie zaskakujące jest to, że nie byłoby problemu, gdyby metoda println nie miała własnych przeciążeń. To kombinacja przeciążeń referencji do metody i tej wywoływanej psuje ten algorytm. Dlatego nie powinno się tworzyć przeciążeń metod, które mogą przyjąć różne interfejsy funkcjonalne na tej samej pozycji. W powyższym przypadku trzeba by castować tę referencję na Runnable, aby kod się skompilował. Jedyne przeciążanie metod, które nie szkodzi jest wtedy, gdy wszystkie te metody robią dokładnie to samo. Można się tym spotkać w przypadku rozszerzania istniejących klas. Miało to miejsce np. w klasie String, gdy został dodany interfejs CharSequence. Standardowym sposobem, aby to osiągnąć, jest wywołanie w tym bardziej konkretnym przeciążeniu tego bardziej ogólnego. Tak też zrobiono w klasie String: // Ensuring that 2 methods have identical behavior by forwarding public boolean contentEquals(StringBuffer sb) { return contentEquals((CharSequence) sb); } Podsumowując, przeciążanie metod z taką samą ilością argumentów wprowadza niepotrzebny chaos, którego lepiej unikać.</summary></entry><entry><title type="html">Sprawdzanie parametrów i defensive copy</title><link href="https://devcave.pl/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy" rel="alternate" type="text/html" title="Sprawdzanie parametrów i defensive copy" /><published>2019-02-02T09:00:00+01:00</published><updated>2019-02-02T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy</id><content type="html" xml:base="https://devcave.pl/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 49, 50&lt;/i&gt; z rozdziału 8:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Methods&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 49: Check parameters for validity
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 50: Make defensive copies when needed
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 51: Design method signatures carefully
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 52: Use overloading judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 53: Use varargs judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 54: Return empty collections or arrays, not nulls
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 55: Return optionals judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;Item 56: Write doc comments for all exposed API elements
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;W tym rozdziale zawarte jest kilka dobrych praktyk na temat projektowania metod: min. jak traktować parametry i wartości zwracane, jak projektować sygnatury metod i jak je dokumentować. W tym wpisie nawiązuje do dwóch pierwszych tematów:&lt;/p&gt;

&lt;h1 id=&quot;sprawdzanie-parametrów-metody&quot;&gt;Sprawdzanie parametrów metody&lt;/h1&gt;

&lt;p&gt;Niektóre metody mogą mieć restrykcje co do parametrów przyjmowanych przez metody, np. indexy nie mogą być ujemne czy referencje do obiektów nie powinny być nullem. Tutaj w myśl zasady &lt;em&gt;fail quickly&lt;/em&gt; powinniśmy wymusić prawidłowość parametrów już na początku metody oraz udokumentować wszystkie restrykcje.&lt;/p&gt;

&lt;p&gt;Takie podejście ułatwia znalezienie źródła problemu - jeśli podana zostanie nieprawidłowa wartość, to natychmiast dostaniemy jasny komunikat tuż u źródła problemu. Jeśli tego nie zrobimy, to może się stać kilka rzeczy:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Metoda może się wysypać z dezorientującym wyjątkiem w samym środku wykonywania&lt;/li&gt;
  &lt;li&gt;Gorzej: Metoda wykonałaby się bez błędu, ale po cichu zwróciłaby nieprawidłowy wynik&lt;/li&gt;
  &lt;li&gt;Najgorzej: Metoda wykonałaby się bez błędu, ale zostawiłaby jakiś obiekt w nieprawidłowym stanie, powodując błąd w przyszłości w mało powiązanym miejscu daleko od źródła problemu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Przydatne wyjątki do walidacji parametrów to: &lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IndexOutOfBoundsException&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Przykładowa metoda ze sprawdzaniem parametru oraz dokumentacją:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a BigInteger whose value is (this mod m). This method
 * differs from the remainder method in that it always returns a
 * non-negative BigInteger.
 *
 * @param m the modulus, which must be positive
 * @return this mod m
 * @throws ArithmeticException if m is less than or equal to 0
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;signum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ArithmeticException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Modulus &amp;lt;= 0: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do the computation&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W Javie 8 dodano metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;Objects.requireNonNull&lt;/code&gt;, która ułatwia null-checkowanie, więc nie ma już sensu robić tego ręcznie. Pozwala też na podanie własnej wiadomości dla wyjątku.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Inline use of Java's null-checking facility&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;strategy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Można też zignorować zwracaną wartość i po prostu potraktować to jako swobodny null-check.&lt;/p&gt;

&lt;p&gt;Szczególnie ważne jest stosowanie tej praktyki w przypadku metod, które nie używają od razu tych parametrów, a przechowują je na później. Szczególnym przypadkiem tutaj są konstruktory, gdzie powinniśmy to robić niemal zawsze, aby uniknąć klas w nieprawidłowym stanie.&lt;/p&gt;

&lt;p&gt;Z drugiej strony nie ma sensu stosować tej praktyki w miejscach, gdzie takie sprawdzenie byłoby kosztowne lub jest wykonywane pośrednio - podczas wykonywania metody i rzuciłoby błędem od razu.&lt;/p&gt;

&lt;p&gt;Faszerowanie metod takimi restrykcjami na parametry to też nie jest dobra rzecz. Metody powinno się projektować tak, by w miarę możliwości były jak najbardziej ogólne i miały jak najmniej ograniczeń.&lt;/p&gt;

&lt;h1 id=&quot;defensive-copy---co-to-i-po-co&quot;&gt;Defensive copy - co to i po co?&lt;/h1&gt;

&lt;p&gt;Java jest w miarę bezpiecznym językiem, jednak nie chroni nas przed wszystkim. Zależnie od sytuacji warto programować defensywnie tzn. z założeniem, że klient naszej klasy będzie chciał dać z siebie wszystko, aby popsuć naszą klasę.&lt;/p&gt;

&lt;p&gt;Łatwo jest udostępnić sposób na modyfikowanie stanu klasy nieumyślnie. Dla przykładu spójrzmy na tę klasę, która miała być niemutowalna:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Broken &quot;immutable&quot; time period class&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * @param  start the beginning of the period
     * @param  end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; after &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Remainder omitted&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Na pierwszy rzut oka może się wydawać, że rzeczywiście jest niemutowalna oraz dba o to, by koniec okresu nie poprzedzał początku. Jednak można to łatwo złamać, wykorzystując fakt, że klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt; jest mutowalna:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Attack the internals of a Period instance&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Modifies internals of p!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Używając Javy 8+, oczywistym rozwiązaniem tego problemu jest używanie klas &lt;code class=&quot;highlighter-rouge&quot;&gt;Instant&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LocalDateTime&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;ZonedDateTime&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;, ponieważ te klasy są niemutowalne. &lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt; jest już przestarzała i nie powinna być używana w nowym kodzie.&lt;/p&gt;

&lt;p&gt;Jednak nie rozwiązujemy tym ogólnego problemu - czasem przecież będziemy potrzebowali użyć mutowalnych klas. I tu rozwiązaniem są właśnie tytułowe “defensive copies”.&lt;/p&gt;

&lt;p&gt;Aby ochronić wnętrzności klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Period&lt;/code&gt; przed taką modyfikacją musimy zrobić &lt;code class=&quot;highlighter-rouge&quot;&gt;defensive copy&lt;/code&gt; każdego mutowalnego parametru podanego do konstruktora:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Repaired constructor - makes defensive copies of parameters&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; after &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jak widać “defensive copy” to po prostu utworzenie nowego identycznego obiektu wewnątrz klasy.&lt;/p&gt;

&lt;p&gt;Dzięki temu poprzedni atak nie zadziała. Ważne jest też to, aby walidacja parametrów była wykonana na kopiach - chroni to klasę przed modyfikowaniem parametrów z innego wątku między czasem, gdy są walidowane, a potem kopiowane. W bezpieczeństwie znane jest to jako atak &lt;em&gt;time-of-check/time-of-use (TOCTOU)&lt;/em&gt;.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Warto zauważyć, że nie użyta jest tu metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;. To dlatego, że klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt; nie jest &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; i nie ma gwarancji, że metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; zwróci obiekt klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Date&lt;/code&gt;. Może również zwrócić instancję niezaufanej podklasy, która jest zaprojektowana by szkodzić. Dlatego nie powinno się używać metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;, aby robić &lt;em&gt;defensive copy&lt;/em&gt; na obiektach, które mogą być rozszerzane.&lt;/p&gt;

&lt;p&gt;To jednak nie wszystko - nasza klasa nadal jest wrażliwa. Nadal można ją modyfikować z zewnątrz dzięki getterom, które udostępniają bezpośrednio wnętrzności klasy:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Second attack on the internals of a Period instance&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Modifies internals of p!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Aby obronić się przed tym atakiem, również w przypadku getterów trzeba zwracać &lt;code class=&quot;highlighter-rouge&quot;&gt;defensive copy&lt;/code&gt; danego pola:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Repaired accessors - make defensive copies of internal fields&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Teraz dopiero nasza klasa jest w pełni niemutowalna, a jej stan zenkapsulowny. Nie ważne jak podstępny lub mało kompetentny jest programista - nie ma możliwości popsucia klasy (pomijając natywne metody i refleksję).&lt;/p&gt;

&lt;p&gt;Taka praktyka nie jest zresztą tylko po to, by projektować niemutowalne klasy. Pisząc metodę lub konstruktor, który przechowuje referencję do mutowalnego obiektu podanego przez klienta lub zwraca mutowalne pole, trzeba się zastanowić się, czy nasza klasa może tolerować zmiany stanu, czy poradzi sobie z tym? Czy może doprowadzić do trudnego do znalezienia błędu za jakiś czas?&lt;/p&gt;

&lt;p&gt;Dobra praktyka jest jednak następująca - staraj się używać niemutowalnych komponentów dla twojego obiektu, a nie będziesz musiał dbać o &lt;em&gt;defensive copy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Czasem &lt;em&gt;defensive copy&lt;/em&gt; może być kosztowne wydajnościowo i nie jest to zawsze uzasadnione. Jeśli klasa ufa klientowi (bo np. klient i klasa są w tym samym pakiecie) lub klient może zaszkodzić tylko sam sobie, to nie ma sensu tego stosować. Wtedy warto tylko to udokumentować.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 49, 50 z rozdziału 8: Methods Item 49: Check parameters for validity Item 50: Make defensive copies when needed Item 51: Design method signatures carefully Item 52: Use overloading judiciously Item 53: Use varargs judiciously Item 54: Return empty collections or arrays, not nulls Item 55: Return optionals judiciously Item 56: Write doc comments for all exposed API elements W tym rozdziale zawarte jest kilka dobrych praktyk na temat projektowania metod: min. jak traktować parametry i wartości zwracane, jak projektować sygnatury metod i jak je dokumentować. W tym wpisie nawiązuje do dwóch pierwszych tematów: Sprawdzanie parametrów metody Niektóre metody mogą mieć restrykcje co do parametrów przyjmowanych przez metody, np. indexy nie mogą być ujemne czy referencje do obiektów nie powinny być nullem. Tutaj w myśl zasady fail quickly powinniśmy wymusić prawidłowość parametrów już na początku metody oraz udokumentować wszystkie restrykcje. Takie podejście ułatwia znalezienie źródła problemu - jeśli podana zostanie nieprawidłowa wartość, to natychmiast dostaniemy jasny komunikat tuż u źródła problemu. Jeśli tego nie zrobimy, to może się stać kilka rzeczy: Metoda może się wysypać z dezorientującym wyjątkiem w samym środku wykonywania Gorzej: Metoda wykonałaby się bez błędu, ale po cichu zwróciłaby nieprawidłowy wynik Najgorzej: Metoda wykonałaby się bez błędu, ale zostawiłaby jakiś obiekt w nieprawidłowym stanie, powodując błąd w przyszłości w mało powiązanym miejscu daleko od źródła problemu. Przydatne wyjątki do walidacji parametrów to: IllegalArgumentException, IndexOutOfBoundsException czy NullPointerException. Przykładowa metoda ze sprawdzaniem parametru oraz dokumentacją: /** * Returns a BigInteger whose value is (this mod m). This method * differs from the remainder method in that it always returns a * non-negative BigInteger. * * @param m the modulus, which must be positive * @return this mod m * @throws ArithmeticException if m is less than or equal to 0 */ public BigInteger mod(BigInteger m) { if (m.signum() &amp;lt;= 0) throw new ArithmeticException(&quot;Modulus &amp;lt;= 0: &quot; + m); ... // Do the computation } W Javie 8 dodano metodę Objects.requireNonNull, która ułatwia null-checkowanie, więc nie ma już sensu robić tego ręcznie. Pozwala też na podanie własnej wiadomości dla wyjątku. // Inline use of Java's null-checking facility this.strategy = Objects.requireNonNull(strategy, &quot;strategy&quot;); Można też zignorować zwracaną wartość i po prostu potraktować to jako swobodny null-check. Szczególnie ważne jest stosowanie tej praktyki w przypadku metod, które nie używają od razu tych parametrów, a przechowują je na później. Szczególnym przypadkiem tutaj są konstruktory, gdzie powinniśmy to robić niemal zawsze, aby uniknąć klas w nieprawidłowym stanie. Z drugiej strony nie ma sensu stosować tej praktyki w miejscach, gdzie takie sprawdzenie byłoby kosztowne lub jest wykonywane pośrednio - podczas wykonywania metody i rzuciłoby błędem od razu. Faszerowanie metod takimi restrykcjami na parametry to też nie jest dobra rzecz. Metody powinno się projektować tak, by w miarę możliwości były jak najbardziej ogólne i miały jak najmniej ograniczeń. Defensive copy - co to i po co? Java jest w miarę bezpiecznym językiem, jednak nie chroni nas przed wszystkim. Zależnie od sytuacji warto programować defensywnie tzn. z założeniem, że klient naszej klasy będzie chciał dać z siebie wszystko, aby popsuć naszą klasę. Łatwo jest udostępnić sposób na modyfikowanie stanu klasy nieumyślnie. Dla przykładu spójrzmy na tę klasę, która miała być niemutowalna: // Broken &quot;immutable&quot; time period class public final class Period { private final Date start; private final Date end; /** * @param start the beginning of the period * @param end the end of the period; must not precede start * @throws IllegalArgumentException if start is after end * @throws NullPointerException if start or end is null */ public Period(Date start, Date end) { if (start.compareTo(end) &amp;gt; 0) throw new IllegalArgumentException( start + &quot; after &quot; + end); this.start = start; this.end = end; } public Date start() { return start; } public Date end() { return end; } ... // Remainder omitted } Na pierwszy rzut oka może się wydawać, że rzeczywiście jest niemutowalna oraz dba o to, by koniec okresu nie poprzedzał początku. Jednak można to łatwo złamać, wykorzystując fakt, że klasa Date jest mutowalna: // Attack the internals of a Period instance Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); end.setYear(78); // Modifies internals of p! Używając Javy 8+, oczywistym rozwiązaniem tego problemu jest używanie klas Instant, LocalDateTime lub ZonedDateTime zamiast Date, ponieważ te klasy są niemutowalne. Date jest już przestarzała i nie powinna być używana w nowym kodzie. Jednak nie rozwiązujemy tym ogólnego problemu - czasem przecież będziemy potrzebowali użyć mutowalnych klas. I tu rozwiązaniem są właśnie tytułowe “defensive copies”. Aby ochronić wnętrzności klasy Period przed taką modyfikacją musimy zrobić defensive copy każdego mutowalnego parametru podanego do konstruktora: // Repaired constructor - makes defensive copies of parameters public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) &amp;gt; 0) throw new IllegalArgumentException( this.start + &quot; after &quot; + this.end); } Jak widać “defensive copy” to po prostu utworzenie nowego identycznego obiektu wewnątrz klasy. Dzięki temu poprzedni atak nie zadziała. Ważne jest też to, aby walidacja parametrów była wykonana na kopiach - chroni to klasę przed modyfikowaniem parametrów z innego wątku między czasem, gdy są walidowane, a potem kopiowane. W bezpieczeństwie znane jest to jako atak time-of-check/time-of-use (TOCTOU). Warto zauważyć, że nie użyta jest tu metoda clone klasy Date. To dlatego, że klasa Date nie jest final i nie ma gwarancji, że metoda clone zwróci obiekt klasy java.util.Date. Może również zwrócić instancję niezaufanej podklasy, która jest zaprojektowana by szkodzić. Dlatego nie powinno się używać metody clone, aby robić defensive copy na obiektach, które mogą być rozszerzane. To jednak nie wszystko - nasza klasa nadal jest wrażliwa. Nadal można ją modyfikować z zewnątrz dzięki getterom, które udostępniają bezpośrednio wnętrzności klasy: // Second attack on the internals of a Period instance Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); p.end().setYear(78); // Modifies internals of p! Aby obronić się przed tym atakiem, również w przypadku getterów trzeba zwracać defensive copy danego pola: // Repaired accessors - make defensive copies of internal fields public Date start() { return new Date(start.getTime()); } public Date end() { return new Date(end.getTime()); } Teraz dopiero nasza klasa jest w pełni niemutowalna, a jej stan zenkapsulowny. Nie ważne jak podstępny lub mało kompetentny jest programista - nie ma możliwości popsucia klasy (pomijając natywne metody i refleksję). Taka praktyka nie jest zresztą tylko po to, by projektować niemutowalne klasy. Pisząc metodę lub konstruktor, który przechowuje referencję do mutowalnego obiektu podanego przez klienta lub zwraca mutowalne pole, trzeba się zastanowić się, czy nasza klasa może tolerować zmiany stanu, czy poradzi sobie z tym? Czy może doprowadzić do trudnego do znalezienia błędu za jakiś czas? Dobra praktyka jest jednak następująca - staraj się używać niemutowalnych komponentów dla twojego obiektu, a nie będziesz musiał dbać o defensive copy. Czasem defensive copy może być kosztowne wydajnościowo i nie jest to zawsze uzasadnione. Jeśli klasa ufa klientowi (bo np. klient i klasa są w tym samym pakiecie) lub klient może zaszkodzić tylko sam sobie, to nie ma sensu tego stosować. Wtedy warto tylko to udokumentować.</summary></entry><entry><title type="html">Zwracanie streamów? Współbieżne streamy.</title><link href="https://devcave.pl/effective-java/zwracanie-kolekcji-zamiast-streamow" rel="alternate" type="text/html" title="Zwracanie streamów? Współbieżne streamy." /><published>2019-01-26T09:00:00+01:00</published><updated>2019-01-26T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/zwracanie-kolekcji-zamiast-streamow</id><content type="html" xml:base="https://devcave.pl/effective-java/zwracanie-kolekcji-zamiast-streamow">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 47, 48&lt;/i&gt; z rozdziału 7:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Lambdas and Streams&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 42: Prefer lambdas to anonymous classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 43: Prefer method references to lambdas
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejsy-funkcyjne-w-javie&quot;&gt;Item 44: Favor the use of standard functional interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;Item 45: Use streams judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;Item 46: Prefer side-effect-free functions in streams
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 47: Prefer Collection to Stream as a return type
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 48: Use caution when making streams parallel
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;zwracanie-kolekcji-zamiast-stremów&quot;&gt;Zwracanie kolekcji zamiast stremów&lt;/h1&gt;

&lt;p&gt;Pisząc metodę zwracającą sekwencję obiektów, powinniśmy przede wszystkim zwrócić jakiś typ kolekcji, a nie tylko &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;. No, chyba że jesteśmy pewni, że obiekty te będą używane tylko w streamie. Pisząc jakieś publiczne API najlepiej jest udostępnić obie wersje.&lt;/p&gt;

&lt;p&gt;Zwracając na przykład tylko &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; sprawiamy, że klient nie będzie mógł w łatwy sposób przeitreować po elementach za pomocą pętli for-each. Niestety &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; nie rozszerza &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;, chociaż mógłby. Żeby użyć go w pętli, trzeba by zrobić takie paskudztwo:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Hideous workaround to iterate over a stream&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allProcesses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Już lepszym obejściem, gdy chcemy użyć elementów streamu w pętli, jest taki adapter:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Adapter from  Stream&amp;lt;E&amp;gt; to Iterable&amp;lt;E&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iterableOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;stream:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Który można użyć potem tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterableOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allProcesses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Process the process&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt; jest podtypem &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; i ma metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;stream&lt;/code&gt;, więc zwracając kolekcje mamy od razu dostęp do iteracji i streamów. Również zwykłe tablice udostępniają łatwy dostęp do tego dzięki &lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays.asList&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.of&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;równoległe-wykonywanie-operacji-na-streamach&quot;&gt;Równoległe wykonywanie operacji na streamach&lt;/h1&gt;

&lt;p&gt;Od Javy 5 mamy bibliotekę &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; która zawiera współbieżne kolekcje i &lt;em&gt;executor framework&lt;/em&gt;. W Javie 7 dodano pakiet &lt;em&gt;fork-join&lt;/em&gt;, czyli wydajny framwork do &lt;em&gt;parallel decomposition&lt;/em&gt;. W Javie 8 dodano streamy, które mogą działać współbieżnie po wywołaniu tylko jednej metody - &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt;. Dzięki tym mechanizmom pisanie wielowątkowych programów staje się coraz łatwiejsze, ale napisanie ich, aby działały poprawnie i szybko jest tak samo trudne, jak to było wcześniej.&lt;/p&gt;

&lt;p&gt;Rozważmy taki program:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Stream-based program to generate the first 20 Mersenne primes&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;primes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TWO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;intValueExact&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ONE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mersenne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mersenne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isProbablePrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;primes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TWO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BigInteger:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextProbablePrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Generuje on pierwsze 20 liczb pierwszych Mersenne’a, nie jest jednak ważne, co dokładnie to robi. Na moim laptopie zajmuje to około 14 sekund. Załóżmy teraz, że naiwnie chciałbym przyspieszyć ten proces, wywołując &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt;, przez co wszystkie operację wywołane zostaną współbieżnie. Czy teraz będzie szybciej? Czy trochę wolniej? Niestety - nie pokaże się nic, a zużycie procesora wskoczy na 100%.&lt;/p&gt;

&lt;p&gt;Co się stało? Ano biblioteka streamów nie ma pojęcia jak wykonać tę operację wielowątkowo. Nawet w dobrych warunkach, jeśli źródło streamu to &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.iterate&lt;/code&gt; lub jest obecna operacja &lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt;, to wywołanie &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt; nie przyniesie dobrego rezultatu.&lt;/p&gt;

&lt;p&gt;Morał jest więc prosty - nie wywołujmy metody &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt; na streamie bezmyślnie.&lt;/p&gt;

&lt;p&gt;Z reguły, najlepszy zysk na wydajności zyskujemy wtedy, gdy robimy streamy na instancjach klas takich jak: &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; oraz tablicach i &lt;code class=&quot;highlighter-rouge&quot;&gt;IntStream.range()&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;LongStream.range()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To, co mają wspólnego, to to, że mogą być dokładnie i dosyć tanim kosztem podzielone na mniejsze części, co ułatwia rozdzielenie pracy pośród wiele wątków. Używany jest do tego &lt;em&gt;spliterator&lt;/em&gt;, który jest zwracany przez wywołanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;spliterator()&lt;/code&gt; na &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Również specyfika końcowych operacji wpływa na efektywność współbieżnego przetwarzania. Jeśli więcej pracy jest wykonywane w operacji kończącej niż w tych modyfikujących, to wywołanie &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt; nie wiele zmieni.&lt;/p&gt;

&lt;p&gt;Najlepsze operacje końcowe, które najlepiej działają współbieżnie to “redukcje”, gdzie wszystkie elementy są łączone za pomocą jednej z metod redukujących w &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; lub gotowe metody takie jak &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;. Równie dobrze sprawdzają się operację takie jak &lt;code class=&quot;highlighter-rouge&quot;&gt;anyMatch&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;allMatch&lt;/code&gt;, i &lt;code class=&quot;highlighter-rouge&quot;&gt;noneMatch&lt;/code&gt;. Do tej grupy nie należą jednak &lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;, która jest nieco bardziej kosztowna.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Używając zwykłego &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; na streamie, który wykonywany jest współbieżnie, kolejność elementów nie zostanie zachowana. Aby dostać na koniec tę samą kolejność trzeba użyć &lt;code class=&quot;highlighter-rouge&quot;&gt;forEachOrdered&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nawet używając źródła streamu, które można łatwo podzielić na kawałki, mało kosztowne operacje kończące i niekolidujące obiekty funkcyjne, &lt;strong&gt;nie uzyskamy lepszej wydajności z wywoływania &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel&lt;/code&gt; jeśli w streamie nie będą wykonywane ciężkie operacje, które przewyższą koszt przetwarzania wielowątkowego.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Przykład streamu, gdzie równoległe wykonywanie ma sens i przynosi duży zysk wydajności:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Prime-counting stream pipeline - benefits from parallelization&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LongStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;rangeClosed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mapToObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;BigInteger:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isProbablePrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Na moim laptopie, policzenie tym prostym sposobem ilości liczb pierwszych mniejszych od 100 000 zajmuje 32 sekundy. Dodanie &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Prime-counting stream pipeline - parallel version&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LongStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;rangeClosed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parallel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mapToObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;BigInteger:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isProbablePrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;redukuje czas do 9 sekund.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 47, 48 z rozdziału 7: Lambdas and Streams Item 42: Prefer lambdas to anonymous classes Item 43: Prefer method references to lambdas Item 44: Favor the use of standard functional interfaces Item 45: Use streams judiciously Item 46: Prefer side-effect-free functions in streams Item 47: Prefer Collection to Stream as a return type Item 48: Use caution when making streams parallel Zwracanie kolekcji zamiast stremów Pisząc metodę zwracającą sekwencję obiektów, powinniśmy przede wszystkim zwrócić jakiś typ kolekcji, a nie tylko Stream. No, chyba że jesteśmy pewni, że obiekty te będą używane tylko w streamie. Pisząc jakieś publiczne API najlepiej jest udostępnić obie wersje. Zwracając na przykład tylko Stream sprawiamy, że klient nie będzie mógł w łatwy sposób przeitreować po elementach za pomocą pętli for-each. Niestety Stream nie rozszerza Iterable, chociaż mógłby. Żeby użyć go w pętli, trzeba by zrobić takie paskudztwo: // Hideous workaround to iterate over a stream for (ProcessHandle ph : (Iterable&amp;lt;ProcessHandle&amp;gt;) ProcessHandle.allProcesses()::iterator) Już lepszym obejściem, gdy chcemy użyć elementów streamu w pętli, jest taki adapter: // Adapter from Stream&amp;lt;E&amp;gt; to Iterable&amp;lt;E&amp;gt; public static &amp;lt;E&amp;gt; Iterable&amp;lt;E&amp;gt; iterableOf(Stream&amp;lt;E&amp;gt; stream) { return stream::iterator; } Który można użyć potem tak: for (ProcessHandle p : iterableOf(ProcessHandle.allProcesses())) { // Process the process } Interfejs Collection jest podtypem Iterable i ma metodę stream, więc zwracając kolekcje mamy od razu dostęp do iteracji i streamów. Również zwykłe tablice udostępniają łatwy dostęp do tego dzięki Arrays.asList i Stream.of. Równoległe wykonywanie operacji na streamach Od Javy 5 mamy bibliotekę java.util.concurrent która zawiera współbieżne kolekcje i executor framework. W Javie 7 dodano pakiet fork-join, czyli wydajny framwork do parallel decomposition. W Javie 8 dodano streamy, które mogą działać współbieżnie po wywołaniu tylko jednej metody - parallel(). Dzięki tym mechanizmom pisanie wielowątkowych programów staje się coraz łatwiejsze, ale napisanie ich, aby działały poprawnie i szybko jest tak samo trudne, jak to było wcześniej. Rozważmy taki program: // Stream-based program to generate the first 20 Mersenne primes public static void main(String[] args) { primes().map(p -&amp;gt; TWO.pow(p.intValueExact()).subtract(ONE)) .filter(mersenne -&amp;gt; mersenne.isProbablePrime(50)) .limit(20) .forEach(System.out::println); } static Stream&amp;lt;BigInteger&amp;gt; primes() { return Stream.iterate(TWO, BigInteger::nextProbablePrime); } Generuje on pierwsze 20 liczb pierwszych Mersenne’a, nie jest jednak ważne, co dokładnie to robi. Na moim laptopie zajmuje to około 14 sekund. Załóżmy teraz, że naiwnie chciałbym przyspieszyć ten proces, wywołując parallel(), przez co wszystkie operację wywołane zostaną współbieżnie. Czy teraz będzie szybciej? Czy trochę wolniej? Niestety - nie pokaże się nic, a zużycie procesora wskoczy na 100%. Co się stało? Ano biblioteka streamów nie ma pojęcia jak wykonać tę operację wielowątkowo. Nawet w dobrych warunkach, jeśli źródło streamu to Stream.iterate lub jest obecna operacja limit, to wywołanie parallel() nie przyniesie dobrego rezultatu. Morał jest więc prosty - nie wywołujmy metody parallel() na streamie bezmyślnie. Z reguły, najlepszy zysk na wydajności zyskujemy wtedy, gdy robimy streamy na instancjach klas takich jak: ArrayList, HashMap, HashSet, ConcurrentHashMap oraz tablicach i IntStream.range()/LongStream.range(). To, co mają wspólnego, to to, że mogą być dokładnie i dosyć tanim kosztem podzielone na mniejsze części, co ułatwia rozdzielenie pracy pośród wiele wątków. Używany jest do tego spliterator, który jest zwracany przez wywołanie metody spliterator() na Stream lub Iterable. Również specyfika końcowych operacji wpływa na efektywność współbieżnego przetwarzania. Jeśli więcej pracy jest wykonywane w operacji kończącej niż w tych modyfikujących, to wywołanie parallel() nie wiele zmieni. Najlepsze operacje końcowe, które najlepiej działają współbieżnie to “redukcje”, gdzie wszystkie elementy są łączone za pomocą jednej z metod redukujących w Stream lub gotowe metody takie jak min, max, count i sum. Równie dobrze sprawdzają się operację takie jak anyMatch, allMatch, i noneMatch. Do tej grupy nie należą jednak collect, która jest nieco bardziej kosztowna. Używając zwykłego forEach na streamie, który wykonywany jest współbieżnie, kolejność elementów nie zostanie zachowana. Aby dostać na koniec tę samą kolejność trzeba użyć forEachOrdered. Nawet używając źródła streamu, które można łatwo podzielić na kawałki, mało kosztowne operacje kończące i niekolidujące obiekty funkcyjne, nie uzyskamy lepszej wydajności z wywoływania parallel jeśli w streamie nie będą wykonywane ciężkie operacje, które przewyższą koszt przetwarzania wielowątkowego. Przykład streamu, gdzie równoległe wykonywanie ma sens i przynosi duży zysk wydajności: // Prime-counting stream pipeline - benefits from parallelization static long pi(long n) { return LongStream.rangeClosed(2, n) .mapToObj(BigInteger::valueOf) .filter(i -&amp;gt; i.isProbablePrime(50)) .count(); } Na moim laptopie, policzenie tym prostym sposobem ilości liczb pierwszych mniejszych od 100 000 zajmuje 32 sekundy. Dodanie parallel(): // Prime-counting stream pipeline - parallel version static long pi(long n) { return LongStream.rangeClosed(2, n) .parallel() .mapToObj(BigInteger::valueOf) .filter(i -&amp;gt; i.isProbablePrime(50)) .count(); } redukuje czas do 9 sekund.</summary></entry><entry><title type="html">Rozważne i prawidłowe używanie streamów</title><link href="https://devcave.pl/effective-java/rozwazne-uzywanie-streamow" rel="alternate" type="text/html" title="Rozważne i prawidłowe używanie streamów" /><published>2019-01-19T09:00:00+01:00</published><updated>2019-01-19T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/rozwazne-uzywanie-streamow</id><content type="html" xml:base="https://devcave.pl/effective-java/rozwazne-uzywanie-streamow">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 45, 46&lt;/i&gt; z rozdziału 7:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Lambdas and Streams&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 42: Prefer lambdas to anonymous classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 43: Prefer method references to lambdas
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejsy-funkcyjne-w-javie&quot;&gt;Item 44: Favor the use of standard functional interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 45: Use streams judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 46: Prefer side-effect-free functions in streams
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;Item 47: Prefer Collection to Stream as a return type
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;Item 48: Use caution when making streams parallel
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;co-to-są-streamy-i-kiedy-je-używać&quot;&gt;Co to są streamy i kiedy je używać&lt;/h1&gt;

&lt;p&gt;W Javie 8 dodane zostały streamy, aby ułatwić wykonywanie wielu operacji na zbiorze danych - sekwencyjnie lub równolegle. API dostarcza dwie abstrakcje: &lt;em&gt;stream&lt;/em&gt; - czyli skończona lub nieskończona sekwencja danych i &lt;em&gt;stream pipline&lt;/em&gt; czyli wieloetapowe przekształcenia i przeliczenia tych danych. Składa się to na zero lub więcej operacji pośrednich (które przekształcają w jakiś sposób &lt;em&gt;stream&lt;/em&gt;, np. mapowanie, sortowanie, filtrowanie itd.) i jedną końcową (np. wrzucenie elementów do kolekcji, zwrócenie konkretnego elementu czy wyświetlanie ich w konsoli).&lt;/p&gt;

&lt;p&gt;Streamy są wykonywane leniwie tzn. dopóki nie nie wywołamy końcowej operacji, to żadna operacja się nie wykona. To pozwala na pracę z nieskończonymi streamami.&lt;/p&gt;

&lt;p&gt;API streamów jest płynne, tzn. możemy dowolnie łączyć różne wywołania w jedno wyrażenie.&lt;/p&gt;

&lt;p&gt;Domyślnie streamy wykonywane są sekwencyjnie. Zamienienie ich na pracę współbieżną jest tak proste, jak wywołanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel()&lt;/code&gt; na streamie, &lt;strong&gt;jednak nie zawsze jest to odpowiednie&lt;/strong&gt; - ten temat poruszę w ostatnim temacie tego rozdziału.&lt;/p&gt;

&lt;p&gt;Stream API jest bardzo wszechstronne i możemy w nich wykonać niemal wszystko, nie znaczy to jednak, że powinniśmy od teraz robić wszystko w streamach. Dobre używanie streamów może skrócić kod i zwiększyć czytelność naszych programów, jednak nadużywanie ich może sprawić, że będzie odwrotnie. Dlatego najlepiej znaleźć złoty środek.&lt;/p&gt;

&lt;p&gt;Zobaczmy to na przykładzie - program, który czyta słowa z pliku i wyświetla wszystkie anagramy (słowa składające się z tych samych liter, jednak w innej kolejności), których długość jest większa niż ta podana przez użytkownika.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Prints all large anagram groups in a dictionary iteratively&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Anagrams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;computeIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Czyli tak - czytamy wszystkie słowa i wkładamy je do mapy. Klucz mapy to ułożone alfabetycznie litery danego słowa (np. dla “programowanie” będzie to “aaegimnooprrw”). Jako wartość, będą to kolejne słowa, które mają takie same litery. Potem wyświetlane są te, które spełniają wymóg długości podany do programu.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Wstawianie wartości do mapy robione jest metodą &lt;code class=&quot;highlighter-rouge&quot;&gt;computeIfAbsent&lt;/code&gt;, która została dodana w Javie 8. Ta metoda sprawdza, czy klucz jest już w mapie i zwraca jego wartość, jeśli istnieje - jeśli nie, to metoda przypisuje wartość obliczoną w podanym obiekcie funkcyjnym jako drugi argument i zwraca tę wartość. Ta metoda upraszcza implementację map, które przypisują kilka wartości do każdego klucza.&lt;/p&gt;

&lt;p&gt;Teraz zobaczymy to samo, tylko wszystko wrzucone do streamów jak leci:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Overuse of streams - don't do this!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Anagrams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Paths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;StringBuilder:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                        &lt;span class=&quot;nl&quot;&gt;StringBuilder:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jest to nieco krótsze, ale też mniej czytelne, zwłaszcza dla kogoś, kto nie jest zaprzyjaźniony ze streamami. &lt;strong&gt;Złoty środek, o którym mówiłem, to korzystanie z obu sposobów&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Tasteful use of streams enhances clarity and conciseness&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Anagrams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Paths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// alphabetize method is the same as in original version&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Łącząc podejście iteracyjne i funkcyjne (streamy) dostaniemy najlepsze rezultaty. Układanie alfabetycznie liter wyrazu jest wydzielone do osobnej &lt;strong&gt;nazwanej&lt;/strong&gt; funkcji, co jasno określa, co się dzieje pod spodem i wyodrębnia szczegóły implementacyjne poza główny kod.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Wobec tego, że typy nie są widoczne w lambdach, warto dobrze nazywać parametry lambd, aby zwiększyć czytelność streamów. Z tego samego powodu używanie metod pomocniczych (jak &lt;code class=&quot;highlighter-rouge&quot;&gt;alphabetize&lt;/code&gt;) w streamach jest dużo ważniejsze niż w kodzie iteracyjnym.&lt;/p&gt;

&lt;p&gt;Poza tym jest też kilka rzeczy, które możemy robić w zwykłych blokach kodu, a nie możemy robić w lambdach:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;W lambdzie można tylko czytać zmienne &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;effectively final&lt;/code&gt; i nie można modyfikować żadnej zmiennej lokalnej&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;W lambdzie nie można zwrócić wyniku do zewnętrznej funkcji, wywołać &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; w zewnętrznej pętli, lub rzucić jakiegokolwiek wyjątku, który zewnętrzna funkcja zadeklarowała.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;pure-functions&quot;&gt;Pure functions&lt;/h1&gt;

&lt;p&gt;Streamy to nie tylko API, to paradygmat oparty na programowaniu funkcyjnym. Aby uzyskać ekspresyjność, wydajność i w niektórych przypadkach zdolność do równoległego przetwarzania, które streamy oferują, trzeba zaadaptować nie tylko API, ale i paradygmat.&lt;/p&gt;

&lt;p&gt;Najważniejszą rzeczą, do której powinniśmy dążyć, jest to, aby nasze obiekty funkcyjne były jak najbardziej zbliżone do tzn. &lt;em&gt;pure function&lt;/em&gt;. &lt;em&gt;Pure function&lt;/em&gt; to taka, która polega tylko na tym, co dostaje w argumencie - nie polega na żadnym innym zmiennym stanie ani nie zmienia stanu żadnego innego obiektu. Jednym słowem jest funkcją bez żadnych efektów ubocznych (&lt;em&gt;pure function = side-effects free function&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Zobaczmy na ten kawałek kodu, który tworzy mapę częstotliwości słów pobranych z pliku:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Uses the streams API but not the paradigm--Don't do this!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Long:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co jest z tym kodem złego, jest czytelny, używa streamów, lambd i referencji do metod. Nawet działa zgodnie z założeniem. A no to, że to wcale nie jest kod streamowy. Jest to zwykły kod iteracyjny wrzucony do streamu. Nie czerpie żadnych korzyści z używania streamów, jest dłuższy niż powinien być i jest mniej czytelny.&lt;/p&gt;

&lt;p&gt;A to wszystko dlatego, że wykonuje wszystko w końcowej operacji &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;, używając lambdy, która zmienia stan zewnętrznego obiektu (mapy &lt;code class=&quot;highlighter-rouge&quot;&gt;freq&lt;/code&gt;). &lt;strong&gt;Operacja &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;, która robi coś więcej niż prezentowanie wyniku czy dodanie wyniku do istniejącej już kolekcji, to &lt;em&gt;bad smell&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Właściwe wykorzystanie streamów powinno wyglądać tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Proper use of streams to initialize a frequency table&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;String:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli ktoś pisze kod, podobny do wcześniejszego, to dlatego, że robi to w sposób, w który robił to dotychczas i z którym jest oswojony - niczym się to nie różni od pętli for-each.&lt;/p&gt;

&lt;p&gt;Lepsza wersja używa &lt;strong&gt;Collectors API&lt;/strong&gt; (metody &lt;code class=&quot;highlighter-rouge&quot;&gt;groupingBy&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;counting&lt;/code&gt;, które zostały zaimportowane statycznie dla lepszej czytelności). Jest to aż 39 metod, które są swego rodzaju implementacją strategi redukcji, tzn. łączenie elementów (w tym przypadku streamu) w pojedynczy obiekt.&lt;/p&gt;

&lt;p&gt;Oprócz tego najczęściej używa się collectory, które zbierają elementy streamu w kolekcję: &lt;code class=&quot;highlighter-rouge&quot;&gt;toList()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;toSet()&lt;/code&gt;, i &lt;code class=&quot;highlighter-rouge&quot;&gt;toCollection(collectionFactory)&lt;/code&gt;. Zwracają kolejno listę, set i inny podany przez nas typ kolekcji. Poza tym są jeszcze różne wariacje zbierania elementów do mapy.&lt;/p&gt;

&lt;p&gt;Dla przykładu wyciągnięcie 10 słów z największą częstotliwością z poprzedniej mapy:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Pipeline to get a top-ten list of words from a frequency table&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topTen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comparing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;freq:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reversed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt; jest jeszcze masa użytecznych metod. Polecam zajrzeć na ten wpis &lt;a href=&quot;https://www.baeldung.com/java-8-collectors&quot;&gt;baeldung.com/java-8-collectors&lt;/a&gt;.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 45, 46 z rozdziału 7: Lambdas and Streams Item 42: Prefer lambdas to anonymous classes Item 43: Prefer method references to lambdas Item 44: Favor the use of standard functional interfaces Item 45: Use streams judiciously Item 46: Prefer side-effect-free functions in streams Item 47: Prefer Collection to Stream as a return type Item 48: Use caution when making streams parallel Co to są streamy i kiedy je używać W Javie 8 dodane zostały streamy, aby ułatwić wykonywanie wielu operacji na zbiorze danych - sekwencyjnie lub równolegle. API dostarcza dwie abstrakcje: stream - czyli skończona lub nieskończona sekwencja danych i stream pipline czyli wieloetapowe przekształcenia i przeliczenia tych danych. Składa się to na zero lub więcej operacji pośrednich (które przekształcają w jakiś sposób stream, np. mapowanie, sortowanie, filtrowanie itd.) i jedną końcową (np. wrzucenie elementów do kolekcji, zwrócenie konkretnego elementu czy wyświetlanie ich w konsoli). Streamy są wykonywane leniwie tzn. dopóki nie nie wywołamy końcowej operacji, to żadna operacja się nie wykona. To pozwala na pracę z nieskończonymi streamami. API streamów jest płynne, tzn. możemy dowolnie łączyć różne wywołania w jedno wyrażenie. Domyślnie streamy wykonywane są sekwencyjnie. Zamienienie ich na pracę współbieżną jest tak proste, jak wywołanie metody parallel() na streamie, jednak nie zawsze jest to odpowiednie - ten temat poruszę w ostatnim temacie tego rozdziału. Stream API jest bardzo wszechstronne i możemy w nich wykonać niemal wszystko, nie znaczy to jednak, że powinniśmy od teraz robić wszystko w streamach. Dobre używanie streamów może skrócić kod i zwiększyć czytelność naszych programów, jednak nadużywanie ich może sprawić, że będzie odwrotnie. Dlatego najlepiej znaleźć złoty środek. Zobaczmy to na przykładzie - program, który czyta słowa z pliku i wyświetla wszystkie anagramy (słowa składające się z tych samych liter, jednak w innej kolejności), których długość jest większa niż ta podana przez użytkownika. // Prints all large anagram groups in a dictionary iteratively public class Anagrams { public static void main(String[] args) throws IOException { File dictionary = new File(args[0]); int minGroupSize = Integer.parseInt(args[1]); Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; groups = new HashMap&amp;lt;&amp;gt;(); try (Scanner s = new Scanner(dictionary)) { while (s.hasNext()) { String word = s.next(); groups.computeIfAbsent(alphabetize(word), (unused) -&amp;gt; new TreeSet&amp;lt;&amp;gt;()).add(word); } } for (Set&amp;lt;String&amp;gt; group : groups.values()) if (group.size() &amp;gt;= minGroupSize) System.out.println(group.size() + &quot;: &quot; + group); } private static String alphabetize(String s) { char[] a = s.toCharArray(); Arrays.sort(a); return new String(a); } } Czyli tak - czytamy wszystkie słowa i wkładamy je do mapy. Klucz mapy to ułożone alfabetycznie litery danego słowa (np. dla “programowanie” będzie to “aaegimnooprrw”). Jako wartość, będą to kolejne słowa, które mają takie same litery. Potem wyświetlane są te, które spełniają wymóg długości podany do programu. Wstawianie wartości do mapy robione jest metodą computeIfAbsent, która została dodana w Javie 8. Ta metoda sprawdza, czy klucz jest już w mapie i zwraca jego wartość, jeśli istnieje - jeśli nie, to metoda przypisuje wartość obliczoną w podanym obiekcie funkcyjnym jako drugi argument i zwraca tę wartość. Ta metoda upraszcza implementację map, które przypisują kilka wartości do każdego klucza. Teraz zobaczymy to samo, tylko wszystko wrzucone do streamów jak leci: // Overuse of streams - don't do this! public class Anagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream&amp;lt;String&amp;gt; words = Files.lines(dictionary)) { words.collect( groupingBy(word -&amp;gt; word.chars().sorted() .collect(StringBuilder::new, (sb, c) -&amp;gt; sb.append((char) c), StringBuilder::append).toString())) .values().stream() .filter(group -&amp;gt; group.size() &amp;gt;= minGroupSize) .map(group -&amp;gt; group.size() + &quot;: &quot; + group) .forEach(System.out::println); } } } Jest to nieco krótsze, ale też mniej czytelne, zwłaszcza dla kogoś, kto nie jest zaprzyjaźniony ze streamami. Złoty środek, o którym mówiłem, to korzystanie z obu sposobów: // Tasteful use of streams enhances clarity and conciseness public class Anagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream&amp;lt;String&amp;gt; words = Files.lines(dictionary)) { words.collect(groupingBy(word -&amp;gt; alphabetize(word))) .values().stream() .filter(group -&amp;gt; group.size() &amp;gt;= minGroupSize) .forEach(group -&amp;gt; System.out.println(group.size() + &quot;: &quot; + group)); } } // alphabetize method is the same as in original version } Łącząc podejście iteracyjne i funkcyjne (streamy) dostaniemy najlepsze rezultaty. Układanie alfabetycznie liter wyrazu jest wydzielone do osobnej nazwanej funkcji, co jasno określa, co się dzieje pod spodem i wyodrębnia szczegóły implementacyjne poza główny kod. Wobec tego, że typy nie są widoczne w lambdach, warto dobrze nazywać parametry lambd, aby zwiększyć czytelność streamów. Z tego samego powodu używanie metod pomocniczych (jak alphabetize) w streamach jest dużo ważniejsze niż w kodzie iteracyjnym. Poza tym jest też kilka rzeczy, które możemy robić w zwykłych blokach kodu, a nie możemy robić w lambdach: W lambdzie można tylko czytać zmienne final lub effectively final i nie można modyfikować żadnej zmiennej lokalnej. W lambdzie nie można zwrócić wyniku do zewnętrznej funkcji, wywołać break lub continue w zewnętrznej pętli, lub rzucić jakiegokolwiek wyjątku, który zewnętrzna funkcja zadeklarowała. Pure functions Streamy to nie tylko API, to paradygmat oparty na programowaniu funkcyjnym. Aby uzyskać ekspresyjność, wydajność i w niektórych przypadkach zdolność do równoległego przetwarzania, które streamy oferują, trzeba zaadaptować nie tylko API, ale i paradygmat. Najważniejszą rzeczą, do której powinniśmy dążyć, jest to, aby nasze obiekty funkcyjne były jak najbardziej zbliżone do tzn. pure function. Pure function to taka, która polega tylko na tym, co dostaje w argumencie - nie polega na żadnym innym zmiennym stanie ani nie zmienia stanu żadnego innego obiektu. Jednym słowem jest funkcją bez żadnych efektów ubocznych (pure function = side-effects free function). Zobaczmy na ten kawałek kodu, który tworzy mapę częstotliwości słów pobranych z pliku: // Uses the streams API but not the paradigm--Don't do this! Map&amp;lt;String, Long&amp;gt; freq = new HashMap&amp;lt;&amp;gt;(); try (Stream&amp;lt;String&amp;gt; words = new Scanner(file).tokens()) { words.forEach(word -&amp;gt; { freq.merge(word.toLowerCase(), 1L, Long::sum); }); } Co jest z tym kodem złego, jest czytelny, używa streamów, lambd i referencji do metod. Nawet działa zgodnie z założeniem. A no to, że to wcale nie jest kod streamowy. Jest to zwykły kod iteracyjny wrzucony do streamu. Nie czerpie żadnych korzyści z używania streamów, jest dłuższy niż powinien być i jest mniej czytelny. A to wszystko dlatego, że wykonuje wszystko w końcowej operacji forEach, używając lambdy, która zmienia stan zewnętrznego obiektu (mapy freq). Operacja forEach, która robi coś więcej niż prezentowanie wyniku czy dodanie wyniku do istniejącej już kolekcji, to bad smell. Właściwe wykorzystanie streamów powinno wyglądać tak: // Proper use of streams to initialize a frequency table Map&amp;lt;String, Long&amp;gt; freq; try (Stream&amp;lt;String&amp;gt; words = new Scanner(file).tokens()) { freq = words.collect(groupingBy(String::toLowerCase, counting())); } Jeśli ktoś pisze kod, podobny do wcześniejszego, to dlatego, że robi to w sposób, w który robił to dotychczas i z którym jest oswojony - niczym się to nie różni od pętli for-each. Lepsza wersja używa Collectors API (metody groupingBy i counting, które zostały zaimportowane statycznie dla lepszej czytelności). Jest to aż 39 metod, które są swego rodzaju implementacją strategi redukcji, tzn. łączenie elementów (w tym przypadku streamu) w pojedynczy obiekt. Oprócz tego najczęściej używa się collectory, które zbierają elementy streamu w kolekcję: toList(), toSet(), i toCollection(collectionFactory). Zwracają kolejno listę, set i inny podany przez nas typ kolekcji. Poza tym są jeszcze różne wariacje zbierania elementów do mapy. Dla przykładu wyciągnięcie 10 słów z największą częstotliwością z poprzedniej mapy: // Pipeline to get a top-ten list of words from a frequency table List&amp;lt;String&amp;gt; topTen = freq.keySet().stream() .sorted(comparing(freq::get).reversed()) .limit(10) .collect(toList()); W klasie Collectors jest jeszcze masa użytecznych metod. Polecam zajrzeć na ten wpis baeldung.com/java-8-collectors.</summary></entry><entry><title type="html">Interfejsy funkcyjne w bibliotece Javy</title><link href="https://devcave.pl/effective-java/interfejsy-funkcyjne-w-javie" rel="alternate" type="text/html" title="Interfejsy funkcyjne w bibliotece Javy" /><published>2019-01-12T09:00:00+01:00</published><updated>2019-01-12T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/interfejsy-funkcyjne-w-javie</id><content type="html" xml:base="https://devcave.pl/effective-java/interfejsy-funkcyjne-w-javie">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 44&lt;/i&gt; z rozdziału 7:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Lambdas and Streams&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 42: Prefer lambdas to anonymous classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/lambdy-zamiast-anonimowych-klas&quot;&gt;Item 43: Prefer method references to lambdas
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/interfejsy-funkcyjne-w-javie&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 44: Favor the use of standard functional interfaces
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;Item 45: Use streams judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/rozwazne-uzywanie-streamow&quot;&gt;Item 46: Prefer side-effect-free functions in streams
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;Item 47: Prefer Collection to Stream as a return type
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zwracanie-kolekcji-zamiast-streamow&quot;&gt;Item 48: Use caution when making streams parallel
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Chcąc sprawnie pisać metody i klasy, które działają na lambdach warto oswoić się z interfejsami funkcyjnymi dostępnymi w standardowej bibliotece Javy.&lt;/p&gt;

&lt;p&gt;Java udostępnia aż 43 interfejsy funkcyjne, ale bez obaw - jest tylko 6 głównych typów, które mają wiele wariacji, głównie ze względu na prymitywy. Wystarczy więc znać tylko te 6, a resztę łatwo można wyprowadzić, jako że mają dosyć regularne nazwy.&lt;/p&gt;

&lt;p&gt;Mamy więc:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Operator-y - interfejsy reprezentujące funkcję, której typ wyniku i argumentu są takie same.&lt;/li&gt;
  &lt;li&gt;Predicate-y - interfejsy reprezentujące funkcję, która przyjmuje argument i zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Function-y - interfejsy reprezentujące funkcję, której typ wyniku i argumentu się różni.&lt;/li&gt;
  &lt;li&gt;Supplier-y - interfejsy reprezentujące funkcję, która nie przyjmuję argumentu i zwraca wartość (dostarcza, &lt;em&gt;supplies&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;Consumer-y - interfejsy reprezentujące funkcję, która przyjmuje argument i nie zwraca nic (konsumuje, &lt;em&gt;consumes&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tabelka z przykładami:&lt;/p&gt;

&lt;table class=&quot;post-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Interface&lt;/th&gt;
      &lt;th&gt;Function Signature&lt;/th&gt;
      &lt;th&gt;Example&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T apply(T t)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String::toLowerCase&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T apply(T t1, T t2)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger::add&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean test(T t)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection::isEmpty&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&amp;lt;T,R&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R apply(T t)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays::asList&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T get()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Instant::now&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void accept(T t)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;System.out::println&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/code&gt; różni się od &lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/code&gt; tym, że ten drugi przyjmuje dwa argumenty.&lt;/p&gt;

&lt;p&gt;Każdy z tych interfejsów ma wariację do pracy z prymitywami: &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;, i &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;. Nazwy tych interfejsów biorą się z tego, że na początku dodawany jest typ prymitywny, który obsługują. Dla przykładu - &lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&lt;/code&gt;, który przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, to &lt;code class=&quot;highlighter-rouge&quot;&gt;IntPredicate&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryOperator&lt;/code&gt;, który przyjmuje dwie wartości &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt; i zwraca również &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;, to &lt;code class=&quot;highlighter-rouge&quot;&gt;LongBinaryOperator&lt;/code&gt;. Żaden z tych interfejsów nie jest parametryzowany, z wyjątkiem interfejsów z grupy &lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;, które parametryzują zwracany typ np. &lt;code class=&quot;highlighter-rouge&quot;&gt;LongFunction&amp;lt;int[]&amp;gt;&lt;/code&gt; przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt; i zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;int[]&lt;/code&gt;. Wszystkie wariacje:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleUnaryOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntUnaryOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongUnaryOperator&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleBinaryOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntBinaryOperator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongBinaryOperator&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntPredicate&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePredicate&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongPredicate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IntFunction&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongFunction&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleFunction&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleSupplier&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongSupplier&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntSupplier&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleConsumer&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntConsumer&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongConsumer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do tego jest 9 wariacji interfejsu &lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;, w wypadku, gdy zwracany typ to prymityw. Typ argumentu i wyniku powinien zawsze się różnić, bo interfejs funkcyjny, który pobiera i zwraca to samo, to &lt;code class=&quot;highlighter-rouge&quot;&gt;UnaryOperator&lt;/code&gt;. Jeśli oba typy są prymitywami (typ argumentu i ten zwracany), to prefixujemy &lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt; z &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ArgType&amp;gt;To&amp;lt;Result&amp;gt;&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;LongToIntFunction&lt;/code&gt;. W sumie mamy 6 takich wariacji:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleToIntFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleToLongFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntToDoubleFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IntToLongFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongToIntFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LongToDoubleFunction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeśli typ argumentu jest prymitywem, a typ zwracany to referencja do obiektu, prefixujemy &lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt; z &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ArgType&amp;gt;ToObj&lt;/code&gt;, np. &lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleToObjFunction&lt;/code&gt;. Mamy w sumie 3 wariacje:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ToIntFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ToLongFunction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ToDoubleFunction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ponadto, są jeszcze 3 dwuargumentowe wersje 3 podstawowych interfejsów (dla których ma to sens): &lt;code class=&quot;highlighter-rouge&quot;&gt;BiPredicate&amp;lt;T,U&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BiFunction&amp;lt;T,U,R&amp;gt;&lt;/code&gt;, i &lt;code class=&quot;highlighter-rouge&quot;&gt;BiConsumer&amp;lt;T,U&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Są również wariacje &lt;code class=&quot;highlighter-rouge&quot;&gt;BiFunction&lt;/code&gt;, które zwracają 3 najważniejsze prymitywy: &lt;code class=&quot;highlighter-rouge&quot;&gt;ToIntBiFunction&amp;lt;T,U&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ToLongBiFunction&amp;lt;T,U&amp;gt;&lt;/code&gt;, i &lt;code class=&quot;highlighter-rouge&quot;&gt;ToDoubleBiFunction&amp;lt;T,U&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dodatkowo &lt;code class=&quot;highlighter-rouge&quot;&gt;Consumer&lt;/code&gt; ma 3 dodatkowe wersje, które pobierają referencję do obiektu i prymityw: &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjDoubleConsumer&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjIntConsumer&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjLongConsumer&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;W sumie mamy 9 dwuargumentowych interfejsów funkcyjnych.&lt;/p&gt;

&lt;p&gt;Ostatni z nich to &lt;code class=&quot;highlighter-rouge&quot;&gt;BooleanSupplier&lt;/code&gt;, który jest wariacją &lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&lt;/code&gt;-a, który zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt; i jest to jedyny wariant, który korzysta bezpośrednio z &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;, ale &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt; jako zwracany typ jest wspierany jeszcze w interfejsie &lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&lt;/code&gt; i jego 4 wariacjach.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Nie powinniśmy używać podstawowych interfejsów funkcyjnych z opakowanymi prymitywami zamiast wariacji z prymitywami. Ich wydajność, jest dużo gorsza, a najbardziej to widać, gdy są używane masowo. Ogólnie powinniśmy unikać autoboxingu, gdzie się da.&lt;/p&gt;

&lt;p&gt;Jeśli którykolwiek interfejs ze standardowej biblioteki pasuje do naszego zastosowania, to w większości przypadków powinniśmy go użyć. To sprawi, że nasze API będzie łatwiejsze do zrozumienia, a ponadto standardowe interfejsy dostarczają przydatne domyślne metody.&lt;/p&gt;

&lt;p&gt;Czasem jednak może się zdarzyć, że nie znajdziemy interfejsu do naszego zastosowania, np. będziemy potrzebować &lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&lt;/code&gt;, który przyjmuje 3 parametry, lub taki, który rzuca &lt;em&gt;checked exception&lt;/em&gt;. Może też się zdarzyć, że lepiej będzie napisać swój interfejs funkcyjny, mimo że mamy już identyczny strukturalnie w standardowej bibliotece.&lt;/p&gt;

&lt;p&gt;Jako przykład weźmy znany &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt;, który strukturą jest identyczny z &lt;code class=&quot;highlighter-rouge&quot;&gt;ToIntBiFunction&amp;lt;T,T&amp;gt;&lt;/code&gt;. Dlaczego zasługuje na osobny interfejs?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jego nazwa dostarcza świetną dokumentację&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt; ma mocne wymagania, co do tego, co stanowi jego prawidłową instancję (co składa się na jego kontrakt). Implementując ten interfejs, zobowiązujemy się, spełnić ten kontrakt.&lt;/li&gt;
  &lt;li&gt;Zawiera wiele przydatnych metod domyślnych do przekształcania i łączenia komparatorów.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Więc warto rozważyć napisanie swojego interfejsu funkcyjnego gdy:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Może zyskać na opisowej nazwie i dokumentacji.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ma silny kontrakt z nim powiązany.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Może zyskać na customowych domyślnych metodach.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tworząc funkcjonalny interfejs, należy go oznaczyć adnotacją &lt;code class=&quot;highlighter-rouge&quot;&gt;@FunctionalInterface&lt;/code&gt;, który mówi użytkownikom, że obsługuje lambdy, oraz co ważniejsze - skompiluje się tylko wtedy, gdy będzie miał dokładnie jedną metodę abstrakcyjną, co powstrzymuje kogokolwiek, przed dodaniem do interfejsu kolejnej abstrakcyjnej metody.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 44 z rozdziału 7: Lambdas and Streams Item 42: Prefer lambdas to anonymous classes Item 43: Prefer method references to lambdas Item 44: Favor the use of standard functional interfaces Item 45: Use streams judiciously Item 46: Prefer side-effect-free functions in streams Item 47: Prefer Collection to Stream as a return type Item 48: Use caution when making streams parallel Chcąc sprawnie pisać metody i klasy, które działają na lambdach warto oswoić się z interfejsami funkcyjnymi dostępnymi w standardowej bibliotece Javy. Java udostępnia aż 43 interfejsy funkcyjne, ale bez obaw - jest tylko 6 głównych typów, które mają wiele wariacji, głównie ze względu na prymitywy. Wystarczy więc znać tylko te 6, a resztę łatwo można wyprowadzić, jako że mają dosyć regularne nazwy. Mamy więc: Operator-y - interfejsy reprezentujące funkcję, której typ wyniku i argumentu są takie same. Predicate-y - interfejsy reprezentujące funkcję, która przyjmuje argument i zwraca boolean. Function-y - interfejsy reprezentujące funkcję, której typ wyniku i argumentu się różni. Supplier-y - interfejsy reprezentujące funkcję, która nie przyjmuję argumentu i zwraca wartość (dostarcza, supplies) Consumer-y - interfejsy reprezentujące funkcję, która przyjmuje argument i nie zwraca nic (konsumuje, consumes) Tabelka z przykładami: Interface Function Signature Example UnaryOperator&amp;lt;T&amp;gt; T apply(T t) String::toLowerCase BinaryOperator&amp;lt;T&amp;gt; T apply(T t1, T t2) BigInteger::add Predicate&amp;lt;T&amp;gt; boolean test(T t) Collection::isEmpty Function&amp;lt;T,R&amp;gt; R apply(T t) Arrays::asList Supplier&amp;lt;T&amp;gt; T get() Instant::now Consumer&amp;lt;T&amp;gt; void accept(T t) System.out::println UnaryOperator&amp;lt;T&amp;gt; różni się od BinaryOperator&amp;lt;T&amp;gt; tym, że ten drugi przyjmuje dwa argumenty. Każdy z tych interfejsów ma wariację do pracy z prymitywami: int, long, i double. Nazwy tych interfejsów biorą się z tego, że na początku dodawany jest typ prymitywny, który obsługują. Dla przykładu - Predicate, który przyjmuje int, to IntPredicate, a BinaryOperator, który przyjmuje dwie wartości long i zwraca również long, to LongBinaryOperator. Żaden z tych interfejsów nie jest parametryzowany, z wyjątkiem interfejsów z grupy Function, które parametryzują zwracany typ np. LongFunction&amp;lt;int[]&amp;gt; przyjmuje long i zwraca int[]. Wszystkie wariacje: DoubleUnaryOperator, IntUnaryOperator, LongUnaryOperator DoubleBinaryOperator, IntBinaryOperator, LongBinaryOperator IntPredicate, DoublePredicate, LongPredicate IntFunction&amp;lt;T&amp;gt;, LongFunction&amp;lt;T&amp;gt;, DoubleFunction&amp;lt;T&amp;gt; DoubleSupplier, LongSupplier, IntSupplier DoubleConsumer, IntConsumer, LongConsumer Do tego jest 9 wariacji interfejsu Function, w wypadku, gdy zwracany typ to prymityw. Typ argumentu i wyniku powinien zawsze się różnić, bo interfejs funkcyjny, który pobiera i zwraca to samo, to UnaryOperator. Jeśli oba typy są prymitywami (typ argumentu i ten zwracany), to prefixujemy Function z &amp;lt;ArgType&amp;gt;To&amp;lt;Result&amp;gt; np. LongToIntFunction. W sumie mamy 6 takich wariacji: DoubleToIntFunction, DoubleToLongFunction, IntToDoubleFunction, IntToLongFunction, LongToIntFunction, LongToDoubleFunction Jeśli typ argumentu jest prymitywem, a typ zwracany to referencja do obiektu, prefixujemy Function z &amp;lt;ArgType&amp;gt;ToObj, np. DoubleToObjFunction. Mamy w sumie 3 wariacje: ToIntFunction, ToLongFunction, ToDoubleFunction Ponadto, są jeszcze 3 dwuargumentowe wersje 3 podstawowych interfejsów (dla których ma to sens): BiPredicate&amp;lt;T,U&amp;gt;, BiFunction&amp;lt;T,U,R&amp;gt;, i BiConsumer&amp;lt;T,U&amp;gt;. Są również wariacje BiFunction, które zwracają 3 najważniejsze prymitywy: ToIntBiFunction&amp;lt;T,U&amp;gt;, ToLongBiFunction&amp;lt;T,U&amp;gt;, i ToDoubleBiFunction&amp;lt;T,U&amp;gt;. Dodatkowo Consumer ma 3 dodatkowe wersje, które pobierają referencję do obiektu i prymityw: ObjDoubleConsumer&amp;lt;T&amp;gt;, ObjIntConsumer&amp;lt;T&amp;gt;, ObjLongConsumer&amp;lt;T&amp;gt;. W sumie mamy 9 dwuargumentowych interfejsów funkcyjnych. Ostatni z nich to BooleanSupplier, który jest wariacją Supplier-a, który zwraca boolean i jest to jedyny wariant, który korzysta bezpośrednio z boolean, ale boolean jako zwracany typ jest wspierany jeszcze w interfejsie Predicate i jego 4 wariacjach. Nie powinniśmy używać podstawowych interfejsów funkcyjnych z opakowanymi prymitywami zamiast wariacji z prymitywami. Ich wydajność, jest dużo gorsza, a najbardziej to widać, gdy są używane masowo. Ogólnie powinniśmy unikać autoboxingu, gdzie się da. Jeśli którykolwiek interfejs ze standardowej biblioteki pasuje do naszego zastosowania, to w większości przypadków powinniśmy go użyć. To sprawi, że nasze API będzie łatwiejsze do zrozumienia, a ponadto standardowe interfejsy dostarczają przydatne domyślne metody. Czasem jednak może się zdarzyć, że nie znajdziemy interfejsu do naszego zastosowania, np. będziemy potrzebować Predicate, który przyjmuje 3 parametry, lub taki, który rzuca checked exception. Może też się zdarzyć, że lepiej będzie napisać swój interfejs funkcyjny, mimo że mamy już identyczny strukturalnie w standardowej bibliotece. Jako przykład weźmy znany Comparator&amp;lt;T&amp;gt;, który strukturą jest identyczny z ToIntBiFunction&amp;lt;T,T&amp;gt;. Dlaczego zasługuje na osobny interfejs? Jego nazwa dostarcza świetną dokumentację Comparator ma mocne wymagania, co do tego, co stanowi jego prawidłową instancję (co składa się na jego kontrakt). Implementując ten interfejs, zobowiązujemy się, spełnić ten kontrakt. Zawiera wiele przydatnych metod domyślnych do przekształcania i łączenia komparatorów. Więc warto rozważyć napisanie swojego interfejsu funkcyjnego gdy: Może zyskać na opisowej nazwie i dokumentacji. Ma silny kontrakt z nim powiązany. Może zyskać na customowych domyślnych metodach. Tworząc funkcjonalny interfejs, należy go oznaczyć adnotacją @FunctionalInterface, który mówi użytkownikom, że obsługuje lambdy, oraz co ważniejsze - skompiluje się tylko wtedy, gdy będzie miał dokładnie jedną metodę abstrakcyjną, co powstrzymuje kogokolwiek, przed dodaniem do interfejsu kolejnej abstrakcyjnej metody.</summary></entry></feed>