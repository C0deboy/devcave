<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://devcave.pl/feed.xml" rel="self" type="application/atom+xml" /><link href="https://devcave.pl/" rel="alternate" type="text/html" /><updated>2023-12-04T17:23:47+01:00</updated><id>https://devcave.pl/feed.xml</id><title type="html">devcave.pl</title><subtitle>Devcave - blog programisty na tematy związane z branżą IT, a szczególnie z programowaniem w Javie.</subtitle><entry><title type="html">Wyjątki - dobre praktyki</title><link href="https://devcave.pl/effective-java/wyjatki-dobre-praktyki" rel="alternate" type="text/html" title="Wyjątki - dobre praktyki" /><published>2020-09-01T10:00:00+02:00</published><updated>2020-09-01T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/wyjatki-dobre-praktyki</id><content type="html" xml:base="https://devcave.pl/effective-java/wyjatki-dobre-praktyki">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 72, 73, 74, 75, 76, 77&lt;/i&gt; z rozdziału 10:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Exceptions&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;Item 69: Use exceptions only for exceptional conditions
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;Item 71: Avoid unnecessary use of checked exceptions
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 72: Favor the use of standard exceptions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 73: Throw exceptions appropriate to the abstraction
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 74: Document all exceptions thrown by each method
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 75: Include failure-capture information in detail messages
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 76: Strive for failure atomicity
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 77: Don’t ignore exceptions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Kolejne tematy dotyczą dobrych praktyk dla wyjątków i są dosyć rozwlekle opisane w książce, więc postanowiłem zebrać je i krótko opisać w jednym poście.&lt;/p&gt;

&lt;h1 id=&quot;reużywaj-istniejące-wyjątki-w-javie&quot;&gt;Reużywaj istniejące wyjątki w Javie&lt;/h1&gt;

&lt;p&gt;Reużywanie kodu jest pożądaną rzeczą i wyjątki nie są tu wyjątkiem.&lt;/p&gt;

&lt;p&gt;Ma to kilka swoich zalet:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API jest łatwiejsze do nauczenia, ponieważ korzysta z wszystkim dobrze znanych konwencji&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Z czym jak najbardziej się zgadzam, jednak dwie kolejne zalety wymienione przez autora są już trochę na siłę:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API jest łatwiejsze w czytaniu, ponieważ nie jest zaśmiecone nieznanymi wyjątkami&lt;/li&gt;
  &lt;li&gt;Mniej klas wyjątków równa się mniejszemu odcisku na pamięci i mniejszym czasem spędzonym na ładowaniu klas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Według mnie druga to to samo co pierwsza, a trzecia może miała większe znaczenie jakiś czas temu. Teraz ważniejsza jest czytelność kodu niż to, że zaoszczędzimy jedną klasę reużywając inną, która może nie do końca spełnia nasze wymagania.&lt;/p&gt;

&lt;p&gt;Wyjątki, które można reużywać w Javie to:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt; — rzucany, gdy został podany niepoprawny argument np. podanie ujemnej liczby, która miała reprezentować liczbę powtórzeń danej akcji.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalStateException&lt;/code&gt; — rzucany, gdy stan obiektu nie jest odpowiedni, a została wywołana zależna metoda np. próba użycia obiektu, który nie został jeszcze zainicjalizowany.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt; — to samo co &lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt; tylko gdy podana jest wartość &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; i jest nieakceptowalna.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IndexOutOfBoundsException&lt;/code&gt; — to samo co &lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt; tylko dla konkretnego przypadku: index jest poza dozwolonym zakresem&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt; — rzucany, gdy obiekt był zaprojektowany do użycia przez tylko jeden wątek (lub z zewnętrzną synchronizacją), a wykrył zmianę, która odbyła się współbieżnie. To w najlepszym wypadku jest tylko wskazówką, bo tak naprawdę nie jest możliwe wykrycie takich zmian w 100% wiarygodny sposób.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnsupportedOperationException&lt;/code&gt; - rzucany, gdy obiekt umyślnie nie wspiera danej operacji np. zdefiniowanej w interfejsie. Przykładem może być tu implementacja &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, do której możemy tylko dorzucać kolejne elementy. Wtedy metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt; rzuciła by ten wyjątek.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Nie reużywaj bezpośrednio &lt;code class=&quot;highlighter-rouge&quot;&gt;**Exception**&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;**RuntimeException**&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;**Throwable**&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;**Error**&lt;/code&gt;. Traktuje te klasy jakby były abstrakcyjne.&lt;/p&gt;

&lt;p&gt;Podsumowanie:&lt;/p&gt;

&lt;table class=&quot;post-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Wyjątek&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Okazja do użycia&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Parametr nie będący &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; jest niepoprawny&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalStateException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Stan obiektu jest niepoprawny w chwili wywoływania metody&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Parametr przekazany jest jako &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, a jest to nie akceptowalne&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Index jest poza dozwolonym zakresem&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Wykrycie niedozwolonej modyfikacji współbieżnej&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnsupportedOperationException&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Obiekt nie wspiera danej metody&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Są jeszcze inne rzadziej używane wyjątki, które można by reużyć np. &lt;code class=&quot;highlighter-rouge&quot;&gt;ArithmeticException&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;NumberFormatException&lt;/code&gt;, gdy projektujemy klasę zajmującą się arytmetyką.&lt;/p&gt;

&lt;p&gt;Na ogół zasada jest taka, że jeśli jakikolwiek wyjątek spełnia nasze potrzeby, to możemy go śmiało reużyć, jednak ważne jest to, żeby dokumentacja wyjątku była zgodna z naszym użyciem, nie tylko nazwa.&lt;/p&gt;

&lt;h1 id=&quot;rzucajmy-wyjątki-odpowiednie-dla-poziomu-abstrakcji-metody&quot;&gt;Rzucajmy wyjątki odpowiednie dla poziomu abstrakcji metody&lt;/h1&gt;

&lt;p&gt;Gdy metoda rzuca wyjątek, który nie ma oczywistego połączenia z zadaniem, które miała wykonać, w najlepszym wypadku spowoduje to lekkie zdezorientowanie programisty. Poza tym w takich wypadkach wysokopoziomowy kod jest zanieczyszczany detalami implementacyjnymi i jeśli zostaną one zmienione, mogą spowodować, że programy klienckie przestaną działać.&lt;/p&gt;

&lt;p&gt;Aby pozbyć się takiego problemu, &lt;strong&gt;warstwy wysokopoziomowe powinny łapać wyjątki z niższego poziomu i zamiast nich rzucać wyjątki, które są odpowiednie dla abstrakcji wysokopoziomowej&lt;/strong&gt;. Nazywa się to &lt;strong&gt;&lt;em&gt;exception translation&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Exception Translation&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Use lower-level abstraction to do our bidding  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LowerLevelException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Przykład z Javy, gdzie akurat &lt;strong&gt;&lt;em&gt;exception translation&lt;/em&gt;&lt;/strong&gt; jest wymuszone przez specyfikację metody &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; w interfejsie &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**  
* Returns the element at the specified position in this list.  
* @throws IndexOutOfBoundsException if the index is out of range  
* ({@code index &amp;lt; 0 || index &amp;gt;= size()}).  
*/&lt;/span&gt;  
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;nc&quot;&gt;ListIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NoSuchElementException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IndexOutOfBoundsException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Index: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Czasem warto też przekazać niskopoziomowy wyjątek do tego wysokopoziomowego. Może ułatwić to debugowanie problemów, ponieważ dzięki metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;getCause&lt;/code&gt; mamy dostęp do pierwotnego powodu wystąpienia problemu (wyjątku) oraz cały jego stack trace jest dołączany do naszego wysokopoziomowego wyjątku. Nazywa się to &lt;strong&gt;&lt;em&gt;exception chaining&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Exception Chaining&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Use lower-level abstraction to do our bidding  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LowerLevelException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wyjątki powinny mieć &lt;em&gt;chaining-aware constructor&lt;/em&gt;, aby to umożliwić:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Exception with chaining-aware constructor&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HigherLevelException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;nc&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A jeśli nie mają, to można skorzystać z metody &lt;code class=&quot;highlighter-rouge&quot;&gt;initCause&lt;/code&gt; z &lt;code class=&quot;highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Oczywiście jak większość rzeczy w programowaniu nie powinniśmy tego nadużywać i w pierwszej kolejności dobrą praktyką jest unikanie propagowania wyjątków niskopoziomowych.&lt;/strong&gt; Najpierw zastanówmy się, czy mamy możliwość je obsłużyć, obejść lub upewnić się wcześniej, że metoda wykona się pomyślnie.&lt;/p&gt;

&lt;p&gt;Kolejne tematy są nieco rozwlekle opisane w książce, a przedstawiają kilka prostych dobrych praktyk, więc skrócę je znacznie:&lt;/p&gt;

&lt;h1 id=&quot;dokumentuj-wszystkie-wyjątki-rzucane-przez-metodę&quot;&gt;Dokumentuj wszystkie wyjątki rzucane przez metodę&lt;/h1&gt;

&lt;p&gt;Dokumentowanie wyjątków jest niezwykle pomocne, dlatego powinniśmy dokumentować każdy rzucany wyjątek osobno i jasno opisywać, pod jakimi warunkami wystąpi. Dotyczy się to zarówno wyjątków &lt;em&gt;checked&lt;/em&gt; oraz &lt;em&gt;unchecked&lt;/em&gt;. Szczególnie pomocne jest dokumentowanie wyjątków &lt;em&gt;unchecked&lt;/em&gt;, bo bez tego nawet nie mamy pojęcia, że w ogóle występują — możemy dowiedzieć się jedynie w &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Aby łatwo rozróżnić w dokumentacji &lt;em&gt;checked exception&lt;/em&gt; oraz &lt;em&gt;unchecked exception&lt;/em&gt;, powinno używać się &lt;code class=&quot;highlighter-rouge&quot;&gt;@throws&lt;/code&gt; tylko do tych &lt;em&gt;checked&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;uwzględniaj-parametry-które-wywołały-błąd-generując-message&quot;&gt;Uwzględniaj parametry, które wywołały błąd generując message&lt;/h1&gt;

&lt;p&gt;Dokładne opisanie błędu znacznie ułatwia zrozumienie powodu jego wystąpienia, dlatego powinniśmy załączyć jak najwięcej informacji generując &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt; dla danego wyjątku.&lt;/p&gt;

&lt;p&gt;Dobrym pomysłem jest wymuszenie podania kluczowych parametrów już w samym konstruktorze wyjątku:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**  
* Constructs an IndexOutOfBoundsException.  
*  
* @param lowerBound the lowest legal index value  
* @param upperBound the highest legal index value plus one  
* @param index the actual index value  
*/&lt;/span&gt;  
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IndexOutOfBoundsException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowerBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;upperBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// Generate a detail message that captures the failure&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Lower bound: %d, Upper bound: %d, Index: %d&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;lowerBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;upperBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
      
    &lt;span class=&quot;c1&quot;&gt;// Save failure information for programmatic access  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lowerBound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowerBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;upperBound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;upperBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;po-błędzie-obiekt-powinien-mieć-pierwotny-stan&quot;&gt;Po błędzie obiekt powinien mieć pierwotny stan&lt;/h1&gt;

&lt;p&gt;Stan obiektu po błędnym wywołaniu metody powinien być taki jak przed wywołaniem, aby była możliwość jego dalszego bezbłędnego używania.&lt;/p&gt;

&lt;p&gt;Jeśli metoda ma taką właściwość, to można powiedzieć, że jest &lt;em&gt;failure-atomic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jest kilka sposobów, żeby to osiągnąć:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Projektowanie niemutowalnych obiektów — wtedy &lt;em&gt;failure atomicity&lt;/em&gt; mamy za darmo&lt;/li&gt;
  &lt;li&gt;Sprawdzanie parametrów przed wykonywaniem modyfikacji stanu&lt;/li&gt;
  &lt;li&gt;Ułożenie operacji w takich sposób, że te, co mogą się nie powieść, są na początku, a te modyfikujące są na końcu&lt;/li&gt;
  &lt;li&gt;Pracowanie na kopii obiektu i podmiana, jeśli wszystko jest ok&lt;/li&gt;
  &lt;li&gt;Napisanie kodu przywracającego poprzedni stan — czyli jeśli mamy błąd to robimy &lt;em&gt;rollback&lt;/em&gt; (wycofanie zmian)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;nie-ignoruj-wyjątków&quot;&gt;Nie ignoruj wyjątków&lt;/h1&gt;

&lt;p&gt;W kołko wszędzie powtarzana zasada — nie ignorujmy wyjątków:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Empty catch block ignores exception - Highly suspect! &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SomeException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Powoduje to, że błąd idzie w eter i nigdy się o nim nie dowiemy, co jest źródłem wielu problemów.&lt;/p&gt;

&lt;p&gt;Absolutnym minimum jest przynajmniej wylogowanie tego błędu, to nie wymaga dużej pracy, a przynajmniej będziemy mieć jakiekolwiek pojęcie o tym, że coś się wydarzyło.&lt;/p&gt;

&lt;p&gt;Są jednak sytuacje, że ignorowanie wyjątku jest odpowiednie. W takich sytuacjach powinniśmy to jasno pokazać:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wyjątek powinniśmy nazwać &lt;code class=&quot;highlighter-rouge&quot;&gt;ignored&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;dodać komentarz/log, który nam powie, dlaczego zignorowaliśmy wyjątek i że to jest ok&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;planarMap:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chromaticNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numColors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Default; guaranteed sufficient for any map  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;numColors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TimeoutException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExecutionException&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ignored&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// Use default: minimal coloring is desirable, not required  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 72, 73, 74, 75, 76, 77 z rozdziału 10: Exceptions Item 69: Use exceptions only for exceptional conditions Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors Item 71: Avoid unnecessary use of checked exceptions Item 72: Favor the use of standard exceptions Item 73: Throw exceptions appropriate to the abstraction Item 74: Document all exceptions thrown by each method Item 75: Include failure-capture information in detail messages Item 76: Strive for failure atomicity Item 77: Don’t ignore exceptions Kolejne tematy dotyczą dobrych praktyk dla wyjątków i są dosyć rozwlekle opisane w książce, więc postanowiłem zebrać je i krótko opisać w jednym poście. Reużywaj istniejące wyjątki w Javie Reużywanie kodu jest pożądaną rzeczą i wyjątki nie są tu wyjątkiem. Ma to kilka swoich zalet: API jest łatwiejsze do nauczenia, ponieważ korzysta z wszystkim dobrze znanych konwencji Z czym jak najbardziej się zgadzam, jednak dwie kolejne zalety wymienione przez autora są już trochę na siłę: API jest łatwiejsze w czytaniu, ponieważ nie jest zaśmiecone nieznanymi wyjątkami Mniej klas wyjątków równa się mniejszemu odcisku na pamięci i mniejszym czasem spędzonym na ładowaniu klas Według mnie druga to to samo co pierwsza, a trzecia może miała większe znaczenie jakiś czas temu. Teraz ważniejsza jest czytelność kodu niż to, że zaoszczędzimy jedną klasę reużywając inną, która może nie do końca spełnia nasze wymagania. Wyjątki, które można reużywać w Javie to: IllegalArgumentException — rzucany, gdy został podany niepoprawny argument np. podanie ujemnej liczby, która miała reprezentować liczbę powtórzeń danej akcji. IllegalStateException — rzucany, gdy stan obiektu nie jest odpowiedni, a została wywołana zależna metoda np. próba użycia obiektu, który nie został jeszcze zainicjalizowany. NullPointerException — to samo co IllegalArgumentException tylko gdy podana jest wartość null i jest nieakceptowalna. IndexOutOfBoundsException — to samo co IllegalArgumentException tylko dla konkretnego przypadku: index jest poza dozwolonym zakresem ConcurrentModificationException — rzucany, gdy obiekt był zaprojektowany do użycia przez tylko jeden wątek (lub z zewnętrzną synchronizacją), a wykrył zmianę, która odbyła się współbieżnie. To w najlepszym wypadku jest tylko wskazówką, bo tak naprawdę nie jest możliwe wykrycie takich zmian w 100% wiarygodny sposób. UnsupportedOperationException - rzucany, gdy obiekt umyślnie nie wspiera danej operacji np. zdefiniowanej w interfejsie. Przykładem może być tu implementacja List, do której możemy tylko dorzucać kolejne elementy. Wtedy metoda delete() rzuciła by ten wyjątek. Nie reużywaj bezpośrednio **Exception**, **RuntimeException**, **Throwable** i **Error**. Traktuje te klasy jakby były abstrakcyjne. Podsumowanie: Wyjątek Okazja do użycia IllegalArgumentException Parametr nie będący null jest niepoprawny IllegalStateException Stan obiektu jest niepoprawny w chwili wywoływania metody NullPointerException Parametr przekazany jest jako null, a jest to nie akceptowalne IndexOutOfBoundsException Index jest poza dozwolonym zakresem ConcurrentModificationException Wykrycie niedozwolonej modyfikacji współbieżnej UnsupportedOperationException Obiekt nie wspiera danej metody Są jeszcze inne rzadziej używane wyjątki, które można by reużyć np. ArithmeticException i NumberFormatException, gdy projektujemy klasę zajmującą się arytmetyką. Na ogół zasada jest taka, że jeśli jakikolwiek wyjątek spełnia nasze potrzeby, to możemy go śmiało reużyć, jednak ważne jest to, żeby dokumentacja wyjątku była zgodna z naszym użyciem, nie tylko nazwa. Rzucajmy wyjątki odpowiednie dla poziomu abstrakcji metody Gdy metoda rzuca wyjątek, który nie ma oczywistego połączenia z zadaniem, które miała wykonać, w najlepszym wypadku spowoduje to lekkie zdezorientowanie programisty. Poza tym w takich wypadkach wysokopoziomowy kod jest zanieczyszczany detalami implementacyjnymi i jeśli zostaną one zmienione, mogą spowodować, że programy klienckie przestaną działać. Aby pozbyć się takiego problemu, warstwy wysokopoziomowe powinny łapać wyjątki z niższego poziomu i zamiast nich rzucać wyjątki, które są odpowiednie dla abstrakcji wysokopoziomowej. Nazywa się to exception translation: // Exception Translation try { ... // Use lower-level abstraction to do our bidding } catch (LowerLevelException e) { throw new HigherLevelException(...); } Przykład z Javy, gdzie akurat exception translation jest wymuszone przez specyfikację metody get w interfejsie List&amp;lt;E&amp;gt;: /** * Returns the element at the specified position in this list. * @throws IndexOutOfBoundsException if the index is out of range * ({@code index &amp;lt; 0 || index &amp;gt;= size()}). */ public E get(int index) { ListIterator&amp;lt;E&amp;gt; i = listIterator(index); try { return i.next(); } catch (NoSuchElementException e) { throw new IndexOutOfBoundsException(&quot;Index: &quot; + index); } } Czasem warto też przekazać niskopoziomowy wyjątek do tego wysokopoziomowego. Może ułatwić to debugowanie problemów, ponieważ dzięki metodzie getCause mamy dostęp do pierwotnego powodu wystąpienia problemu (wyjątku) oraz cały jego stack trace jest dołączany do naszego wysokopoziomowego wyjątku. Nazywa się to exception chaining: // Exception Chaining try { ... // Use lower-level abstraction to do our bidding } catch (LowerLevelException cause) { throw new HigherLevelException(cause); } Wyjątki powinny mieć chaining-aware constructor, aby to umożliwić: // Exception with chaining-aware constructor class HigherLevelException extends Exception { HigherLevelException(Throwable cause) { super(cause); } } A jeśli nie mają, to można skorzystać z metody initCause z Throwable. Oczywiście jak większość rzeczy w programowaniu nie powinniśmy tego nadużywać i w pierwszej kolejności dobrą praktyką jest unikanie propagowania wyjątków niskopoziomowych. Najpierw zastanówmy się, czy mamy możliwość je obsłużyć, obejść lub upewnić się wcześniej, że metoda wykona się pomyślnie. Kolejne tematy są nieco rozwlekle opisane w książce, a przedstawiają kilka prostych dobrych praktyk, więc skrócę je znacznie: Dokumentuj wszystkie wyjątki rzucane przez metodę Dokumentowanie wyjątków jest niezwykle pomocne, dlatego powinniśmy dokumentować każdy rzucany wyjątek osobno i jasno opisywać, pod jakimi warunkami wystąpi. Dotyczy się to zarówno wyjątków checked oraz unchecked. Szczególnie pomocne jest dokumentowanie wyjątków unchecked, bo bez tego nawet nie mamy pojęcia, że w ogóle występują — możemy dowiedzieć się jedynie w runtime. Aby łatwo rozróżnić w dokumentacji checked exception oraz unchecked exception, powinno używać się @throws tylko do tych checked. Uwzględniaj parametry, które wywołały błąd generując message Dokładne opisanie błędu znacznie ułatwia zrozumienie powodu jego wystąpienia, dlatego powinniśmy załączyć jak najwięcej informacji generując message dla danego wyjątku. Dobrym pomysłem jest wymuszenie podania kluczowych parametrów już w samym konstruktorze wyjątku: /** * Constructs an IndexOutOfBoundsException. * * @param lowerBound the lowest legal index value * @param upperBound the highest legal index value plus one * @param index the actual index value */ public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) { // Generate a detail message that captures the failure super(String.format(&quot;Lower bound: %d, Upper bound: %d, Index: %d&quot;, lowerBound, upperBound, index)); // Save failure information for programmatic access this.lowerBound = lowerBound; this.upperBound = upperBound; this.index = index; } Po błędzie obiekt powinien mieć pierwotny stan Stan obiektu po błędnym wywołaniu metody powinien być taki jak przed wywołaniem, aby była możliwość jego dalszego bezbłędnego używania. Jeśli metoda ma taką właściwość, to można powiedzieć, że jest failure-atomic. Jest kilka sposobów, żeby to osiągnąć: Projektowanie niemutowalnych obiektów — wtedy failure atomicity mamy za darmo Sprawdzanie parametrów przed wykonywaniem modyfikacji stanu Ułożenie operacji w takich sposób, że te, co mogą się nie powieść, są na początku, a te modyfikujące są na końcu Pracowanie na kopii obiektu i podmiana, jeśli wszystko jest ok Napisanie kodu przywracającego poprzedni stan — czyli jeśli mamy błąd to robimy rollback (wycofanie zmian) Nie ignoruj wyjątków W kołko wszędzie powtarzana zasada — nie ignorujmy wyjątków: // Empty catch block ignores exception - Highly suspect! try { ... } catch (SomeException e) { } Powoduje to, że błąd idzie w eter i nigdy się o nim nie dowiemy, co jest źródłem wielu problemów. Absolutnym minimum jest przynajmniej wylogowanie tego błędu, to nie wymaga dużej pracy, a przynajmniej będziemy mieć jakiekolwiek pojęcie o tym, że coś się wydarzyło. Są jednak sytuacje, że ignorowanie wyjątku jest odpowiednie. W takich sytuacjach powinniśmy to jasno pokazać: wyjątek powinniśmy nazwać ignored dodać komentarz/log, który nam powie, dlaczego zignorowaliśmy wyjątek i że to jest ok Przykład: Future&amp;lt;Integer&amp;gt; f = exec.submit(planarMap::chromaticNumber); int numColors = 4; // Default; guaranteed sufficient for any map try { numColors = f.get(1L, TimeUnit.SECONDS); } catch (TimeoutException | ExecutionException ignored) { // Use default: minimal coloring is desirable, not required }</summary></entry><entry><title type="html">Wyjątki</title><link href="https://devcave.pl/effective-java/wyjatki" rel="alternate" type="text/html" title="Wyjątki" /><published>2020-07-18T10:00:00+02:00</published><updated>2020-07-18T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/wyjatki</id><content type="html" xml:base="https://devcave.pl/effective-java/wyjatki">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 69, 70, 71&lt;/i&gt; z rozdziału 10:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Exceptions&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 69: Use exceptions only for exceptional conditions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wyjatki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 71: Avoid unnecessary use of checked exceptions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 72: Favor the use of standard exceptions
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 73: Throw exceptions appropriate to the abstraction
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 74: Document all exceptions thrown by each method
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 75: Include failure-capture information in detail messages
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 76: Strive for failure atomicity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wyjatki-dobre-praktyki&quot;&gt;Item 77: Don’t ignore exceptions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Zaczynamy rozdział 10 po długiej przerwie :)&lt;/p&gt;

&lt;p&gt;W tym rozdziale będzie mowa o wyjątkach.&lt;/p&gt;

&lt;p&gt;Wyjątki w Javie są, jakie są, ale ogólnie jest to całkiem użyteczne narzędzie. Gdy są używane prawidłowo, mogą zwiększyć czytelność programu, jego stabilność i utrzymywalność. Z kolei, jeśli będą używane niepoprawnie, uzyskamy dokładnie odwrotny efekt, dlatego warto poświęcić im kilka słów.&lt;/p&gt;

&lt;h1 id=&quot;wyjątki-powinny-być-używane-tylko-w-wyjątkowych-sytuacjach&quot;&gt;Wyjątki powinny być używane tylko w wyjątkowych sytuacjach&lt;/h1&gt;

&lt;p&gt;Zresztą sama nazwa na to wskazuje. Niestety nie każdy o tym pamięta i dlatego wyjątki są często nadużywane.&lt;/p&gt;

&lt;p&gt;Oto przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Horrible abuse of exceptions. Don't ever do this!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;climb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayIndexOutOfBoundsException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co ten kod robi? Nie jest to oczywiste na pierwszy rzut oka, ale jest to po prostu najzwyklejsza iteracja po elementach tablicy. Nieskończona pętla &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; jest przerywana przez rzucenie wyjątku &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;, złapanie go, a następnie zignorowanie.&lt;/p&gt;

&lt;p&gt;Normalny człowiek napisałby to tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Mountain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;climb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W poprzednim przykładzie mamy wiele przykładów złych praktyk:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;użycie wyjątku tam, gdzie jest to zbędne&lt;/li&gt;
  &lt;li&gt;ignorowanie wyjątku&lt;/li&gt;
  &lt;li&gt;wynajdowanie koła na nowo&lt;/li&gt;
  &lt;li&gt;użycie wyjątków do sterowania przepływem programu&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Poza tym samo umieszczanie kodu w &lt;code class=&quot;highlighter-rouge&quot;&gt;try-catch&lt;/code&gt; uniemożliwia niektóre optymalizacje JVM, które bez niego zostałyby zastosowane.&lt;/p&gt;

&lt;p&gt;Wyjątków nie powinno się używać do sterowania przepływu programu, ponieważ wtedy łatwiej o bugi, które nawet mogą być przez to ukryte, co również utrudnia debugowanie.&lt;/p&gt;

&lt;p&gt;Wystarczy sobie wyobrazić, że w pętli byłaby wykonywana jakaś inna metoda, która też miałaby możliwość rzucić &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; z całkiem innej, niepowiązanej tablicy. W takiej sytuacji ten błąd spowodowałby, że pętla zakończyłaby się wcześniej, niż powinna i zostałoby to potraktowane jako prawidłowe zachowanie (wyjątek jest ignorowany, nieważne co go wywołało).&lt;/p&gt;

&lt;p&gt;Te same zasady dotyczą projektowania API. Dobrze zaprojektowane API nie powinno zmuszać użytkownika, by używał wyjątków do sterowania przepływem programu.&lt;/p&gt;

&lt;p&gt;Klasa, która ma metodę zależną od stanu, która może być wywołana tylko pod określonymi warunkami, powinna udostępniać metodę sprawdzającą stan i określającą czy użycie metody zależnej od stanu jest odpowiednie.&lt;/p&gt;

&lt;p&gt;Przykładem może być interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;, który ma metodę zależną od stanu &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; i sprawdzającą stan &lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext&lt;/code&gt;. Dzięki temu mamy możliwość użycia go w zwykłych pętlach for:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli nie byłoby metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext&lt;/code&gt;, wtedy bylibyśmy zmuszeni do tego:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Do not use this hideous code for iteration over a collection!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NoSuchElementException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co ma wszystkie wady wspomniane wcześniej.&lt;/p&gt;

&lt;p&gt;Alternatywą dla metod testujących stan jest by metody zależne od stanu zwracały pusty &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; lub inną rozróżnialną wartość jak np. &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Należy to stosować, jeśli obiekt jest używany współbieżnie bez zewnętrznej synchronizacji lub udostępnia zmianę stanu z zewnątrz, ponieważ stan obiektu mógłby być zmieniony pomiędzy wywołaniami metody sprawdzającej, a tej zależnej od stanu.&lt;/p&gt;

&lt;p&gt;Obawy o wydajność mogłyby dyktować użycie klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; czy innej rozróżnialnej wartości, gdy metoda testująca duplikowałaby pracę metody zależnej od stanu, jednak ze wpisów o optymalizacji wiemy, że w większości wypadków nie powinniśmy się martwić o takie mikro optymalizacje. Metoda testująca stan oferuje lepszą czytelność i nieprawidłowe użycie jest łatwiejsze do wykrycia — jeśli zapomnimy wywołać metodę testującą, to metoda zależna od stanu rzuci wyjątek i błąd będzie oczywisty. Jeśli zapomnimy sprawdzić rozróżnialną wartość, która oznacza błąd, wtedy błąd może być trudniejszy do wychwycenia. Oczywiście nie dotyczy to użycia &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt;, ponieważ jest jasne, że metoda może nie zwrócić danej wartości i należy sprawdzić, czy istnieje.&lt;/p&gt;

&lt;p&gt;Kiedyś ta zasada miała dużo większe znaczenie, bo miała znaczny wpływ na wydajność. Obecnie w większości przypadków powinniśmy się kierować przejrzystością i prostotą kodu. Warto zerknąć na link &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/184654/ive-been-told-that-exceptions-should-only-be-used-in-exceptional-cases-how-do&quot;&gt;I’ve been told that Exceptions should only be used in exceptional cases. How do I know if my case is exceptional?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A szczególnie na odpowiedź:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Exceptions were invented to help make error handling easier with less code clutter. You should use them in cases when they make error handling easier with less code clutter. This “exceptions only for exceptional circumstances” business stems from a time when exception handling was deemed an unacceptable performance hit. That’s no longer the case in the vast majority of code, but people still spout the rule without remembering the reason behind it.&lt;/p&gt;

  &lt;p&gt;Especially in Java, which is maybe the most exception-loving language ever conceived, &lt;strong&gt;you shouldn’t feel bad about using exceptions when it simplifies your code&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Warto również rzucić okiem na &lt;a href=&quot;https://java.programmingpedia.net/en/tutorial/5381/java-pitfalls-exception-usage&quot;&gt;Java Pitfalls - Exception usage&lt;/a&gt;, gdzie znajdziemy przykłady problemów związanych z obsługą wyjątków.&lt;/p&gt;

&lt;h1 id=&quot;rodzaje-wyjątków-i-kiedy-jakie-używać&quot;&gt;Rodzaje wyjątków i kiedy jakie używać&lt;/h1&gt;

&lt;p&gt;W Javie mamy trzy rodzaje wyjątków: &lt;em&gt;checked exceptions&lt;/em&gt;, &lt;em&gt;runtime exceptions&lt;/em&gt; i &lt;em&gt;errors&lt;/em&gt;. Dwa ostatnie należą do grupy &lt;em&gt;unchecked exceptions&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Różnica pomiędzy nimi jest taka, że używając &lt;em&gt;checked exceptions&lt;/em&gt; w metodzie, musimy go zadeklarować w sekcji &lt;code class=&quot;highlighter-rouge&quot;&gt;throws&lt;/code&gt; i zmuszamy użytkownika tej metody, by obsłużył dany wyjątek używając &lt;code class=&quot;highlighter-rouge&quot;&gt;try catch&lt;/code&gt; lub aby podał go do obsługi wyżej deklarując ten wyjątek w sekcji &lt;code class=&quot;highlighter-rouge&quot;&gt;throws&lt;/code&gt;. Z kolei &lt;em&gt;unchecked exceptions&lt;/em&gt; są bardziej elastyczne w użyciu i nie ma przymusu ich obsługi czy deklarowania w sekcji &lt;code class=&quot;highlighter-rouge&quot;&gt;throws&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Decyzja, kiedy jaki rodzaj wyjątku użyć nie jest zawsze jednoznaczna, ale są ogólnie akceptowalne reguły i wskazówki, którymi powinniśmy się kierować.&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;W Javie jest silne akceptowalna konwencja, że &lt;em&gt;errors&lt;/em&gt; są zarezerwowane do użycia przez JVM i najlepiej nie implementować żadnych nowych podklas klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt; jak również nigdy nie rzucać tych już istniejących, z wyjątkiem &lt;code class=&quot;highlighter-rouge&quot;&gt;AssertionError&lt;/code&gt;. &lt;strong&gt;Implementując &lt;em&gt;unchecked exception&lt;/em&gt; powinniśmy rozszerzać klasę &lt;code class=&quot;highlighter-rouge&quot;&gt;RuntimeException&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;więc-kiedy-używać-checked-exceptions-a-kiedy-unchecked-exceptions&quot;&gt;Więc kiedy używać &lt;em&gt;checked exceptions&lt;/em&gt;, a kiedy &lt;em&gt;unchecked exceptions&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Najczęściej spotkamy się z zasadą, że &lt;em&gt;checked exceptions&lt;/em&gt; powinny być używane w sytuacjach, gdy wiemy, że użytkownik ma szansę wyjść z tego błędu cało.&lt;/p&gt;

&lt;p&gt;Jeśli metoda rzuca &lt;em&gt;unchecked exception&lt;/em&gt; to zazwyczaj oznacza, że nie może kontynuować wykonywania operacji, bo zakończyłoby się to niepowodzeniem i wyrządziłoby to więcej szkód niż dobra.&lt;/p&gt;

&lt;p&gt;Najczęstszym przypadkiem w tej sytuacji jest złe użycie API przez użytkownika, który nie dotrzymał wymagań specyfikacji API. Dla przykładu aby dostać się do wartości tablicy, specyfikacja mówi, że index musi być pomiędzy 0, a długością tablicy odjąć 1. Jeśli popełnimy błąd i podamy niepoprawny index to dostaniemy &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Unchecked exceptions&lt;/em&gt; są zatem najczęściej używane, by wskazać błąd programistyczny, z którego nie można już łatwo wyjść.&lt;/p&gt;

&lt;p&gt;Jak sam autor zauważa w książce, niestety nie zawsze jest jasne, kiedy mamy do czynienia z „&lt;em&gt;recoverable condition&lt;/em&gt;”, a kiedy z „&lt;em&gt;programming error&lt;/em&gt;”. Musimy więc kierować się własnym przeczuciem i stwierdzić czy dany błąd ma być „z góry” widoczny dla użytkownika i wymusić na nim obsługę tego błędu (i wtedy użyć &lt;em&gt;checked exception&lt;/em&gt;), czy chcemy wskazać błąd „po cichu” w trakcie wykonywania programu, bez wymuszania obsługi tego błędu (korzystając z &lt;em&gt;unchecked exception&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Trzeba też wziąć pod uwagę, że &lt;em&gt;checked exception&lt;/em&gt; są bardziej problematyczne w użyciu — o tym w następnej sekcji.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Warto pamiętać, że wyjątki to pełnoprawne klasy, które mogą mieć pola i metody. Podstawowe zastosowanie takich metod to udostępnienie poszczególnych szczegółów, które były przyczyną wystąpienia danego wyjątku. Gdy brakuje takich metod, programiści mogliby próbować wyciągnąć te dane, parsując message, co jest złą praktyką — taki message może się zmienić w każdej chwili i nasz kod przestanie działać. Szczególnie jest to ważne w przypadku &lt;em&gt;checked exception&lt;/em&gt;, bo oczekujemy, że użytkownik będzie chciał obsłużyć ten błąd, więc może potrzebować tych szczegółów.&lt;/p&gt;

&lt;h1 id=&quot;dlaczego-checked-exceptions-są-problematyczne-i-lepiej-ich-unikać&quot;&gt;Dlaczego checked exceptions są problematyczne i lepiej ich unikać&lt;/h1&gt;

&lt;p&gt;Jak już sobie powiedzieliśmy, &lt;em&gt;checked exceptions&lt;/em&gt; użyte prawidłowo poprawiają jakość API i programów. W przeciwieństwie do kodów błędów czy &lt;em&gt;unchecked exceptions&lt;/em&gt; zmuszają programistów do obsłużenia możliwych problemów, zwiększając niezawodność programu.&lt;/p&gt;

&lt;p&gt;Z drugiej strony wielu programistów Java nie lubi &lt;em&gt;checked exceptions&lt;/em&gt; ponieważ są nieprzyjemne w użyciu. Nakładają z góry na użytkownika obowiązek obsłużenia danego błędu w jednym lub wielu blokach &lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;, co generuje masę boilerplate-u. Również definicja metody rozciąga się mocno przez deklarowanie wszystkich wyjątków w sekcji &lt;code class=&quot;highlighter-rouge&quot;&gt;throws&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;W Javie 8+ jest jeszcze gorzej, bo w streamach nie można bezpośrednio używać metod, które rzucają &lt;em&gt;checked exceptions&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pisanie prostych programów jest przez to problematyczne, bo nie zawsze chcemy od razu obsługiwać milion casów. Dobrym przykładem są problemy IO, gdy chcemy dostać się do pliku. W prostym programie wysypanie się programu ze stosownym komunikatem byłoby wystarczające, ale nie, w Javie musimy od razu obsłużyć te sytuacje. Ewentualnie powstają twory takie jak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// checked exception throwing method call&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TheCheckedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Can't happen!&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;czy:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// checked exception throwing method call&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TheCheckedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Oh well, we lose.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To obciążenie może być uzasadnione tylko w przypadkach, gdy poprawne użycie API nie załatwi sprawy i użytkownik korzystający z metody rzeczywiście powinien coś z tym zrobić — w przeciwnym wypadku powinniśmy użyć &lt;em&gt;unchecked exception&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Dobrym kompromisem może też być użycie klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; i całkowita rezygnacja z wykorzystania wyjątków, jednak w tym rozwiązaniu nie będziemy mogli udostępnić żadnych szczegółów na temat błędu.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 69, 70, 71 z rozdziału 10: Exceptions Item 69: Use exceptions only for exceptional conditions Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors Item 71: Avoid unnecessary use of checked exceptions Item 72: Favor the use of standard exceptions Item 73: Throw exceptions appropriate to the abstraction Item 74: Document all exceptions thrown by each method Item 75: Include failure-capture information in detail messages Item 76: Strive for failure atomicity Item 77: Don’t ignore exceptions Zaczynamy rozdział 10 po długiej przerwie :) W tym rozdziale będzie mowa o wyjątkach. Wyjątki w Javie są, jakie są, ale ogólnie jest to całkiem użyteczne narzędzie. Gdy są używane prawidłowo, mogą zwiększyć czytelność programu, jego stabilność i utrzymywalność. Z kolei, jeśli będą używane niepoprawnie, uzyskamy dokładnie odwrotny efekt, dlatego warto poświęcić im kilka słów. Wyjątki powinny być używane tylko w wyjątkowych sytuacjach Zresztą sama nazwa na to wskazuje. Niestety nie każdy o tym pamięta i dlatego wyjątki są często nadużywane. Oto przykład: // Horrible abuse of exceptions. Don't ever do this! try { int i = 0; while(true) range[i++].climb(); } catch (ArrayIndexOutOfBoundsException e) { } Co ten kod robi? Nie jest to oczywiste na pierwszy rzut oka, ale jest to po prostu najzwyklejsza iteracja po elementach tablicy. Nieskończona pętla while jest przerywana przez rzucenie wyjątku ArrayIndexOutOfBoundsException, złapanie go, a następnie zignorowanie. Normalny człowiek napisałby to tak: for (Mountain m : range) m.climb(); W poprzednim przykładzie mamy wiele przykładów złych praktyk: użycie wyjątku tam, gdzie jest to zbędne ignorowanie wyjątku wynajdowanie koła na nowo użycie wyjątków do sterowania przepływem programu Poza tym samo umieszczanie kodu w try-catch uniemożliwia niektóre optymalizacje JVM, które bez niego zostałyby zastosowane. Wyjątków nie powinno się używać do sterowania przepływu programu, ponieważ wtedy łatwiej o bugi, które nawet mogą być przez to ukryte, co również utrudnia debugowanie. Wystarczy sobie wyobrazić, że w pętli byłaby wykonywana jakaś inna metoda, która też miałaby możliwość rzucić ArrayIndexOutOfBoundsException z całkiem innej, niepowiązanej tablicy. W takiej sytuacji ten błąd spowodowałby, że pętla zakończyłaby się wcześniej, niż powinna i zostałoby to potraktowane jako prawidłowe zachowanie (wyjątek jest ignorowany, nieważne co go wywołało). Te same zasady dotyczą projektowania API. Dobrze zaprojektowane API nie powinno zmuszać użytkownika, by używał wyjątków do sterowania przepływem programu. Klasa, która ma metodę zależną od stanu, która może być wywołana tylko pod określonymi warunkami, powinna udostępniać metodę sprawdzającą stan i określającą czy użycie metody zależnej od stanu jest odpowiednie. Przykładem może być interfejs Iterator, który ma metodę zależną od stanu next i sprawdzającą stan hasNext. Dzięki temu mamy możliwość użycia go w zwykłych pętlach for: for (Iterator&amp;lt;Foo&amp;gt; i = collection.iterator(); i.hasNext(); ) { Foo foo = i.next(); ... } Jeśli nie byłoby metody hasNext, wtedy bylibyśmy zmuszeni do tego: // Do not use this hideous code for iteration over a collection! try { Iterator&amp;lt;Foo&amp;gt; i = collection.iterator(); while(true) { Foo foo = i.next(); ... } } catch (NoSuchElementException e) { } Co ma wszystkie wady wspomniane wcześniej. Alternatywą dla metod testujących stan jest by metody zależne od stanu zwracały pusty Optional lub inną rozróżnialną wartość jak np. null. Należy to stosować, jeśli obiekt jest używany współbieżnie bez zewnętrznej synchronizacji lub udostępnia zmianę stanu z zewnątrz, ponieważ stan obiektu mógłby być zmieniony pomiędzy wywołaniami metody sprawdzającej, a tej zależnej od stanu. Obawy o wydajność mogłyby dyktować użycie klasy Optional czy innej rozróżnialnej wartości, gdy metoda testująca duplikowałaby pracę metody zależnej od stanu, jednak ze wpisów o optymalizacji wiemy, że w większości wypadków nie powinniśmy się martwić o takie mikro optymalizacje. Metoda testująca stan oferuje lepszą czytelność i nieprawidłowe użycie jest łatwiejsze do wykrycia — jeśli zapomnimy wywołać metodę testującą, to metoda zależna od stanu rzuci wyjątek i błąd będzie oczywisty. Jeśli zapomnimy sprawdzić rozróżnialną wartość, która oznacza błąd, wtedy błąd może być trudniejszy do wychwycenia. Oczywiście nie dotyczy to użycia Optional, ponieważ jest jasne, że metoda może nie zwrócić danej wartości i należy sprawdzić, czy istnieje. Kiedyś ta zasada miała dużo większe znaczenie, bo miała znaczny wpływ na wydajność. Obecnie w większości przypadków powinniśmy się kierować przejrzystością i prostotą kodu. Warto zerknąć na link I’ve been told that Exceptions should only be used in exceptional cases. How do I know if my case is exceptional? A szczególnie na odpowiedź: Exceptions were invented to help make error handling easier with less code clutter. You should use them in cases when they make error handling easier with less code clutter. This “exceptions only for exceptional circumstances” business stems from a time when exception handling was deemed an unacceptable performance hit. That’s no longer the case in the vast majority of code, but people still spout the rule without remembering the reason behind it. Especially in Java, which is maybe the most exception-loving language ever conceived, you shouldn’t feel bad about using exceptions when it simplifies your code. Warto również rzucić okiem na Java Pitfalls - Exception usage, gdzie znajdziemy przykłady problemów związanych z obsługą wyjątków. Rodzaje wyjątków i kiedy jakie używać W Javie mamy trzy rodzaje wyjątków: checked exceptions, runtime exceptions i errors. Dwa ostatnie należą do grupy unchecked exceptions. Różnica pomiędzy nimi jest taka, że używając checked exceptions w metodzie, musimy go zadeklarować w sekcji throws i zmuszamy użytkownika tej metody, by obsłużył dany wyjątek używając try catch lub aby podał go do obsługi wyżej deklarując ten wyjątek w sekcji throws. Z kolei unchecked exceptions są bardziej elastyczne w użyciu i nie ma przymusu ich obsługi czy deklarowania w sekcji throws. Decyzja, kiedy jaki rodzaj wyjątku użyć nie jest zawsze jednoznaczna, ale są ogólnie akceptowalne reguły i wskazówki, którymi powinniśmy się kierować. W Javie jest silne akceptowalna konwencja, że errors są zarezerwowane do użycia przez JVM i najlepiej nie implementować żadnych nowych podklas klasy Error jak również nigdy nie rzucać tych już istniejących, z wyjątkiem AssertionError. Implementując unchecked exception powinniśmy rozszerzać klasę RuntimeException. Więc kiedy używać checked exceptions, a kiedy unchecked exceptions? Najczęściej spotkamy się z zasadą, że checked exceptions powinny być używane w sytuacjach, gdy wiemy, że użytkownik ma szansę wyjść z tego błędu cało. Jeśli metoda rzuca unchecked exception to zazwyczaj oznacza, że nie może kontynuować wykonywania operacji, bo zakończyłoby się to niepowodzeniem i wyrządziłoby to więcej szkód niż dobra. Najczęstszym przypadkiem w tej sytuacji jest złe użycie API przez użytkownika, który nie dotrzymał wymagań specyfikacji API. Dla przykładu aby dostać się do wartości tablicy, specyfikacja mówi, że index musi być pomiędzy 0, a długością tablicy odjąć 1. Jeśli popełnimy błąd i podamy niepoprawny index to dostaniemy ArrayIndexOutOfBoundsException. Unchecked exceptions są zatem najczęściej używane, by wskazać błąd programistyczny, z którego nie można już łatwo wyjść. Jak sam autor zauważa w książce, niestety nie zawsze jest jasne, kiedy mamy do czynienia z „recoverable condition”, a kiedy z „programming error”. Musimy więc kierować się własnym przeczuciem i stwierdzić czy dany błąd ma być „z góry” widoczny dla użytkownika i wymusić na nim obsługę tego błędu (i wtedy użyć checked exception), czy chcemy wskazać błąd „po cichu” w trakcie wykonywania programu, bez wymuszania obsługi tego błędu (korzystając z unchecked exception). Trzeba też wziąć pod uwagę, że checked exception są bardziej problematyczne w użyciu — o tym w następnej sekcji. Warto pamiętać, że wyjątki to pełnoprawne klasy, które mogą mieć pola i metody. Podstawowe zastosowanie takich metod to udostępnienie poszczególnych szczegółów, które były przyczyną wystąpienia danego wyjątku. Gdy brakuje takich metod, programiści mogliby próbować wyciągnąć te dane, parsując message, co jest złą praktyką — taki message może się zmienić w każdej chwili i nasz kod przestanie działać. Szczególnie jest to ważne w przypadku checked exception, bo oczekujemy, że użytkownik będzie chciał obsłużyć ten błąd, więc może potrzebować tych szczegółów. Dlaczego checked exceptions są problematyczne i lepiej ich unikać Jak już sobie powiedzieliśmy, checked exceptions użyte prawidłowo poprawiają jakość API i programów. W przeciwieństwie do kodów błędów czy unchecked exceptions zmuszają programistów do obsłużenia możliwych problemów, zwiększając niezawodność programu. Z drugiej strony wielu programistów Java nie lubi checked exceptions ponieważ są nieprzyjemne w użyciu. Nakładają z góry na użytkownika obowiązek obsłużenia danego błędu w jednym lub wielu blokach catch, co generuje masę boilerplate-u. Również definicja metody rozciąga się mocno przez deklarowanie wszystkich wyjątków w sekcji throws. W Javie 8+ jest jeszcze gorzej, bo w streamach nie można bezpośrednio używać metod, które rzucają checked exceptions. Pisanie prostych programów jest przez to problematyczne, bo nie zawsze chcemy od razu obsługiwać milion casów. Dobrym przykładem są problemy IO, gdy chcemy dostać się do pliku. W prostym programie wysypanie się programu ze stosownym komunikatem byłoby wystarczające, ale nie, w Javie musimy od razu obsłużyć te sytuacje. Ewentualnie powstają twory takie jak: try { // checked exception throwing method call } catch (TheCheckedException e) { throw new AssertionError(); // Can't happen! } czy: try { // checked exception throwing method call } catch (TheCheckedException e) { e.printStackTrace(); // Oh well, we lose. System.exit(1); } To obciążenie może być uzasadnione tylko w przypadkach, gdy poprawne użycie API nie załatwi sprawy i użytkownik korzystający z metody rzeczywiście powinien coś z tym zrobić — w przeciwnym wypadku powinniśmy użyć unchecked exception. Dobrym kompromisem może też być użycie klasy Optional i całkowita rezygnacja z wykorzystania wyjątków, jednak w tym rozwiązaniu nie będziemy mogli udostępnić żadnych szczegółów na temat błędu.</summary></entry><entry><title type="html">Konferencja SegFault Kraków 2019</title><link href="https://devcave.pl/konferencje/segfault-krakow-2019" rel="alternate" type="text/html" title="Konferencja SegFault Kraków 2019" /><published>2019-11-07T09:00:00+01:00</published><updated>2019-11-07T09:00:00+01:00</updated><id>https://devcave.pl/konferencje/segfault-krakow-2019</id><content type="html" xml:base="https://devcave.pl/konferencje/segfault-krakow-2019">&lt;p&gt;&lt;img src=&quot;/img/konferencje/SegFault Unconference event.jpg&quot; alt=&quot;Grafika SegFault Warszawa 2019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tak jak wspominałem wcześniej, szykuje się dwudniowa, krakowska edycja konferencji SegFault. Odbędzie się &lt;strong&gt;25 i 26 listopada&lt;/strong&gt;. Na nią też się wybieram i również Was zapraszam :slightly_smiling_face:. Jak zawsze - mam dla Was &lt;strong&gt;kod rabatowy&lt;/strong&gt; oraz &lt;strong&gt;1 darmową wejściówkę&lt;/strong&gt;. Info o nich znajdziesz na &lt;a href=&quot;#kod-rabatowy--wejściówka&quot;&gt;końcu tego posta&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tymczasem sprawdźcie czym jest &lt;strong&gt;SegFault Unconference&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&quot;opis-konferencji&quot;&gt;Opis konferencji:&lt;/h1&gt;

&lt;p&gt;Konferencyjna marka SegFault znów zaskakuje! &lt;strong&gt;25 i 26 listopada&lt;/strong&gt;, w &lt;strong&gt;Krakowie&lt;/strong&gt;, poznacie jej najnowszą odsłonę - &lt;strong&gt;SegFault Unconference&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;W kalendarzu konferencji IT SegFault Unconference zajęło miejsce CoreDump. Nowa formuła to przede wszystkim inspiracje, których szukacie.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pierwszy dzień&lt;/strong&gt; wydarzenia to formuła Unconference, czyli wymiana doświadczeń oraz najlepsi prelegenci - cali dla Was. To Wy wybieracie tematy!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Drugi dzień&lt;/strong&gt; to prelekcje, które będą odpowiedziami na nurtujące Was pytania. Przed Wami mnóstwo inspiracji i podpowiedzi nietypowych rozwiązań, na które czekacie.&lt;/p&gt;

&lt;p&gt;SegFault Unconference to także &lt;strong&gt;Aftreparty&lt;/strong&gt;, czyli okazja do osobistego spotkania z prelegentami i innymi uczestnikami eventu.&lt;/p&gt;

&lt;p&gt;Tematyka SegFault Unconference sięga nie tylko do języków programowania, systemów rozproszonych, ale także do narzędzi (automatyzacji, kontenerów), jak i umiejętności miękkich.&lt;/p&gt;

&lt;p&gt;Rzućcie okiem na &lt;a href=&quot;https://segfault.events/krakow2019/#schedule&quot;&gt;agendę&lt;/a&gt; :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;SegFault Unconference - tego Wam brakowało na rynku konferencji IT!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Więcej informacji: &lt;a href=&quot;https://segfault.events/krakow2019/&quot;&gt;segfault.events/krakow2019/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Facebook: &lt;a href=&quot;https://www.facebook.com/SegFaultConf/&quot;&gt;facebook.com/SegFaultConf/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Twitter: &lt;a href=&quot;https://twitter.com/SegFaultConf&quot;&gt;twitter.com/SegFaultConf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;YouTube: &lt;a href=&quot;https://www.youtube.com/Konferencje%20SegFault&quot;&gt;youtube.com/Konferencje SegFault&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kod-rabatowy--wejściówka&quot;&gt;Kod rabatowy + wejściówka&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Darmowa wejściówka jest tylko dla jednej osoby&lt;/strong&gt; - kto chętny to zapraszam do &lt;a href=&quot;/kontakt&quot;&gt;kontaktu&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Jeśli masz konto na LinkedIn, to mnie po prostu &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;dodaj&lt;/a&gt; i pogadamy bezpośrednio tam.&lt;/p&gt;

&lt;p&gt;Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę &lt;a href=&quot;/o-mnie&quot;&gt;o mnie&lt;/a&gt; i na mój &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Status wejściówki: &lt;code class=&quot;highlighter-rouge&quot;&gt;ODEBRANA&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Jeśli nie udało Ci się zgarnąć darmowej wejściówki to możesz skorzystać z kodu rabatowego &lt;strong&gt;10%&lt;/strong&gt; :slightly_smiling_face:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;KRK_DEVCAVE_10&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Codeboy</name></author><category term="Konferencje" /><category term="Konferencje" /><summary type="html">Tak jak wspominałem wcześniej, szykuje się dwudniowa, krakowska edycja konferencji SegFault. Odbędzie się 25 i 26 listopada. Na nią też się wybieram i również Was zapraszam :slightly_smiling_face:. Jak zawsze - mam dla Was kod rabatowy oraz 1 darmową wejściówkę. Info o nich znajdziesz na końcu tego posta. Tymczasem sprawdźcie czym jest SegFault Unconference. Opis konferencji: Konferencyjna marka SegFault znów zaskakuje! 25 i 26 listopada, w Krakowie, poznacie jej najnowszą odsłonę - SegFault Unconference. W kalendarzu konferencji IT SegFault Unconference zajęło miejsce CoreDump. Nowa formuła to przede wszystkim inspiracje, których szukacie. Pierwszy dzień wydarzenia to formuła Unconference, czyli wymiana doświadczeń oraz najlepsi prelegenci - cali dla Was. To Wy wybieracie tematy! Drugi dzień to prelekcje, które będą odpowiedziami na nurtujące Was pytania. Przed Wami mnóstwo inspiracji i podpowiedzi nietypowych rozwiązań, na które czekacie. SegFault Unconference to także Aftreparty, czyli okazja do osobistego spotkania z prelegentami i innymi uczestnikami eventu. Tematyka SegFault Unconference sięga nie tylko do języków programowania, systemów rozproszonych, ale także do narzędzi (automatyzacji, kontenerów), jak i umiejętności miękkich. Rzućcie okiem na agendę :slightly_smiling_face: SegFault Unconference - tego Wam brakowało na rynku konferencji IT! Więcej informacji: segfault.events/krakow2019/ Facebook: facebook.com/SegFaultConf/ Twitter: twitter.com/SegFaultConf YouTube: youtube.com/Konferencje SegFault Kod rabatowy + wejściówka Darmowa wejściówka jest tylko dla jednej osoby - kto chętny to zapraszam do kontaktu. Jeśli masz konto na LinkedIn, to mnie po prostu dodaj i pogadamy bezpośrednio tam. Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę o mnie i na mój LinkedIn. Status wejściówki: ODEBRANA Jeśli nie udało Ci się zgarnąć darmowej wejściówki to możesz skorzystać z kodu rabatowego 10% :slightly_smiling_face: KRK_DEVCAVE_10</summary></entry><entry><title type="html">Konferencja SegFault Warszawa 2019</title><link href="https://devcave.pl/konferencje/segfault-warszawa-2019" rel="alternate" type="text/html" title="Konferencja SegFault Warszawa 2019" /><published>2019-09-25T10:00:00+02:00</published><updated>2019-09-25T10:00:00+02:00</updated><id>https://devcave.pl/konferencje/segfault-warszawa-2019</id><content type="html" xml:base="https://devcave.pl/konferencje/segfault-warszawa-2019">&lt;p&gt;&lt;img src=&quot;/img/konferencje/SegFault Warszawa 2019.png&quot; alt=&quot;Grafika SegFault Warszawa 2019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zostałem partnerem medialnym konferencji SegFault i tak jak zapowiadałem, mam dla was &lt;strong&gt;darmową wejściówkę&lt;/strong&gt; oraz &lt;strong&gt;kod rabatowy&lt;/strong&gt; na w sumie 2 konferencje, ale po kolei, na razie pierwsza, jednodniowa, która odbędzie się w Warszawie :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;Pod koniec listopada będzie &lt;a href=&quot;https://segfault.events/krakow2019/&quot;&gt;dwudniowa edycja krakowska&lt;/a&gt;, o innej tematyce, na którą też się wybieram, więc bądźcie na bieżąco, wejściówka czeka :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;Tymczasem zobaczcie czy Was zainteresuje tematyką edycja warszawska.&lt;/p&gt;

&lt;h2 id=&quot;opis-konferencji&quot;&gt;Opis konferencji:&lt;/h2&gt;

&lt;p&gt;SegFault po raz pierwszy w Warszawie! Już &lt;strong&gt;27 września&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Warszawska edycja SegFault to przede wszystkim tematyka związana z &lt;strong&gt;Data Engineering&lt;/strong&gt; i &lt;strong&gt;Applied ML / AI&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Wszyscy mówią dziś o mocy i możliwościach Big Data, Machine Learning i Sztucznej Inteligencji? W SegFault idziemy krok dalej - nie teoretyzujemy, lecz pokazujemy jak wdrożyć tego typu rozwiązania w konkretne projekty.&lt;/p&gt;

&lt;p&gt;Zastanawiacie się jak wykorzystać ML lub AI w Waszych projektach? Warszawska edycja SegFault jest właśnie dla Was! Przygotujcie się na sporą dawkę praktycznych zastosowań. Zero “Hello World” bez pokrycia.&lt;/p&gt;

&lt;p&gt;SegFault Warszawa 2019 - świetne nazwiska, doskonale skomponowana agenda. Merytorycznie i na temat.&lt;/p&gt;

&lt;p&gt;Rzućcie okiem na &lt;a href=&quot;https://segfault.events/warszawa2019/#schedule&quot;&gt;agendę&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Więcej informacji: &lt;a href=&quot;https://segfault.events/warszawa2019/&quot;&gt;segfault.events/warszawa2019&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Facebook: &lt;a href=&quot;https://www.facebook.com/SegFaultConf/&quot;&gt;facebook.com/SegFaultConf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Twitter: &lt;a href=&quot;https://twitter.com/SegFaultConf&quot;&gt;twitter.com/SegFaultConf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;YouTube: &lt;a href=&quot;https://www.youtube.com/Konferencje%20SegFault&quot;&gt;youtube.com/Konferencje SegFault&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kod-rabatowy--wejściówka&quot;&gt;Kod rabatowy + wejściówka&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Darmowa wejściówka jest tylko dla jednej osoby&lt;/strong&gt; - kto chętny to zapraszam do &lt;a href=&quot;/kontakt&quot;&gt;kontaktu&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Jeśli masz konto na LinkedIn, to mnie po prostu &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;dodaj&lt;/a&gt; i pogadamy bezpośrednio tam.&lt;/p&gt;

&lt;p&gt;Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę &lt;a href=&quot;/o-mnie&quot;&gt;o mnie&lt;/a&gt; i na mój &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Status wejściówki: &lt;code class=&quot;highlighter-rouge&quot;&gt;ODEBRANA&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Jeśli nie udało Ci się zgarnąć darmowej wejściówki to możesz skorzystać z kodu rabatowego &lt;strong&gt;10%&lt;/strong&gt; :slightly_smiling_face:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;WAE_DEVCAVE_10&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Codeboy</name></author><category term="Konferencje" /><category term="Konferencje" /><summary type="html">Zostałem partnerem medialnym konferencji SegFault i tak jak zapowiadałem, mam dla was darmową wejściówkę oraz kod rabatowy na w sumie 2 konferencje, ale po kolei, na razie pierwsza, jednodniowa, która odbędzie się w Warszawie :slightly_smiling_face: Pod koniec listopada będzie dwudniowa edycja krakowska, o innej tematyce, na którą też się wybieram, więc bądźcie na bieżąco, wejściówka czeka :slightly_smiling_face: Tymczasem zobaczcie czy Was zainteresuje tematyką edycja warszawska. Opis konferencji: SegFault po raz pierwszy w Warszawie! Już 27 września! Warszawska edycja SegFault to przede wszystkim tematyka związana z Data Engineering i Applied ML / AI. Wszyscy mówią dziś o mocy i możliwościach Big Data, Machine Learning i Sztucznej Inteligencji? W SegFault idziemy krok dalej - nie teoretyzujemy, lecz pokazujemy jak wdrożyć tego typu rozwiązania w konkretne projekty. Zastanawiacie się jak wykorzystać ML lub AI w Waszych projektach? Warszawska edycja SegFault jest właśnie dla Was! Przygotujcie się na sporą dawkę praktycznych zastosowań. Zero “Hello World” bez pokrycia. SegFault Warszawa 2019 - świetne nazwiska, doskonale skomponowana agenda. Merytorycznie i na temat. Rzućcie okiem na agendę. Więcej informacji: segfault.events/warszawa2019 Facebook: facebook.com/SegFaultConf Twitter: twitter.com/SegFaultConf YouTube: youtube.com/Konferencje SegFault Kod rabatowy + wejściówka Darmowa wejściówka jest tylko dla jednej osoby - kto chętny to zapraszam do kontaktu. Jeśli masz konto na LinkedIn, to mnie po prostu dodaj i pogadamy bezpośrednio tam. Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę o mnie i na mój LinkedIn. Status wejściówki: ODEBRANA Jeśli nie udało Ci się zgarnąć darmowej wejściówki to możesz skorzystać z kodu rabatowego 10% :slightly_smiling_face: WAE_DEVCAVE_10</summary></entry><entry><title type="html">Konferencja JDD Kraków 2019</title><link href="https://devcave.pl/konferencje/jdd-krakow-2019" rel="alternate" type="text/html" title="Konferencja JDD Kraków 2019" /><published>2019-09-21T09:00:00+02:00</published><updated>2019-09-21T09:00:00+02:00</updated><id>https://devcave.pl/konferencje/jdd-krakow-2019</id><content type="html" xml:base="https://devcave.pl/konferencje/jdd-krakow-2019">&lt;p&gt;&lt;img src=&quot;/img/konferencje/JDD Kraków 2019.png&quot; alt=&quot;Grafika JDD Kraków 2019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wreszcie coś nowego dla Was z mojej strony :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;Zostałem partnerem medialnym konferencji JDD, na którą również się wybieram i tak jak zapowiadałem, mam dla was &lt;strong&gt;kod rabatowy&lt;/strong&gt; oraz &lt;strong&gt;1 darmową wejściówkę&lt;/strong&gt;. Info o nich znajdziesz na &lt;a href=&quot;#kod-rabatowy--wejściówka&quot;&gt;końcu tego posta&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;opis-konferencji-jdd&quot;&gt;Opis konferencji JDD:&lt;/h2&gt;

&lt;p&gt;Zbliża się jedna z największych konferencji o tematyce Java w Polsce – różnorodność to domena tegorocznej edycji JDD!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/konferencje/JDD 1.jpg&quot; alt=&quot;JDD 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zapowiada się kolejne, wielkie zgrupowanie fanatyków programowania w Javie. Prelegenci z różnych stron świata, doświadczeni profesjonaliści, reprezentanci różnorodnych społeczności ze świata IT, pełni zapału studenci oraz deweloperzy na przeróżnych stopniach zaawansowania – wszyscy, który kochają Javę będą tam!&lt;/p&gt;

&lt;p&gt;W tym roku JDD odbędzie się &lt;strong&gt;14-15 października 2019&lt;/strong&gt;, jak zawsze, &lt;strong&gt;w Krakowie&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Organizatorzy stawiają na różnorodność.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/konferencje/JDD 2.jpg&quot; alt=&quot;JDD 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ścieżki podzielone ze względu na poziom zaawansowania i język prezentacji, inspirujące wykłady oraz nowe twarze na scenie – na to możemy się nastawiać, myśląc o JDD 2019.&lt;/p&gt;

&lt;p&gt;Organizatorzy planują ścieżkę technologiczną oraz szereg zróżnicowanych tematów: front-end, Metodologie DevOps, JAVA 9/10/11, testing, dobre praktyki, soft skills, Machine Learning, AI, Mobile, Chatbots, Blockchain, Reactive, Functional Programming, Databases, Big Data, NoSQL, Industry 4.0 /ERP/ Erp in cloud.&lt;/p&gt;

&lt;p&gt;Czego możemy się spodziewać po XIV edycji legendarnej konferencji Java?&lt;/p&gt;

&lt;p&gt;Przygotujcie się na:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;najnowsze trendy, najbardziej efektywne rozwiązania i liczne case studies&lt;/li&gt;
  &lt;li&gt;praktyczne przykłady, sesje live coding&lt;/li&gt;
  &lt;li&gt;jeszcze więcej specjalistów i ekspertów&lt;/li&gt;
  &lt;li&gt;tematy dla wszystkich: junior, mid i senior deweloperów&lt;/li&gt;
  &lt;li&gt;agendę opartą m.in. na zgłoszeniach CFP oraz propozycjach, które uczestnicy podawali w zeszłorocznych ankietach&lt;/li&gt;
  &lt;li&gt;warsztaty, żywe i wciągające panele dyskusyjne, beer-talks&lt;/li&gt;
  &lt;li&gt;spotkanie ze społecznościami Java z całej Polski&lt;/li&gt;
  &lt;li&gt;ogromny entuzjazm i niezapomniana, luźna atmosfera (wszystko dzięki niezwykłym uczestnikom konferencji i AfterParty!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;W Radzie Programowej zasiadają:
Sławomir Sobótka, Andrzej Grzesik, Wojciech Oczkowski, 
Marcin Świerczyński, Magda Stożek, Damian Leszczyński, Łukasz Dziedziul, 
Michał Gruca, JakubPilimon, Grzegorz Piwowarek, Marcin Zajączkowski, Jarek Pałka&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/konferencje/JDD 3.jpg&quot; alt=&quot;JDD 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kolejna edycja konkursu JUGmajster&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;W tym roku również, tradycyjnie, odbędzie się konkurs JUGmajster! To kultowy element JDD - debiutujący specjaliści Java konkurują ze sobą na scenie. Tylko jeden z nich powali widownię na łopatki i zostanie okrzyknięty JUGmajstrem 2019. Podczas zeszłorocznej edycji rywalizacja okazała się niezwykle zacięta - „Chcemy, by ta edycja konkursu odznaczała się jeszcze większymi emocjami i wyższym poziomem rywalizacji”, twierdzą organizatorzy. Konkurs JUGmajster to ogromna dawka praktycznej wiedzy i najnowsze rozwiązania prosto od debiutantów, walczących ze sobą o miano wschodzącej gwiazdy polskiej sceny IT.&lt;/p&gt;

&lt;p&gt;Więcej informacji o konferencji na stronie: &lt;a href=&quot;https://jdd.org.pl&quot;&gt;jdd.org.pl&lt;/a&gt; oraz na Facebooku i Twitterze.&lt;/p&gt;

&lt;h1 id=&quot;kod-rabatowy--wejściówka&quot;&gt;Kod rabatowy + wejściówka&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Darmowa wejściówka jest tylko dla jednej osoby&lt;/strong&gt; - kto chętny to zapraszam do &lt;a href=&quot;/kontakt&quot;&gt;kontaktu&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Jeśli masz konto na LinkedIn, to mnie po prostu &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;dodaj&lt;/a&gt; i pogadamy bezpośrednio tam.&lt;/p&gt;

&lt;p&gt;Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę &lt;a href=&quot;/o-mnie&quot;&gt;o mnie&lt;/a&gt; i na mój &lt;a href=&quot;https://www.linkedin.com/in/marcin-lasota/&quot;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Status wejściówki: &lt;code class=&quot;highlighter-rouge&quot;&gt;ODEBRANA&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Wejściówkę odebrał Sebastian, a zdecydował o tym fakt, że był po prostu pierwszy :slightly_smiling_face:
Wszystko rozegrało się na slacku devspl.slack.com, oto dowód :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/konferencje/jdd-odebranie.jpg&quot; alt=&quot;JDD rozmowa odebranie wejściówki&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;Niestety wejściówka została już odebrana, ale zachęcam do śledzenia bloga, wkrótce pojawią się 2 kolejne posty z wejściówkami na konferencję SegFault.&lt;/p&gt;

&lt;p&gt;Jeśli nie udało Ci się dostać darmowej wejściówki to możesz skorzystać z kodu rabatowego &lt;strong&gt;15%&lt;/strong&gt; :slightly_smiling_face:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;DEVCAVE_15&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zostałem też partnerem medialnym innej konferencji, na które również będę miał wejściówki, więc będziesz jeszcze miał co najmniej 2 szanse na inne konferencje :slightly_smiling_face:&lt;/p&gt;

&lt;p&gt;Bądźcie na bieżąco, info o następnej konferencji będzie prawdopodobnie za tydzień :wink:&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Konferencje" /><category term="Konferencje" /><summary type="html">Wreszcie coś nowego dla Was z mojej strony :slightly_smiling_face: Zostałem partnerem medialnym konferencji JDD, na którą również się wybieram i tak jak zapowiadałem, mam dla was kod rabatowy oraz 1 darmową wejściówkę. Info o nich znajdziesz na końcu tego posta. Opis konferencji JDD: Zbliża się jedna z największych konferencji o tematyce Java w Polsce – różnorodność to domena tegorocznej edycji JDD! Zapowiada się kolejne, wielkie zgrupowanie fanatyków programowania w Javie. Prelegenci z różnych stron świata, doświadczeni profesjonaliści, reprezentanci różnorodnych społeczności ze świata IT, pełni zapału studenci oraz deweloperzy na przeróżnych stopniach zaawansowania – wszyscy, który kochają Javę będą tam! W tym roku JDD odbędzie się 14-15 października 2019, jak zawsze, w Krakowie! Organizatorzy stawiają na różnorodność. Ścieżki podzielone ze względu na poziom zaawansowania i język prezentacji, inspirujące wykłady oraz nowe twarze na scenie – na to możemy się nastawiać, myśląc o JDD 2019. Organizatorzy planują ścieżkę technologiczną oraz szereg zróżnicowanych tematów: front-end, Metodologie DevOps, JAVA 9/10/11, testing, dobre praktyki, soft skills, Machine Learning, AI, Mobile, Chatbots, Blockchain, Reactive, Functional Programming, Databases, Big Data, NoSQL, Industry 4.0 /ERP/ Erp in cloud. Czego możemy się spodziewać po XIV edycji legendarnej konferencji Java? Przygotujcie się na: najnowsze trendy, najbardziej efektywne rozwiązania i liczne case studies praktyczne przykłady, sesje live coding jeszcze więcej specjalistów i ekspertów tematy dla wszystkich: junior, mid i senior deweloperów agendę opartą m.in. na zgłoszeniach CFP oraz propozycjach, które uczestnicy podawali w zeszłorocznych ankietach warsztaty, żywe i wciągające panele dyskusyjne, beer-talks spotkanie ze społecznościami Java z całej Polski ogromny entuzjazm i niezapomniana, luźna atmosfera (wszystko dzięki niezwykłym uczestnikom konferencji i AfterParty!) W Radzie Programowej zasiadają: Sławomir Sobótka, Andrzej Grzesik, Wojciech Oczkowski, Marcin Świerczyński, Magda Stożek, Damian Leszczyński, Łukasz Dziedziul, Michał Gruca, JakubPilimon, Grzegorz Piwowarek, Marcin Zajączkowski, Jarek Pałka Kolejna edycja konkursu JUGmajster W tym roku również, tradycyjnie, odbędzie się konkurs JUGmajster! To kultowy element JDD - debiutujący specjaliści Java konkurują ze sobą na scenie. Tylko jeden z nich powali widownię na łopatki i zostanie okrzyknięty JUGmajstrem 2019. Podczas zeszłorocznej edycji rywalizacja okazała się niezwykle zacięta - „Chcemy, by ta edycja konkursu odznaczała się jeszcze większymi emocjami i wyższym poziomem rywalizacji”, twierdzą organizatorzy. Konkurs JUGmajster to ogromna dawka praktycznej wiedzy i najnowsze rozwiązania prosto od debiutantów, walczących ze sobą o miano wschodzącej gwiazdy polskiej sceny IT. Więcej informacji o konferencji na stronie: jdd.org.pl oraz na Facebooku i Twitterze. Kod rabatowy + wejściówka Darmowa wejściówka jest tylko dla jednej osoby - kto chętny to zapraszam do kontaktu. Jeśli masz konto na LinkedIn, to mnie po prostu dodaj i pogadamy bezpośrednio tam. Jeśli chciałbyś się dowiedzieć czegoś o mnie to zajrzyj na stronę o mnie i na mój LinkedIn. Status wejściówki: ODEBRANA Wejściówkę odebrał Sebastian, a zdecydował o tym fakt, że był po prostu pierwszy :slightly_smiling_face: Wszystko rozegrało się na slacku devspl.slack.com, oto dowód :slightly_smiling_face: Niestety wejściówka została już odebrana, ale zachęcam do śledzenia bloga, wkrótce pojawią się 2 kolejne posty z wejściówkami na konferencję SegFault. Jeśli nie udało Ci się dostać darmowej wejściówki to możesz skorzystać z kodu rabatowego 15% :slightly_smiling_face: DEVCAVE_15 Zostałem też partnerem medialnym innej konferencji, na które również będę miał wejściówki, więc będziesz jeszcze miał co najmniej 2 szanse na inne konferencje :slightly_smiling_face: Bądźcie na bieżąco, info o następnej konferencji będzie prawdopodobnie za tydzień :wink:</summary></entry><entry><title type="html">Optymalizowanie kodu</title><link href="https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze" rel="alternate" type="text/html" title="Optymalizowanie kodu" /><published>2019-03-16T09:00:00+01:00</published><updated>2019-03-16T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze</id><content type="html" xml:base="https://devcave.pl/effective-java/optymalizacja-i-konwencje-nazewnicze">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 67, 68&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 57: Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 58: Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 59: Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 60: Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 61: Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 62: Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 63: Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 64: Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 65: Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 66: Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 67: Optimize judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 68: Adhere to generally accepted naming conventions
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;optymalizacja---robić-czy-nie&quot;&gt;Optymalizacja - robić czy nie?&lt;/h1&gt;

&lt;p&gt;Są co najmniej 3 znane cytaty odnośnie optymalizacji:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.&lt;br /&gt;
—William A. Wulf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.&lt;br /&gt;
—Donald E. Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We follow two rules in the matter of optimization:
Rule 1. Don’t do it.&lt;br /&gt;
Rule 2 (for experts only). Don’t do it yet—that is, not until you have a perfectly clear and unoptimized solution.&lt;br /&gt;
—M. A. Jackson&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wszystkie 3 cytaty poprzedzają język programowania Java o co najmniej dwie dekady, jednak nadal są aktualne i mówią świętą prawdę o optymalizacji — łatwiej jest nią narobić więcej szkód niż dobra, szczególnie jeśli mowa o przedwczesnej optymalizacji.&lt;/p&gt;

&lt;p&gt;Nie warto poświęcać dobrego designu na rzecz wydajności – lepiej jest pisać dobre programy niż szybkie. Jeśli dobry program nie jest wystarczająco wydajny, jego architektura pozwoli go później zoptymalizować. Dobre programy przestrzegają zasady enkapsulacji danych, więc pojedyncze decyzje mogą być zmienione bez wpływu na pozostałą część systemu.&lt;/p&gt;

&lt;p&gt;Nie znaczy to też, że powinniśmy ignorować problemy wydajnościowe, dopóki nie skończymy programu. Problemy implementacyjne mogą być naprawione późniejszą optymalizacją, ale wszechobecne wady architektury ograniczające wydajność mogą nie być możliwe do naprawy bez przepisywania całego systemu od nowa.&lt;/p&gt;

&lt;p&gt;Najtrudniej wprowadzić zamianę w komponentach, które zawierają interakcje pomiędzy komponentami a światem zewnętrznym np. API czy formaty przesyłania danych. Mogą też narzucić znaczne ograniczenia wydajności, dlatego te części systemy trzeba zaprojektować z największą starannością.&lt;/p&gt;

&lt;p&gt;Więc nie możemy całkiem przestać myśleć o optymalizacji. Zawsze trzeba rozważać konsekwencje naszych wyborów, np. tworząc typ mutowalny, możemy wymuszać na kliencie wiele zbędnych kopii defensywnych. Podobnie, używając dziedziczenia w publicznej klasie zamiast kompozycji, zszywamy daną klasę z nadklasa na zawsze, co może skutkować ograniczeniami podklasy. Tak samo używając w API typu implementacji zamiast interfejsu, wymuszamy tylko jedną konkretną implementację, mimo to, że w przyszłości mogłaby być napisana bardziej wydajna wersja. Jeśli system jest używany tylko wewnętrznie i możemy całkowicie przebudowywać kod, to nie ma to aż takiego znaczenia, ale po co sobie utrudniać życie?&lt;/p&gt;

&lt;p&gt;Na szczęście zazwyczaj dobry design idzie w parze z dobrą wydajnością lub z łatwą możliwością na jej poprawę. Kiedy zaprojektowaliśmy czysty i dobrze ustrukturyzowany kod, to wtedy może być czas na rozważanie optymalizacji, która w dobrze zaprojektowanym systemie jest łatwa do wprowadzenia. Nigdy nie powinniśmy skupiać się na optymalizacji kosztem spaczonego designu.&lt;/p&gt;

&lt;p&gt;W określeniu, gdzie powinniśmy skupić naszą uwagę podczas optymalizowania systemu, mogą nam pomóc profilery. Te narzędzia dają nam takie informacje jak np. czas, w jakim każda metoda się wykonuje i jak wiele razy to miało miejsce. Innym narzędziem, o którym warto wspomnieć, jest framework do benchmarków &lt;a href=&quot;https://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, którym możemy zmierzyć wydajność poszczególnych kawałków kodu. Warto skorzystać z tego narzędzia, aby porównać zoptymalizowany kod, czy aby na pewno wydajność jest lepsza, czy tylko nam się tak wydaje.&lt;/p&gt;

&lt;h1 id=&quot;konwencje-nazewnicze-w-javie&quot;&gt;Konwencje nazewnicze w Javie&lt;/h1&gt;

&lt;p&gt;Ten temat jest dosyć rozwlekle opisany w książce, jednak myślę, że tu nie ma co się rozdrabniać - podam same konkrety.&lt;/p&gt;

&lt;p&gt;W Javie (jak i w każdym innym języku) mamy powszechnie uznawane konwencje nazewnicze, których należy się trzymać.&lt;/p&gt;

&lt;p&gt;Można powiedzieć, że dzielą się na dwie grupy — typograficzne i gramatyczne.&lt;/p&gt;

&lt;p&gt;Nazwy pakietów i modułów powinny być zwięzłe i składać się wyłącznie z małych liter. Zalecane też są opisowe skróty np. &lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;utilities&lt;/code&gt; lub akronimy. Nazwa pakietu, który będzie używany poza naszą organizacją, powinna zaczynać się od odwróconej nazwy domeny np. &lt;code class=&quot;highlighter-rouge&quot;&gt;com.google&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Klasy i interfejsy włączając w to enumy i adnotacje powinny zaczynać się wielką literą i dalej CamelCase. Często dyskusji podlega problem, czy akronimy powinny być całe pisane wielkimi literami, czy nie. Według mnie nie — tylko pierwsza litera powinna być pisana z dużej, szczególnie gdy mamy w nazwie dwa akronimy. Wolałbyś widzieć klasę nazwaną &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTPURL&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;HttpUrl&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Metody i pola obowiązują te same zasady tyle, że zaczynamy małą literą.&lt;/p&gt;

&lt;p&gt;Wyjątkiem od tej zasady są pola stałe (&lt;code class=&quot;highlighter-rouge&quot;&gt;static final&lt;/code&gt; + niemutowalne), które powinny być zapisane dużymi literami, a poszczególne słowa oddzielone podłogą. Stałymi są również wartości enumów.&lt;/p&gt;

&lt;p&gt;Zmienne lokalne mają już większą dowolność co do nazwy, ale powinny być opisowe i oczywiście zaczynać się małą literą.&lt;/p&gt;

&lt;p&gt;Nazwy parametru typu składają się z jednej dużej litery. Najczęściej używa się:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; dla jakiegoś typu (jeśli jest więcej niż jeden, to kolejno &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;T1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;T2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;T3&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; dla typu elementu kolekcji&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; dla typu klucza i wartości mapy&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; dla typu wyjątku.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; dla typu zwracanego przez funkcję&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Podsumowując:&lt;/p&gt;

&lt;table class=&quot;post-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Element&lt;/th&gt;
      &lt;th&gt;Przykład&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pakiet lub moduł&lt;/td&gt;
      &lt;td&gt;org.junit.jupiter.api, com.google.common.collect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Klasa lub Interfejs&lt;/td&gt;
      &lt;td&gt;Stream, FutureTask, LinkedHashMap, HttpClient&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Metoda lub pole&lt;/td&gt;
      &lt;td&gt;remove, groupingBy, getCrc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stała&lt;/td&gt;
      &lt;td&gt;PI, MIN_VALUE, NEGATIVE_INFINITY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Zmienna lokalna&lt;/td&gt;
      &lt;td&gt;i, denom, houseNum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parametr typu&lt;/td&gt;
      &lt;td&gt;T, E, K, V, X, R, U, V, T1, T2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Odnośnie do konwencji gramatycznych, które nie są już tak bardzo konieczne, jak te typograficzne, to zazwyczaj nazwy klas instancjonowalnych są rzeczownikiem w liczbie pojedynczej jak np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PriorityQueue&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;ChessPiece&lt;/code&gt;. Z kolei nazwy nieinstancjonowalnych klasy typu utility często są w liczbie mnogiej np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt;. Interfejsy zazwyczaj nazywane są tak jak klasy np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;, ale też z końcówkami &lt;code class=&quot;highlighter-rouge&quot;&gt;able&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;ible&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Accessible&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Metody, które:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;wykonują jakieś akcje zazwyczaj ich nazwa to czasownik np. &lt;code class=&quot;highlighter-rouge&quot;&gt;append&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;drawImage&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;zwracają &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt; zazwyczaj zaczynają się od &lt;code class=&quot;highlighter-rouge&quot;&gt;is&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;has&lt;/code&gt; + rzeczownik np. &lt;code class=&quot;highlighter-rouge&quot;&gt;isDigit&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isProbablePrime&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isEmpty&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isEnabled&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;hasSiblings&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;zwracają jakąś daną zazwyczaj zaczynają się od &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; lub bezpośrednio nazwa tej danej np. &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;getTime&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;konwertują obiekt w inny zazwyczaj nazywają się &lt;code class=&quot;highlighter-rouge&quot;&gt;toType&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;toArray&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;zwracają inny widok zazwyczaj nazywają sie &lt;code class=&quot;highlighter-rouge&quot;&gt;asType&lt;/code&gt; np. &lt;code class=&quot;highlighter-rouge&quot;&gt;asList&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;są statycznymi fabrykami zazwyczaj nazywają się &lt;code class=&quot;highlighter-rouge&quot;&gt;from&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;of&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;instance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;newInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getType&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;newType&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 67, 68 z rozdziału 9: General Programming Item 57: Minimize the scope of local variables Item 58: Prefer for-each loops to traditional for loops Item 59: Know and use the libraries Item 60: Avoid float and double if exact answers are required Item 61: Prefer primitive types to boxed primitives Item 62: Avoid strings where other types are more appropriate Item 63: Beware the performance of string concatenation Item 64: Refer to objects by their interfaces Item 65: Prefer interfaces to reflection Item 66: Use native methods judiciously Item 67: Optimize judiciously Item 68: Adhere to generally accepted naming conventions Optymalizacja - robić czy nie? Są co najmniej 3 znane cytaty odnośnie optymalizacji: More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity. —William A. Wulf We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. —Donald E. Knuth We follow two rules in the matter of optimization: Rule 1. Don’t do it. Rule 2 (for experts only). Don’t do it yet—that is, not until you have a perfectly clear and unoptimized solution. —M. A. Jackson Wszystkie 3 cytaty poprzedzają język programowania Java o co najmniej dwie dekady, jednak nadal są aktualne i mówią świętą prawdę o optymalizacji — łatwiej jest nią narobić więcej szkód niż dobra, szczególnie jeśli mowa o przedwczesnej optymalizacji. Nie warto poświęcać dobrego designu na rzecz wydajności – lepiej jest pisać dobre programy niż szybkie. Jeśli dobry program nie jest wystarczająco wydajny, jego architektura pozwoli go później zoptymalizować. Dobre programy przestrzegają zasady enkapsulacji danych, więc pojedyncze decyzje mogą być zmienione bez wpływu na pozostałą część systemu. Nie znaczy to też, że powinniśmy ignorować problemy wydajnościowe, dopóki nie skończymy programu. Problemy implementacyjne mogą być naprawione późniejszą optymalizacją, ale wszechobecne wady architektury ograniczające wydajność mogą nie być możliwe do naprawy bez przepisywania całego systemu od nowa. Najtrudniej wprowadzić zamianę w komponentach, które zawierają interakcje pomiędzy komponentami a światem zewnętrznym np. API czy formaty przesyłania danych. Mogą też narzucić znaczne ograniczenia wydajności, dlatego te części systemy trzeba zaprojektować z największą starannością. Więc nie możemy całkiem przestać myśleć o optymalizacji. Zawsze trzeba rozważać konsekwencje naszych wyborów, np. tworząc typ mutowalny, możemy wymuszać na kliencie wiele zbędnych kopii defensywnych. Podobnie, używając dziedziczenia w publicznej klasie zamiast kompozycji, zszywamy daną klasę z nadklasa na zawsze, co może skutkować ograniczeniami podklasy. Tak samo używając w API typu implementacji zamiast interfejsu, wymuszamy tylko jedną konkretną implementację, mimo to, że w przyszłości mogłaby być napisana bardziej wydajna wersja. Jeśli system jest używany tylko wewnętrznie i możemy całkowicie przebudowywać kod, to nie ma to aż takiego znaczenia, ale po co sobie utrudniać życie? Na szczęście zazwyczaj dobry design idzie w parze z dobrą wydajnością lub z łatwą możliwością na jej poprawę. Kiedy zaprojektowaliśmy czysty i dobrze ustrukturyzowany kod, to wtedy może być czas na rozważanie optymalizacji, która w dobrze zaprojektowanym systemie jest łatwa do wprowadzenia. Nigdy nie powinniśmy skupiać się na optymalizacji kosztem spaczonego designu. W określeniu, gdzie powinniśmy skupić naszą uwagę podczas optymalizowania systemu, mogą nam pomóc profilery. Te narzędzia dają nam takie informacje jak np. czas, w jakim każda metoda się wykonuje i jak wiele razy to miało miejsce. Innym narzędziem, o którym warto wspomnieć, jest framework do benchmarków JMH, którym możemy zmierzyć wydajność poszczególnych kawałków kodu. Warto skorzystać z tego narzędzia, aby porównać zoptymalizowany kod, czy aby na pewno wydajność jest lepsza, czy tylko nam się tak wydaje. Konwencje nazewnicze w Javie Ten temat jest dosyć rozwlekle opisany w książce, jednak myślę, że tu nie ma co się rozdrabniać - podam same konkrety. W Javie (jak i w każdym innym języku) mamy powszechnie uznawane konwencje nazewnicze, których należy się trzymać. Można powiedzieć, że dzielą się na dwie grupy — typograficzne i gramatyczne. Nazwy pakietów i modułów powinny być zwięzłe i składać się wyłącznie z małych liter. Zalecane też są opisowe skróty np. util zamiast utilities lub akronimy. Nazwa pakietu, który będzie używany poza naszą organizacją, powinna zaczynać się od odwróconej nazwy domeny np. com.google. Klasy i interfejsy włączając w to enumy i adnotacje powinny zaczynać się wielką literą i dalej CamelCase. Często dyskusji podlega problem, czy akronimy powinny być całe pisane wielkimi literami, czy nie. Według mnie nie — tylko pierwsza litera powinna być pisana z dużej, szczególnie gdy mamy w nazwie dwa akronimy. Wolałbyś widzieć klasę nazwaną HTTPURL czy HttpUrl? Metody i pola obowiązują te same zasady tyle, że zaczynamy małą literą. Wyjątkiem od tej zasady są pola stałe (static final + niemutowalne), które powinny być zapisane dużymi literami, a poszczególne słowa oddzielone podłogą. Stałymi są również wartości enumów. Zmienne lokalne mają już większą dowolność co do nazwy, ale powinny być opisowe i oczywiście zaczynać się małą literą. Nazwy parametru typu składają się z jednej dużej litery. Najczęściej używa się: T dla jakiegoś typu (jeśli jest więcej niż jeden, to kolejno T, U, V lub T1, T2, T3) E dla typu elementu kolekcji K i V dla typu klucza i wartości mapy X dla typu wyjątku. R dla typu zwracanego przez funkcję Podsumowując: Element Przykład Pakiet lub moduł org.junit.jupiter.api, com.google.common.collect Klasa lub Interfejs Stream, FutureTask, LinkedHashMap, HttpClient Metoda lub pole remove, groupingBy, getCrc Stała PI, MIN_VALUE, NEGATIVE_INFINITY Zmienna lokalna i, denom, houseNum Parametr typu T, E, K, V, X, R, U, V, T1, T2 Odnośnie do konwencji gramatycznych, które nie są już tak bardzo konieczne, jak te typograficzne, to zazwyczaj nazwy klas instancjonowalnych są rzeczownikiem w liczbie pojedynczej jak np. Thread, PriorityQueue czy ChessPiece. Z kolei nazwy nieinstancjonowalnych klasy typu utility często są w liczbie mnogiej np. Collectors czy Collections. Interfejsy zazwyczaj nazywane są tak jak klasy np. Collection czy Comparator, ale też z końcówkami able lub ible np. Runnable, Iterable czy Accessible. Metody, które: wykonują jakieś akcje zazwyczaj ich nazwa to czasownik np. append lub drawImage zwracają boolean zazwyczaj zaczynają się od is lub has + rzeczownik np. isDigit, isProbablePrime, isEmpty, isEnabled lub hasSiblings zwracają jakąś daną zazwyczaj zaczynają się od get lub bezpośrednio nazwa tej danej np. size, hashCode lub getTime. konwertują obiekt w inny zazwyczaj nazywają się toType np. toString lub toArray. zwracają inny widok zazwyczaj nazywają sie asType np. asList. są statycznymi fabrykami zazwyczaj nazywają się from, of, valueOf, instance, getInstance, newInstance, getType lub newType.</summary></entry><entry><title type="html">Refleksja i metody natywne</title><link href="https://devcave.pl/effective-java/refleksja-i-metody-natywne" rel="alternate" type="text/html" title="Refleksja i metody natywne" /><published>2019-03-09T09:00:00+01:00</published><updated>2019-03-09T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/refleksja-i-metody-natywne</id><content type="html" xml:base="https://devcave.pl/effective-java/refleksja-i-metody-natywne">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 65, 66&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 57: Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 58: Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 59: Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 60: Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 61: Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 62: Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 63: Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 64: Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 65: Prefer interfaces to reflection
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 66: Use native methods judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 67: Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 68: Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;preferuj-interfejsy-zamiast-bezpośredniej-refleksji&quot;&gt;Preferuj interfejsy zamiast bezpośredniej refleksji&lt;/h1&gt;

&lt;p&gt;Refleksja, którą w Javie mamy w pakiecie &lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;, umożliwia uzyskać dostęp do konstruktorów, metod i pól każdej klasy, a także do ich nazw, typów, sygnatur itd.&lt;/p&gt;

&lt;p&gt;Dzięki temu możemy manipulować niemal każdym elementem klasy. Możemy również budować instancje, wywoływać metody czy nawet uzyskać dostęp do pól, które są zadeklarowane jako &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ponadto refleksja pozwala jednej klasie użyć drugiej, mimo że ta druga nie istniała podczas kompilacji tej pierwszej.&lt;/p&gt;

&lt;p&gt;Jest to zatem potężne narzędzie, jednak ma swoją cenę:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tracimy wszystkie zalety sprawdzania typów i wyjątków. Jeśli spróbujemy wywołać metodę nieistniejącą metodę refleksją, to program wysypie się dopiero w &lt;em&gt;runtime&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;Kod refleksji jest zazwyczaj paskudny i rozwlekły - ciężko się go piszę i czyta&lt;/li&gt;
  &lt;li&gt;Wydajność jest dużo gorsza w porównaniu ze zwykłym wywoływaniem metod&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Są aplikacje, które wręcz polegają na refleksji. Są to między innymi narzędzia analizy kodu czy frameworki &lt;em&gt;dependency injection&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Można jednak czerpać korzyści z refleksji, jednocześnie redukując przy tym jej koszt poprzez używanie refleksji w ograniczonej formie.&lt;/p&gt;

&lt;p&gt;Kiedy program musi używać klasy, która jeszcze nie jest dostępna w czasie kompilacji, możemy posłużyć się istniejącym interfejsem lub nadklasą, by odnosić się do tej klasy. Możemy wtedy utworzyć instancję refleksją i używać jej przez interfejs lub nadklasę.&lt;/p&gt;

&lt;p&gt;Dla przykładu program, który tworzy instancje &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&amp;lt;String&amp;gt;&lt;/code&gt;, której klasa jest podawana jako pierwszy argument w cmd. Pozostałe argumenty lądują w tym secie i są printowane na konsolę. Kolejność, w jakiej będą pokazane, zależy od implementacji setu np. jeśli podamy &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; to kolejność będzie losowa, a gdy &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt; to będzie alfabetycznie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Reflective instantiation with interface access&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Translate the class name into a Class object&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Unchecked cast!&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class not found.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Get the constructor&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NoSuchMethodException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No parameterless constructor&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Instantiate the set&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IllegalAccessException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor not accessible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InstantiationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class not instantiable.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InvocationTargetException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor threw &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassCastException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Class doesn't implement Set&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Exercise the set&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Np. dla argumentów &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.TreeSet b c d g i s a&lt;/code&gt; dostalibyśmy w wyniku &lt;code class=&quot;highlighter-rouge&quot;&gt;[a, b, c, d, g, i, s]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ten przykład pokazuję też jak kod refleksji jest rozwlekły i ile wymaga boilerplateru - generuje aż 6 różnych wyjątków. Można by je jednak zredukować, łapiąc &lt;code class=&quot;highlighter-rouge&quot;&gt;ReflectiveOperationException&lt;/code&gt;, który jest nadklasą wyjątków refleksji i został dodany w Javie 7. Używając refleksji dostajemy też wiele &lt;em&gt;unchecked cast warning&lt;/em&gt;. Więc ignorując poszczególne wyjątki otrzymalibyśmy taki kod:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Reflective instantiation with interface access&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Translate the class name into a Class object&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Unchecked cast!&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Get the constructor&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Instantiate the set&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Exercise the set&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ReflectiveOperationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Constructor not accessible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie jest już aż tak rozwlekły, ale nadal nie należy do najpiękniejszych.&lt;/p&gt;

&lt;p&gt;Podsumowując, refleksja to potężne narzędzie do specyficznych zastosowań i ma kilka wad. Jeśli jednak musimy jej użyć, powinniśmy (jeśli jest tylko taka możliwość) ograniczyć jej użycie do stworzenia instancji klasy, a później już operować na interfejsie czy nadklasie, która jest dostępna w czasie kompilacji.&lt;/p&gt;

&lt;h1 id=&quot;metody-natywne&quot;&gt;Metody natywne&lt;/h1&gt;

&lt;p&gt;Java Native Interface (JNI) pozwala na wywoływanie natywnych metod, które są napisane w natywnych dla danego systemu językach jak C czy C++. Może to być wykorzystane w celu uzyskania dostępu do specyficznych funkcji systemu jak np. rejestry czy do użycia bibliotek, które są napisane w natywnych językach. W natywnych językach mogą też być napisane części systemu, które są krytyczne pod względem wydajności i które później wywołamy z Javy.&lt;/p&gt;

&lt;p&gt;Obecnie jednak nie potrzebujemy używania natywnego kodu do większości specyficznych części systemu, bo Java wspiera już wiele z nich sama z siebie. Dla przykładu w Javie 9 dodano &lt;code class=&quot;highlighter-rouge&quot;&gt;process API&lt;/code&gt;, które daje nam wygodny dostęp do procesów systemu operacyjnego.&lt;/p&gt;

&lt;p&gt;Również pisanie natywnych metod w celu zapewnienia lepszej wydajności w wielu przypadkach nie jest już zalecane. JVM stał się dużo szybszy, niż to miało miejsce w pierwszych wersjach Javy i obecnie można uzyskać porównywalną wydajność w Javie. Na przykład, historycznie w Javie 1.1, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt; polegał wtedy na szybkiej bibliotece napisanej w C, a w Javie 3 zmieniono implementację na Javę i doprowadzono do tego, że była szybsza niż oryginalna, natywna implementacja.&lt;/p&gt;

&lt;p&gt;Wywoływanie metod natywnych wiąże się z kosztowną komunikacją między kodem działającym na JVM a tym natywnym. Używając natywnych metod uzależniamy się od systemu i aplikacja staje się mniej przenośna między systemami. Aplikacje takie są też mniej bezpieczne i trudniejsze w debugowaniu.&lt;/p&gt;

&lt;p&gt;Jeśli nigdy nie spotkałeś się z metodami natywnymi, to polecam: &lt;a href=&quot;https://www.baeldung.com/jni&quot;&gt;Guide to JNI (Java Native Interface)&lt;/a&gt;&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 65, 66 z rozdziału 9: General Programming Item 57: Minimize the scope of local variables Item 58: Prefer for-each loops to traditional for loops Item 59: Know and use the libraries Item 60: Avoid float and double if exact answers are required Item 61: Prefer primitive types to boxed primitives Item 62: Avoid strings where other types are more appropriate Item 63: Beware the performance of string concatenation Item 64: Refer to objects by their interfaces Item 65: Prefer interfaces to reflection Item 66: Use native methods judiciously Item 67: Optimize judiciously Item 68: Adhere to generally accepted naming conventions Preferuj interfejsy zamiast bezpośredniej refleksji Refleksja, którą w Javie mamy w pakiecie java.lang.reflect, umożliwia uzyskać dostęp do konstruktorów, metod i pól każdej klasy, a także do ich nazw, typów, sygnatur itd. Dzięki temu możemy manipulować niemal każdym elementem klasy. Możemy również budować instancje, wywoływać metody czy nawet uzyskać dostęp do pól, które są zadeklarowane jako private. Ponadto refleksja pozwala jednej klasie użyć drugiej, mimo że ta druga nie istniała podczas kompilacji tej pierwszej. Jest to zatem potężne narzędzie, jednak ma swoją cenę: tracimy wszystkie zalety sprawdzania typów i wyjątków. Jeśli spróbujemy wywołać metodę nieistniejącą metodę refleksją, to program wysypie się dopiero w runtime. Kod refleksji jest zazwyczaj paskudny i rozwlekły - ciężko się go piszę i czyta Wydajność jest dużo gorsza w porównaniu ze zwykłym wywoływaniem metod Są aplikacje, które wręcz polegają na refleksji. Są to między innymi narzędzia analizy kodu czy frameworki dependency injection. Można jednak czerpać korzyści z refleksji, jednocześnie redukując przy tym jej koszt poprzez używanie refleksji w ograniczonej formie. Kiedy program musi używać klasy, która jeszcze nie jest dostępna w czasie kompilacji, możemy posłużyć się istniejącym interfejsem lub nadklasą, by odnosić się do tej klasy. Możemy wtedy utworzyć instancję refleksją i używać jej przez interfejs lub nadklasę. Dla przykładu program, który tworzy instancje Set&amp;lt;String&amp;gt;, której klasa jest podawana jako pierwszy argument w cmd. Pozostałe argumenty lądują w tym secie i są printowane na konsolę. Kolejność, w jakiej będą pokazane, zależy od implementacji setu np. jeśli podamy HashSet to kolejność będzie losowa, a gdy TreeSet to będzie alfabetycznie: // Reflective instantiation with interface access public static void main(String[] args) { // Translate the class name into a Class object Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cl = null; try { cl = (Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt;) // Unchecked cast! Class.forName(args[0]); } catch (ClassNotFoundException e) { fatalError(&quot;Class not found.&quot;); } // Get the constructor Constructor&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cons = null; try { cons = cl.getDeclaredConstructor(); } catch (NoSuchMethodException e) { fatalError(&quot;No parameterless constructor&quot;); } // Instantiate the set Set&amp;lt;String&amp;gt; s = null; try { s = cons.newInstance(); } catch (IllegalAccessException e) { fatalError(&quot;Constructor not accessible&quot;); } catch (InstantiationException e) { fatalError(&quot;Class not instantiable.&quot;); } catch (InvocationTargetException e) { fatalError(&quot;Constructor threw &quot; + e.getCause()); } catch (ClassCastException e) { fatalError(&quot;Class doesn't implement Set&quot;); } // Exercise the set s.addAll(Arrays.asList(args).subList(1, args.length)); System.out.println(s); } private static void fatalError(String msg) { System.err.println(msg); System.exit(1); } Np. dla argumentów java.util.TreeSet b c d g i s a dostalibyśmy w wyniku [a, b, c, d, g, i, s]. Ten przykład pokazuję też jak kod refleksji jest rozwlekły i ile wymaga boilerplateru - generuje aż 6 różnych wyjątków. Można by je jednak zredukować, łapiąc ReflectiveOperationException, który jest nadklasą wyjątków refleksji i został dodany w Javie 7. Używając refleksji dostajemy też wiele unchecked cast warning. Więc ignorując poszczególne wyjątki otrzymalibyśmy taki kod: // Reflective instantiation with interface access public static void main(String[] args) { // Translate the class name into a Class object Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cl; Set&amp;lt;String&amp;gt; s = null; try { cl = (Class&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt;) // Unchecked cast! Class.forName(args[0]); // Get the constructor Constructor&amp;lt;? extends Set&amp;lt;String&amp;gt;&amp;gt; cons; cons = cl.getDeclaredConstructor(); // Instantiate the set s = cons.newInstance(); // Exercise the set s.addAll(Arrays.asList(args).subList(1, args.length)); } catch (ReflectiveOperationException e) { System.err.println(&quot;Constructor not accessible&quot;); System.exit(1); } System.out.println(s); } Nie jest już aż tak rozwlekły, ale nadal nie należy do najpiękniejszych. Podsumowując, refleksja to potężne narzędzie do specyficznych zastosowań i ma kilka wad. Jeśli jednak musimy jej użyć, powinniśmy (jeśli jest tylko taka możliwość) ograniczyć jej użycie do stworzenia instancji klasy, a później już operować na interfejsie czy nadklasie, która jest dostępna w czasie kompilacji. Metody natywne Java Native Interface (JNI) pozwala na wywoływanie natywnych metod, które są napisane w natywnych dla danego systemu językach jak C czy C++. Może to być wykorzystane w celu uzyskania dostępu do specyficznych funkcji systemu jak np. rejestry czy do użycia bibliotek, które są napisane w natywnych językach. W natywnych językach mogą też być napisane części systemu, które są krytyczne pod względem wydajności i które później wywołamy z Javy. Obecnie jednak nie potrzebujemy używania natywnego kodu do większości specyficznych części systemu, bo Java wspiera już wiele z nich sama z siebie. Dla przykładu w Javie 9 dodano process API, które daje nam wygodny dostęp do procesów systemu operacyjnego. Również pisanie natywnych metod w celu zapewnienia lepszej wydajności w wielu przypadkach nie jest już zalecane. JVM stał się dużo szybszy, niż to miało miejsce w pierwszych wersjach Javy i obecnie można uzyskać porównywalną wydajność w Javie. Na przykład, historycznie w Javie 1.1, BigInteger polegał wtedy na szybkiej bibliotece napisanej w C, a w Javie 3 zmieniono implementację na Javę i doprowadzono do tego, że była szybsza niż oryginalna, natywna implementacja. Wywoływanie metod natywnych wiąże się z kosztowną komunikacją między kodem działającym na JVM a tym natywnym. Używając natywnych metod uzależniamy się od systemu i aplikacja staje się mniej przenośna między systemami. Aplikacje takie są też mniej bezpieczne i trudniejsze w debugowaniu. Jeśli nigdy nie spotkałeś się z metodami natywnymi, to polecam: Guide to JNI (Java Native Interface)</summary></entry><entry><title type="html">Wybieraj właściwe typy</title><link href="https://devcave.pl/effective-java/wybieraj-wlasciwe-typy" rel="alternate" type="text/html" title="Wybieraj właściwe typy" /><published>2019-03-02T09:00:00+01:00</published><updated>2019-03-02T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/wybieraj-wlasciwe-typy</id><content type="html" xml:base="https://devcave.pl/effective-java/wybieraj-wlasciwe-typy">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 60, 61, 62, 63, 64&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 57: Minimize the scope of local variables
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 58: Prefer for-each loops to traditional for loops
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;Item 59: Know and use the libraries
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 60: Avoid float and double if exact answers are required
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 61: Prefer primitive types to boxed primitives
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 62: Avoid strings where other types are more appropriate
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 63: Beware the performance of string concatenation
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 64: Refer to objects by their interfaces
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 65: Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 66: Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 67: Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 68: Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;unikaj-float-i-double-kiedy-potrzebujesz-precyzji&quot;&gt;Unikaj float i double kiedy potrzebujesz precyzji&lt;/h1&gt;

&lt;p&gt;Typy &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; były zaprojektowane początkowo do naukowych obliczeń. Skupiają się na jak najlepszej wydajności, jednak nie dostarczają one dokładnych wyników. Przykładowo nie powinny być stosowane w obliczeniach walutowych, bo nie jest możliwe precyzyjne reprezentowania 0.1 lub innej ujemnej potęgi 10 jako &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dla przykładu, mając 1.03 zł i odejmując od tego 42 gr, dostalibyśmy w wyniku 0.6100000000000001.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.03&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 0.6100000000000001&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Inny przykład - mając 1 zł i odejmując od tego 9 razy coś za 10 gr zostałoby nam 0.09999999999999998 zł.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.00&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 0.09999999999999998&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Może się zdawać, że ten problem można by rozwiązać, po prostu zaokrąglając wyniki, jednak nie jest to prawda - nie zawsze by to działało.&lt;/p&gt;

&lt;p&gt;Rozwiązanie jest prostsze - tam gdzie jest wymagana precyzja, używaj - &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, lub &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Najlepiej jest używać konstruktora &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt;, który przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; - wtedy unikamy wprowadzania niedokładnych wartości do obliczeń.&lt;/p&gt;

&lt;p&gt;Używanie &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt; ma jednak dwie wady:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jest dużo mniej wygodne niż używanie prymitywnych typów&lt;/li&gt;
  &lt;li&gt;jest też od nich mniej wydajne&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jednak tym drugim w większości wypadków nie ma się co przejmować.&lt;/p&gt;

&lt;h1 id=&quot;preferuj-typy-prymitywne&quot;&gt;Preferuj typy prymitywne&lt;/h1&gt;

&lt;p&gt;Ten temat już był i dobrze go opisałem w poście &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;Unikaj nadmiarowego tworzenia obiektów&lt;/a&gt;, wyjaśniając i pokazując na przykładzie, dlaczego powinniśmy preferować typy prymitywne zamiast ich odpowiedników klasowych (&lt;em&gt;boxed primitives&lt;/em&gt;).&lt;/p&gt;

&lt;h1 id=&quot;unikaj-używania-stringów-tam-gdzie-istnieją-lepsze-alternatywy&quot;&gt;Unikaj używania stringów tam, gdzie istnieją lepsze alternatywy&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; został zaprojektowany by reprezentować tekst, jednak jest tendencja, by go używać do innych celów, podczas gdy mamy do tego lepsze alternatywy.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; często dostajemy w żądaniach z przeglądarki, czytając plik i z wielu innych źródeł - jest to naturalne, jednak nie powinniśmy tego zostawiać w tej postaci, jeśli istnieje lub możemy stworzyć odpowiedni typ reprezentujący te dane. Niby jest to oczywiste, ale i tak często &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; jest nadużywane.&lt;/p&gt;

&lt;p&gt;Kolejną złą praktyką jest używanie stringów zamiast enumów - opisywałem to w temacie &lt;a href=&quot;/effective-java/enums&quot;&gt;Enumy - kilka dobrych praktyk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Przed użyciem &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; warto się zastanowić czy nie ma lepszej alternatywy dla danego zastosowania.&lt;/p&gt;

&lt;h1 id=&quot;wydajność-konkatenacji-stringów&quot;&gt;Wydajność konkatenacji stringów&lt;/h1&gt;

&lt;p&gt;Jak pewnie Ci wiadomo &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; w Javie jest niemutowalny, więc każde użycie operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; między stringami (konkatenacja) tworzy nowy obiekt &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;. Jest to całkowicie w porządku w przypadku łączeniu kilku stringów o stałej długości, jednak mało wydajne przy budowaniu dużych ciągów tekstu, szczególnie w pętli. Przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Inappropriate use of string concatenation - Performs poorly!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineForItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// String concatenation&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu dla każdej iteracji pętli tworzy się niepotrzebnie nowy &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;, przez co metoda jest mało wydajna. Rozwiązaniem tutaj jest użycie klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;, która jest mutowalnym odpowiednikiem klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;LINE_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineForItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W prostych przypadkach nie ma sensu używać &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a ponieważ kompilator Javy automatycznie robi to za nas (taka automatyczna optymalizacja z jego strony). Użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a w prostych przypadkach tylko źle wpływa na czytelność kodu. Lepiej jest użyć wtedy po prostu operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;. Jednak w przypadku pętli i w bardziej złożonych operacjach konkatenacji, kompilator Javy nie jest w stanie podmienić jej na użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;-a, więc w takich przypadkach warto go użyć.&lt;/p&gt;

&lt;h1 id=&quot;odnoś-się-do-obiektów-po-ich-interfejsach&quot;&gt;Odnoś się do obiektów po ich interfejsach&lt;/h1&gt;

&lt;p&gt;Podobny rada była w poście &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Projektowanie metod&lt;/a&gt;, gdzie była mowa o używaniu interfejsów w typie parametrów. Ten temat rozszerza tę radę do wszystkich możliwych miejsc deklaracji typu - parametry, wartości zwracane, zmienne czy pola. Jeśli istnieje odpowiedni interfejs, to bez względu na miejsce deklaracji, zawsze powinniśmy deklarować typ jako interfejs zamiast konkretnej klasy.&lt;/p&gt;

&lt;p&gt;Jedyny moment, gdzie musimy odnieść się do klasy konkretnej, jest tam, gdzie tworzymy ten obiekt konstruktorem.&lt;/p&gt;

&lt;p&gt;Zatem miejmy w nawyku taki kod:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Good - uses interface as type&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A nie taki:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bad - uses class as type!&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dostajemy dzięki temu bardziej zwięzły kod, ale co ważniejsze - większą elastyczność. Możemy w każdej chwili zmienić implementację, a cały kod dookoła będzie dalej się kompilował:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Son&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I prawdopodobnie działał. Jest jednak jeden wyjątek od tej zasady. Jeśli konkretna implementacja oferuję jakąś specjalną funkcjonalność, która nie jest zagwarantowana przez interfejs i kod polega na tej funkcjonalności, to nie powinniśmy używać ogólnego interfejsu jako deklaracji typu.&lt;/p&gt;

&lt;p&gt;Przykładem tutaj mogłoby być to, że nasz kod polegałby na sortowaniu zapewnionym przez &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;. Wtedy byłoby nieodpowiednie zadeklarowanie typu tej zmiennej jako &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt; ponieważ interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt; sam w sobie nie daję żadnej gwarancji odnośnie sortowania.&lt;/p&gt;

&lt;p&gt;Oczywiście jest wiele przypadków, gdzie klasy nie mają swoich interfejsów, szczególnie tzw. &lt;em&gt;value classes&lt;/em&gt; jak np. &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt;. Wtedy naturalnie będziemy używać konkretnych klas i nie ma w tym nic złego. Postarajmy się wtedy używać po prostu klasę najwyżej w hierarchii, która ma wymaganą przez nas funkcjonalność.&lt;/p&gt;

&lt;p&gt;Czasem musimy zrobić też użytek z metod, które występują w klasie konkretnej, a nie ma ich na interfejsie - wtedy też użyjemy klasy konkretnej jako deklaracji typu i nie ma w tym nic złego.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 60, 61, 62, 63, 64 z rozdziału 9: General Programming Item 57: Minimize the scope of local variables Item 58: Prefer for-each loops to traditional for loops Item 59: Know and use the libraries Item 60: Avoid float and double if exact answers are required Item 61: Prefer primitive types to boxed primitives Item 62: Avoid strings where other types are more appropriate Item 63: Beware the performance of string concatenation Item 64: Refer to objects by their interfaces Item 65: Prefer interfaces to reflection Item 66: Use native methods judiciously Item 67: Optimize judiciously Item 68: Adhere to generally accepted naming conventions Unikaj float i double kiedy potrzebujesz precyzji Typy float i double były zaprojektowane początkowo do naukowych obliczeń. Skupiają się na jak najlepszej wydajności, jednak nie dostarczają one dokładnych wyników. Przykładowo nie powinny być stosowane w obliczeniach walutowych, bo nie jest możliwe precyzyjne reprezentowania 0.1 lub innej ujemnej potęgi 10 jako float lub double. Dla przykładu, mając 1.03 zł i odejmując od tego 42 gr, dostalibyśmy w wyniku 0.6100000000000001. System.out.println(1.03 - 0.42); // 0.6100000000000001 Inny przykład - mając 1 zł i odejmując od tego 9 razy coś za 10 gr zostałoby nam 0.09999999999999998 zł. System.out.println(1.00 - 9 * 0.10); // 0.09999999999999998 Może się zdawać, że ten problem można by rozwiązać, po prostu zaokrąglając wyniki, jednak nie jest to prawda - nie zawsze by to działało. Rozwiązanie jest prostsze - tam gdzie jest wymagana precyzja, używaj - BigDecimal, int, lub long. Najlepiej jest używać konstruktora BigDecimal, który przyjmuje String - wtedy unikamy wprowadzania niedokładnych wartości do obliczeń. Używanie BigDecimal ma jednak dwie wady: jest dużo mniej wygodne niż używanie prymitywnych typów jest też od nich mniej wydajne Jednak tym drugim w większości wypadków nie ma się co przejmować. Preferuj typy prymitywne Ten temat już był i dobrze go opisałem w poście Unikaj nadmiarowego tworzenia obiektów, wyjaśniając i pokazując na przykładzie, dlaczego powinniśmy preferować typy prymitywne zamiast ich odpowiedników klasowych (boxed primitives). Unikaj używania stringów tam, gdzie istnieją lepsze alternatywy String został zaprojektowany by reprezentować tekst, jednak jest tendencja, by go używać do innych celów, podczas gdy mamy do tego lepsze alternatywy. String często dostajemy w żądaniach z przeglądarki, czytając plik i z wielu innych źródeł - jest to naturalne, jednak nie powinniśmy tego zostawiać w tej postaci, jeśli istnieje lub możemy stworzyć odpowiedni typ reprezentujący te dane. Niby jest to oczywiste, ale i tak często String jest nadużywane. Kolejną złą praktyką jest używanie stringów zamiast enumów - opisywałem to w temacie Enumy - kilka dobrych praktyk. Przed użyciem String warto się zastanowić czy nie ma lepszej alternatywy dla danego zastosowania. Wydajność konkatenacji stringów Jak pewnie Ci wiadomo String w Javie jest niemutowalny, więc każde użycie operatora + między stringami (konkatenacja) tworzy nowy obiekt String. Jest to całkowicie w porządku w przypadku łączeniu kilku stringów o stałej długości, jednak mało wydajne przy budowaniu dużych ciągów tekstu, szczególnie w pętli. Przykład: // Inappropriate use of string concatenation - Performs poorly! public String statement() { String result = &quot;&quot;; for (int i = 0; i &amp;lt; numItems(); i++) result += lineForItem(i); // String concatenation return result; } Tu dla każdej iteracji pętli tworzy się niepotrzebnie nowy String, przez co metoda jest mało wydajna. Rozwiązaniem tutaj jest użycie klasy StringBuilder, która jest mutowalnym odpowiednikiem klasy String: public String statement() { StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH); for (int i = 0; i &amp;lt; numItems(); i++) b.append(lineForItem(i)); return b.toString(); } W prostych przypadkach nie ma sensu używać StringBuilder-a ponieważ kompilator Javy automatycznie robi to za nas (taka automatyczna optymalizacja z jego strony). Użycie StringBuilder-a w prostych przypadkach tylko źle wpływa na czytelność kodu. Lepiej jest użyć wtedy po prostu operatora +. Jednak w przypadku pętli i w bardziej złożonych operacjach konkatenacji, kompilator Javy nie jest w stanie podmienić jej na użycie StringBuilder-a, więc w takich przypadkach warto go użyć. Odnoś się do obiektów po ich interfejsach Podobny rada była w poście Projektowanie metod, gdzie była mowa o używaniu interfejsów w typie parametrów. Ten temat rozszerza tę radę do wszystkich możliwych miejsc deklaracji typu - parametry, wartości zwracane, zmienne czy pola. Jeśli istnieje odpowiedni interfejs, to bez względu na miejsce deklaracji, zawsze powinniśmy deklarować typ jako interfejs zamiast konkretnej klasy. Jedyny moment, gdzie musimy odnieść się do klasy konkretnej, jest tam, gdzie tworzymy ten obiekt konstruktorem. Zatem miejmy w nawyku taki kod: // Good - uses interface as type Set&amp;lt;Son&amp;gt; sonSet = new LinkedHashSet&amp;lt;&amp;gt;(); A nie taki: // Bad - uses class as type! LinkedHashSet&amp;lt;Son&amp;gt; sonSet = new LinkedHashSet&amp;lt;&amp;gt;(); Dostajemy dzięki temu bardziej zwięzły kod, ale co ważniejsze - większą elastyczność. Możemy w każdej chwili zmienić implementację, a cały kod dookoła będzie dalej się kompilował: Set&amp;lt;Son&amp;gt; sonSet = new HashSet&amp;lt;&amp;gt;(); I prawdopodobnie działał. Jest jednak jeden wyjątek od tej zasady. Jeśli konkretna implementacja oferuję jakąś specjalną funkcjonalność, która nie jest zagwarantowana przez interfejs i kod polega na tej funkcjonalności, to nie powinniśmy używać ogólnego interfejsu jako deklaracji typu. Przykładem tutaj mogłoby być to, że nasz kod polegałby na sortowaniu zapewnionym przez LinkedHashSet. Wtedy byłoby nieodpowiednie zadeklarowanie typu tej zmiennej jako Set ponieważ interfejs Set sam w sobie nie daję żadnej gwarancji odnośnie sortowania. Oczywiście jest wiele przypadków, gdzie klasy nie mają swoich interfejsów, szczególnie tzw. value classes jak np. String czy BigInteger. Wtedy naturalnie będziemy używać konkretnych klas i nie ma w tym nic złego. Postarajmy się wtedy używać po prostu klasę najwyżej w hierarchii, która ma wymaganą przez nas funkcjonalność. Czasem musimy zrobić też użytek z metod, które występują w klasie konkretnej, a nie ma ich na interfejsie - wtedy też użyjemy klasy konkretnej jako deklaracji typu i nie ma w tym nic złego.</summary></entry><entry><title type="html">Zasięg zmiennych, pętle i biblioteki</title><link href="https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki" rel="alternate" type="text/html" title="Zasięg zmiennych, pętle i biblioteki" /><published>2019-02-23T09:00:00+01:00</published><updated>2019-02-23T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki</id><content type="html" xml:base="https://devcave.pl/effective-java/zasieg-zmiennych-petle-i-biblioteki">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 57, 58, 59&lt;/i&gt; z rozdziału 9:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;General Programming&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 57: Minimize the scope of local variables
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 58: Prefer for-each loops to traditional for loops
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/zasieg-zmiennych-petle-i-biblioteki&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 59: Know and use the libraries
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 60: Avoid float and double if exact answers are required
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 61: Prefer primitive types to boxed primitives
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 62: Avoid strings where other types are more appropriate
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 63: Beware the performance of string concatenation
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wybieraj-wlasciwe-typy&quot;&gt;Item 64: Refer to objects by their interfaces
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 65: Prefer interfaces to reflection
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/refleksja-i-metody-natywne&quot;&gt;Item 66: Use native methods judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 67: Optimize judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/optymalizacja-i-konwencje-nazewnicze&quot;&gt;Item 68: Adhere to generally accepted naming conventions
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;W tym rozdziale jest zawarta kolejna porcja dobrych praktyk dla featureów Javy. Będzie też o refleksji, natywnych metodach i optymalizacji.
Jednak to potem, najpierw trzy pierwsze tematy:&lt;/p&gt;

&lt;h1 id=&quot;minimalizowanie-zasięgu-zmiennych&quot;&gt;Minimalizowanie zasięgu zmiennych&lt;/h1&gt;

&lt;p&gt;Dlaczego jest to ważne? Ano sprawia, że kod jest bardziej czytelny i mniej podatny na błedy.&lt;/p&gt;

&lt;p&gt;Zmienne powinny być deklarowane najbliżej pierwszego użycia. W przeciwnym wypadku będzie to zaśmiecać inny niepowiązany kawałek kodu i wprowadzać chaos.&lt;/p&gt;

&lt;p&gt;Deklarując zmienną zbyt wcześnie, nie tylko sprawiamy, że zasięg zaczyna się zbyt wcześnie, ale też kończy zbyt późno. Raczej nie powinno się rozdzielać deklaracji od zainicializowania, jedynym wyjątkiem tutaj jest try catch, gdzie jest to wymuszone.&lt;/p&gt;

&lt;p&gt;Pętle oferują dodatkową możliwość na zmniejszenie zasięgu zmiennych. Możemy w nich zadeklarować zmienne pętli, w rezultacie ograniczając ich zasięg tylko do pętli.&lt;/p&gt;

&lt;p&gt;Jednak preferowany sposób na iterowanie po kolekcji to:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Preferred idiom for iterating over a collection or array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do Something with e&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli potrzebujemy dostępu do iteratora, np. żeby wywołać metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt; to:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Idiom for iterating when you need the iterator&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e and i&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dlaczego te są preferowane, a nie pętle while? Prosty przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// BUG!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Druga pętla przez przypadek używa pierwszego iteratora, który nadal jest w zasięgu. Kod kompiluje się i wykonuje bez błędu.&lt;/p&gt;

&lt;p&gt;W przypadku zwykłych pętli nie ma takiej opcji:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e and i&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Compile-time error - cannot find symbol i&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e2 and i2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu inny przykład na minimalizowanie zasięgu zmiennej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expensiveComputation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with i;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Deklarujmy 2 zmienne pętli, aby uniknąć kosztownego i niepotrzebnego obliczania &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; w każdej iteracji pętli jednocześnie ograniczając jej zasięg tylko do pętli.&lt;/p&gt;

&lt;p&gt;Ostatnią ogólną dobrą techniką minimalizowania zasięgu zmiennych jest utrzymywanie metod krótkich i konkretnych. Jeśli połączone są 2 czynności w jednej metodzie i mają zmienne wymieszane między sobą, to dobrze jest je rozdzielić.&lt;/p&gt;

&lt;h1 id=&quot;preferuj-pętle-for-each&quot;&gt;Preferuj pętle for-each&lt;/h1&gt;

&lt;p&gt;Lekcja w tym temacie jest dosyć oczywista i wydaje mi się, że powszechnie stosowana, więc tylko na szybko - używaj zawsze for-each, jeśli nie potrzebujesz dostępu do indexu.&lt;/p&gt;

&lt;p&gt;Redukuje to boilerplate, zmniejsza szum, przez co kod jest bardziej czytelny, oraz nie mamy możliwości popełnienia błędu:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The preferred idiom for iterating over collections and arrays&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Do something with e&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co jest ważne - nie ma tu utraty wydajności czy jakiegoś innego skutku ubocznego - kod kompiluje się do niemal identycznej tradycyjnej pętli.&lt;/p&gt;

&lt;p&gt;Te pętle też są łatwiejsze w użyciu w przypadku zagnieżdżonych pętli. Ze zwykłymi pętlami można zrobić następujący błąd:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Can you spot the bug?&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CLUB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DIAMOND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;HEART&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SPADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ACE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DEUCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FIVE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SEVEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EIGHT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;NINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;JACK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;QUEEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;KING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Widzisz go? Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt; dla &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; jest wywoływana w złym miejscu. Powinna być wywołana wcześniej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Fixed, but ugly - you can do better!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Teraz działa, jednak jest to mało czytelne - dużo lepiej jest używać po prostu for-each:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Preferred idiom for nested iteration on collections and arrays&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rank&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Card&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jednak są 3 sytuacje, kiedy nie zrobimy z nich użytku:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gdy chcemy usunąć elementy z kolekcji. Wtedy musimy skorzystać z iteratora lub lepiej - użyć dodanej w Javie 8 metody &lt;code class=&quot;highlighter-rouge&quot;&gt;removeIf&lt;/code&gt; do kolekcji.&lt;/li&gt;
  &lt;li&gt;Gdy chcemy podmienić jakieś elementy&lt;/li&gt;
  &lt;li&gt;Współbieżne iterowanie&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Warto zaznaczyć fakt, że możemy iterować pętlą for-each po każdym obiekcie, który implementuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;poznaj-i-używaj-biblioteki&quot;&gt;Poznaj i używaj biblioteki&lt;/h1&gt;

&lt;p&gt;Trzeci temat mówi o ważności znajomości bibliotek i o tym, by nie wynajdować koła na nowo.&lt;/p&gt;

&lt;p&gt;Weźmy na przykład, że chcemy wygenerować losowe liczby od 0 do n. Natykając się na tak powszechny problem, możesz być niemal pewny, że ktoś już stworzył do tego dobrze działający algorytm.&lt;/p&gt;

&lt;p&gt;By napisać samemu taki algorytm, musiałbyś sporo wiedzieć o pseudolosowych generatorach liczb, teorii liczb i kodzie uzupełnień do dwóch. Na szczęście ten problem mamy już rozwiązany w Javie.&lt;/p&gt;

&lt;p&gt;Od Javy 7 nie powinniśmy już używać do tego klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Random&lt;/code&gt;. Dla większości użyć dobrym wyborem jest &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalRandom&lt;/code&gt;. Produkuje lepszej jakości liczby losowe i jest dużo szybszy od poprzednika. Dla &lt;code class=&quot;highlighter-rouge&quot;&gt;ForkJoinPool&lt;/code&gt; i współbieżnych streamów używaj &lt;code class=&quot;highlighter-rouge&quot;&gt;SplittableRandom&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Drugą przewagą bibliotek jest to, że nie musisz tracić czasu na rzeźbienie rozwiązań dla niepowiązanych zbytnio z aplikacją powszechnym problemów, a możesz skupić się na tworzeniu aplikacji i jej funkcjonalności.&lt;/p&gt;

&lt;p&gt;Kolejną przewagą jest to, że biblioteki najczęściej są cały czas rozwijane (czasem przez całe zespoły) i testowane przez tysiące użytkowników, więc dostajemy solidne, wydajne i przetestowane rozwiązanie niemal za darmo.&lt;/p&gt;

&lt;p&gt;Mimo tylu zalet dużo programistów nadal nie używa bibliotek w pełni - czemu? Najprawdopodobniej
 dlatego, że ich do końca nie znają. Dlatego ważne jest, żeby zaznajamiać się z każdymi nowościami wchodzącymi do Javy i innych bibliotek. Często wprowadzane jest wiele usprawnień, które znacznie poprawiają choćby czytelność i kod klienta.&lt;/p&gt;

&lt;p&gt;Kompletnie podstawowym zestawem bibliotek każdego programisty powinny być przynajmniej te z:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java.lang&lt;/li&gt;
  &lt;li&gt;java.util&lt;/li&gt;
  &lt;li&gt;java.io&lt;/li&gt;
  &lt;li&gt;collections  framkework&lt;/li&gt;
  &lt;li&gt;biblioteka stremów&lt;/li&gt;
  &lt;li&gt;java.util.concurrent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeśli nie możesz znaleźć czegoś w bibliotekach Javy, następnym dobrym wyborem mogą być biblioteki firm trzecich jak np. googlowska &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Guava&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Podsumowując, zmierzając się z jakimiś powszechnym problemem, nie wynajduj koła na nowo - używaj bibliotek w jak najbardziej efektywny sposób, a do rzeźbienia czegoś samemu zabieraj się tylko wtedy, gdy żadna biblioteka nie spełnia twoich potrzeb.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 57, 58, 59 z rozdziału 9: General Programming Item 57: Minimize the scope of local variables Item 58: Prefer for-each loops to traditional for loops Item 59: Know and use the libraries Item 60: Avoid float and double if exact answers are required Item 61: Prefer primitive types to boxed primitives Item 62: Avoid strings where other types are more appropriate Item 63: Beware the performance of string concatenation Item 64: Refer to objects by their interfaces Item 65: Prefer interfaces to reflection Item 66: Use native methods judiciously Item 67: Optimize judiciously Item 68: Adhere to generally accepted naming conventions W tym rozdziale jest zawarta kolejna porcja dobrych praktyk dla featureów Javy. Będzie też o refleksji, natywnych metodach i optymalizacji. Jednak to potem, najpierw trzy pierwsze tematy: Minimalizowanie zasięgu zmiennych Dlaczego jest to ważne? Ano sprawia, że kod jest bardziej czytelny i mniej podatny na błedy. Zmienne powinny być deklarowane najbliżej pierwszego użycia. W przeciwnym wypadku będzie to zaśmiecać inny niepowiązany kawałek kodu i wprowadzać chaos. Deklarując zmienną zbyt wcześnie, nie tylko sprawiamy, że zasięg zaczyna się zbyt wcześnie, ale też kończy zbyt późno. Raczej nie powinno się rozdzielać deklaracji od zainicializowania, jedynym wyjątkiem tutaj jest try catch, gdzie jest to wymuszone. Pętle oferują dodatkową możliwość na zmniejszenie zasięgu zmiennych. Możemy w nich zadeklarować zmienne pętli, w rezultacie ograniczając ich zasięg tylko do pętli. Jednak preferowany sposób na iterowanie po kolekcji to: // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Something with e } Jeśli potrzebujemy dostępu do iteratora, np. żeby wywołać metodę remove() to: // Idiom for iterating when you need the iterator for (Iterator&amp;lt;Element&amp;gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do something with e and i } Dlaczego te są preferowane, a nie pętle while? Prosty przykład: Iterator&amp;lt;Element&amp;gt; i = c.iterator(); while (i.hasNext()) { doSomething(i.next()); } ... Iterator&amp;lt;Element&amp;gt; i2 = c2.iterator(); while (i.hasNext()) { // BUG! doSomethingElse(i2.next()); } Druga pętla przez przypadek używa pierwszego iteratora, który nadal jest w zasięgu. Kod kompiluje się i wykonuje bez błędu. W przypadku zwykłych pętli nie ma takiej opcji: for (Iterator&amp;lt;Element&amp;gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do something with e and i } ... // Compile-time error - cannot find symbol i for (Iterator&amp;lt;Element&amp;gt; i2 = c2.iterator(); i.hasNext(); ) { Element e2 = i2.next(); ... // Do something with e2 and i2 } Tu inny przykład na minimalizowanie zasięgu zmiennej: for (int i = 0, n = expensiveComputation(); i &amp;lt; n; i++) { ... // Do something with i; } Deklarujmy 2 zmienne pętli, aby uniknąć kosztownego i niepotrzebnego obliczania n w każdej iteracji pętli jednocześnie ograniczając jej zasięg tylko do pętli. Ostatnią ogólną dobrą techniką minimalizowania zasięgu zmiennych jest utrzymywanie metod krótkich i konkretnych. Jeśli połączone są 2 czynności w jednej metodzie i mają zmienne wymieszane między sobą, to dobrze jest je rozdzielić. Preferuj pętle for-each Lekcja w tym temacie jest dosyć oczywista i wydaje mi się, że powszechnie stosowana, więc tylko na szybko - używaj zawsze for-each, jeśli nie potrzebujesz dostępu do indexu. Redukuje to boilerplate, zmniejsza szum, przez co kod jest bardziej czytelny, oraz nie mamy możliwości popełnienia błędu: // The preferred idiom for iterating over collections and arrays for (Element e : elements) { ... // Do something with e } Co jest ważne - nie ma tu utraty wydajności czy jakiegoś innego skutku ubocznego - kod kompiluje się do niemal identycznej tradycyjnej pętli. Te pętle też są łatwiejsze w użyciu w przypadku zagnieżdżonych pętli. Ze zwykłymi pętlami można zrobić następujący błąd: // Can you spot the bug? enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection&amp;lt;Suit&amp;gt; suits = Arrays.asList(Suit.values()); static Collection&amp;lt;Rank&amp;gt; ranks = Arrays.asList(Rank.values()); List&amp;lt;Card&amp;gt; deck = new ArrayList&amp;lt;&amp;gt;(); for (Iterator&amp;lt;Suit&amp;gt; i = suits.iterator(); i.hasNext(); ) for (Iterator&amp;lt;Rank&amp;gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); Widzisz go? Metoda next() dla i jest wywoływana w złym miejscu. Powinna być wywołana wcześniej: // Fixed, but ugly - you can do better! for (Iterator&amp;lt;Suit&amp;gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator&amp;lt;Rank&amp;gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } Teraz działa, jednak jest to mało czytelne - dużo lepiej jest używać po prostu for-each: // Preferred idiom for nested iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); Jednak są 3 sytuacje, kiedy nie zrobimy z nich użytku: Gdy chcemy usunąć elementy z kolekcji. Wtedy musimy skorzystać z iteratora lub lepiej - użyć dodanej w Javie 8 metody removeIf do kolekcji. Gdy chcemy podmienić jakieś elementy Współbieżne iterowanie Warto zaznaczyć fakt, że możemy iterować pętlą for-each po każdym obiekcie, który implementuje Iterable. Poznaj i używaj biblioteki Trzeci temat mówi o ważności znajomości bibliotek i o tym, by nie wynajdować koła na nowo. Weźmy na przykład, że chcemy wygenerować losowe liczby od 0 do n. Natykając się na tak powszechny problem, możesz być niemal pewny, że ktoś już stworzył do tego dobrze działający algorytm. By napisać samemu taki algorytm, musiałbyś sporo wiedzieć o pseudolosowych generatorach liczb, teorii liczb i kodzie uzupełnień do dwóch. Na szczęście ten problem mamy już rozwiązany w Javie. Od Javy 7 nie powinniśmy już używać do tego klasy Random. Dla większości użyć dobrym wyborem jest ThreadLocalRandom. Produkuje lepszej jakości liczby losowe i jest dużo szybszy od poprzednika. Dla ForkJoinPool i współbieżnych streamów używaj SplittableRandom. Drugą przewagą bibliotek jest to, że nie musisz tracić czasu na rzeźbienie rozwiązań dla niepowiązanych zbytnio z aplikacją powszechnym problemów, a możesz skupić się na tworzeniu aplikacji i jej funkcjonalności. Kolejną przewagą jest to, że biblioteki najczęściej są cały czas rozwijane (czasem przez całe zespoły) i testowane przez tysiące użytkowników, więc dostajemy solidne, wydajne i przetestowane rozwiązanie niemal za darmo. Mimo tylu zalet dużo programistów nadal nie używa bibliotek w pełni - czemu? Najprawdopodobniej dlatego, że ich do końca nie znają. Dlatego ważne jest, żeby zaznajamiać się z każdymi nowościami wchodzącymi do Javy i innych bibliotek. Często wprowadzane jest wiele usprawnień, które znacznie poprawiają choćby czytelność i kod klienta. Kompletnie podstawowym zestawem bibliotek każdego programisty powinny być przynajmniej te z: java.lang java.util java.io collections framkework biblioteka stremów java.util.concurrent Jeśli nie możesz znaleźć czegoś w bibliotekach Javy, następnym dobrym wyborem mogą być biblioteki firm trzecich jak np. googlowska Guava. Podsumowując, zmierzając się z jakimiś powszechnym problemem, nie wynajduj koła na nowo - używaj bibliotek w jak najbardziej efektywny sposób, a do rzeźbienia czegoś samemu zabieraj się tylko wtedy, gdy żadna biblioteka nie spełnia twoich potrzeb.</summary></entry><entry><title type="html">Varargi, nulle i Optionale</title><link href="https://devcave.pl/effective-java/vargargi-nulle-i-optionale" rel="alternate" type="text/html" title="Varargi, nulle i Optionale" /><published>2019-02-16T09:00:00+01:00</published><updated>2019-02-16T09:00:00+01:00</updated><id>https://devcave.pl/effective-java/vargargi-nulle-i-optionale</id><content type="html" xml:base="https://devcave.pl/effective-java/vargargi-nulle-i-optionale">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 53, 54, 55, 56&lt;/i&gt; z rozdziału 8:&lt;/p&gt;

&lt;p class=&quot;m-0&quot;&gt;Methods&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 49: Check parameters for validity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/sprawdzanie-parametr%C3%B3w-i-defensive-copy&quot;&gt;Item 50: Make defensive copies when needed
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 51: Design method signatures carefully
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/projektowanie-metod-i-przeciazenie&quot;&gt;Item 52: Use overloading judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 53: Use varargs judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 54: Return empty collections or arrays, not nulls
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 55: Return optionals judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/vargargi-nulle-i-optionale&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 56: Write doc comments for all exposed API elements
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;używanie-varargs&quot;&gt;Używanie varargs&lt;/h1&gt;

&lt;p&gt;Co to są &lt;em&gt;varargs&lt;/em&gt;? Jest to po prostu zmienna ilość parametrów zadeklarowana jako jeden argument. Można to porównać do tablicy - może przechowywać zero lub więcej argumentów. 
Pod spodem działa to tak że tworzona jest tablica wielkości liczby podanych elementów, a następnie te wartości są w niej umieszczane i do metody przekazywana jest tablica.&lt;/p&gt;

&lt;p&gt;Przykładowe proste użycie &lt;em&gt;varargs&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Simple use of varargs&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Varargs&lt;/em&gt; deklaruje się za pomocą &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; dodanym do typu. I np. &lt;code class=&quot;highlighter-rouge&quot;&gt;sum(1, 2, 3)&lt;/code&gt; zwróci 6, a &lt;code class=&quot;highlighter-rouge&quot;&gt;sum()&lt;/code&gt; zero. Myślę, że działanie jest dosyć jasne.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Varargs&lt;/em&gt; nie nadają się jednak w przypadku, gdy chcemy mieć przynajmniej jeden 
argument, np. chcąc policzyć minimum. Musielibyśmy wtedy dodać specjalne sprawdzenie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The WRONG way to use varargs to pass one or more arguments!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Too few arguments&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jednak to rozwiązanie nie jest dobre:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sprawdzenie odbywa się dopiero w runtime, więc nie widać błedu podczas pisania kodu&lt;/li&gt;
  &lt;li&gt;jest brzydkie i nadmiarowe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jest na to dużo lepszy sposób - zadeklarować metodę przyjmującą pierwszy argument, a jako drugi argument podać &lt;em&gt;varargs&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// The right way to use varargs to pass one or more arguments&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W super ekstremalnych warunkach (w których prawdopodobnie nigdy nie będziesz), gdzie liczy się wydajność i wiemy, że np. 90% wywołań ma mniej niż 3 argumenty, możemy użyć kilku przeciążeń metody, aby uniknąć nadmiarowego tworzenia tablic:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Statyczne fabryki dla &lt;code class=&quot;highlighter-rouge&quot;&gt;EnumSet&lt;/code&gt; w standardowej bibliotece używają tej techniki.&lt;/p&gt;

&lt;h1 id=&quot;zwracaj-puste-kolekcje-nie-nulle&quot;&gt;Zwracaj puste kolekcje, nie nulle&lt;/h1&gt;

&lt;p&gt;Czasem można spotkać metody podobne do tej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Returns null to indicate an empty collection. Don't do this!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @return a list containing all of the cheeses in the shop,
 *     or null if no cheeses are available for purchase.
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie ma powodu, aby traktować puste kolekcje w specjalny sposób i zwracać null, jeśli są puste. Na pewno nie jest to też dobra praktyka. Dodatkowo zmusza to klienta, by obsłużyć tę sytuację w miejscach, gdzie normalnie by tego nie robił:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheeses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheesdes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STILTON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Jolly good, just the thing.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Argumenty typu, że powinny być preferowane nulle, ponieważ wtedy nie alokujemy pamięci na pusty kontener, nie mają sensu w dzisiejszych aplikacjach. Martwienie się wydajnością na tym poziomie jest zbędną przedwczesną optymalizacją, która w 95% nie przyniesie żadnej korzyści.&lt;/p&gt;

&lt;p&gt;Ponadto używając niemutowalnych pustych kolekcji typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptyList&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptySet&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.emptyMap&lt;/code&gt; całkowicie eliminujemy ten problem, bo wtedy reużywamy jedną i tą samą pustą kolekcję.&lt;/p&gt;

&lt;p&gt;Podobnie wygląda sytuacja dla tablic, nie powinno się zwracać nulli zamiast pustej tablicy.&lt;/p&gt;

&lt;p&gt;Lekcja z tego tematu jest jasna - nie zwracaj nulli zamiast pustych kolekcji czy tablic. Pogarsza to tylko kod klienta i nie ma żadnych sensownych korzyści.&lt;/p&gt;

&lt;h1 id=&quot;zwracanie-optional&quot;&gt;Zwracanie Optional&lt;/h1&gt;

&lt;p&gt;Przed Java 8 mieliśmy dwa sposoby na pisanie metod, które nie mogłyby zwrócić danej wartości w określonych warunkach. Można było albo rzucić wyjątkiem, albo po prostu zwrócić null (jeśli zwracany typ nie był prymitywem). Żaden z nich nie był idealnym sposobem. Wyjątki powinny być stosowane tylko w wyjątkowych sytuacjach, a do tego rzucanie wyjątku jest nieco kosztowne, bo wraz z wyjątkiem tworzony jest cały stack trace.&lt;/p&gt;

&lt;p&gt;Zwracanie nulla nie ma tych wad, jednak tak samo wymaga od klienta specjalnego obsłużenia, które czasem nie jest oczywiste.&lt;/p&gt;

&lt;p&gt;Od Javy 8 jest też trzeci wbudowany sposób - klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;. Reprezentuje ona niemutowalny kontener, który może przetrzymywać pojedynczą referencję do obiektu (która nie jest nullem) lub nic, czyli może być pusty.&lt;/p&gt;

&lt;p&gt;Więc gdy metoda zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, ale jak pod jakimiś warunkami może nie być w stanie zwrócić &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, to wtedy może zadeklarować zwracany typ jako &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Metoda, która zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; jest nieco bardziej elastyczna i łatwiejsza w użyciu niż rzucanie i obsługa wyjątku czy zwracanie nulla + obsługa. Czasem może nie być oczywsite, że metoda może zwrócić null, zwłaszcza gdy nie mamy dostępu do dokumentacji lub jej po prostu nie ma. Dzięki &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; mamy tę informację bezpośrednio w API i jest jasne, że metoda może nie być w stanie zwrócić tej wartości.&lt;/p&gt;

&lt;p&gt;Przykładowe użycie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Returns maximum value in collection as an Optional&amp;lt;E&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        
    &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jak widać, jest to całkiem proste. Bez &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; metoda mogłaby rzucić &lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;, gdyby kolekcja z parametru była pusta, jednak wtedy kod klienta nie byłby tak czysty w użyciu, bo wymagałby boilerplatu try catch.&lt;/p&gt;

&lt;p&gt;Jest też wariant, który może przyjąć null: &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional.ofNullable(value)&lt;/code&gt; i zwraca pusty &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt;, jeśli został podany null.&lt;/p&gt;

&lt;p&gt;Użycie &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; można spotkać w standardowej blibliotece np.  używając streamów.&lt;/p&gt;

&lt;p&gt;Czy zawsze jednak warto stosować &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; czy rzucenia wyjątkiem?&lt;/p&gt;

&lt;p&gt;Optionale są podobne w założeniu co rzucanie &lt;em&gt;checked exception&lt;/em&gt; - oba jasno informują klienta API, że wartość może być nie zwrócona, jednak te drugie wymagają od niego więcej boilerplate-u.&lt;/p&gt;

&lt;p&gt;Optionale oferują nam do dyspozycji kilka pomocnych metod, które pozwalają pisać zwięzły kod. Np.: możemy podać domyślną wartość:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Using an optional to provide a chosen default value&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastWordInLexicon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No words...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;lub rzucić wyjątkiem:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Using an optional to throw a chosen exception&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Toy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myToy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseThrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;TemperTantrumException:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;note&quot;&gt;Zauważ, że podawana jest referencja do konstruktora, więc wyjątek nie zostanie utworzony, dopóki nie zajdzie taka potrzeba.&lt;/p&gt;

&lt;p&gt;Inne przykłady to &lt;code class=&quot;highlighter-rouge&quot;&gt;orElseGet&lt;/code&gt;, który przyjmuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;, by uniknąć kosztu tworzenia obiektu zbyt wcześnie oraz &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;W Javie 9 dodano także &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresentOrElse&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Warto znać te inne metody, bo czasem można zwięźle zastąpić nimi zwykłe sprawdzania &lt;code class=&quot;highlighter-rouge&quot;&gt;isPresent&lt;/code&gt;. Dla przykładu metoda, która pokazuje ID parenta danego procesu lub N/A, jeśli go nie ma:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent PID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isPresent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parentProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;N/A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A tak wygląda to samo z wykorzystaniem metody &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent PID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;N/A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optionalów nie powinno się używać do opakowywania kolekcji, podobnie jak w przypadku zwracania null, gdy są puste.&lt;/p&gt;

&lt;p&gt;Odpowiadając wreszcie na pytanie - Optionale są bardzo dobrą alternatywą dla nulli i rzucania wyjątków, gdy metoda nie może zwrócić danej wartości. Jedyna opcja gdzie mógłoby to być nieodpowiednie, to w sytuacjach, gdzie wydajność jest krytyczna i takie mikro optymalizacje mają sens, ale w 95% przypadkach tak nie jest.&lt;/p&gt;

&lt;h1 id=&quot;dokumentacja&quot;&gt;Dokumentacja&lt;/h1&gt;

&lt;p&gt;Jeśli publiczne API ma być użyteczne, powinno być udokumentowane, dlatego zwieńczeniem naszej pracy powinna być dokumentacja.&lt;/p&gt;

&lt;p&gt;W Javie mamy narzędzie Javadoc, które ułatwia nam to, generując dokumentację API automatycznie z kodu źródłowego.&lt;/p&gt;

&lt;p&gt;Konwencje dokumentacji nie są częścią języka, jednak są swojego rodzaju API, które każdy programista powinien znać. Te konwencje są opisane na stronie &lt;a href=&quot;https://www.oracle.com/technetwork/articles/java/index-137868.html&quot;&gt;How to Write Doc Comments&lt;/a&gt; jednak nie była ona updatowana od Javy 4 i nie ma opisanych kilku tagów dodanych w Javie:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;9 - {@index}&lt;/li&gt;
  &lt;li&gt;8 - {@implSpec}&lt;/li&gt;
  &lt;li&gt;5 - {@literal}, {@code}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Publiczne API powinno mieć udokumentowane co najmniej każdą publiczną klasę, interfejs, konstruktor, metodę i pole.&lt;/p&gt;

&lt;p&gt;Resztę szczegółów z tego tematu pozwoliłem sobie pominąć - jakby ktoś chciał zobaczyć przykłady i wprowadzenie w temat to odsyłam do &lt;a href=&quot;https://www.baeldung.com/javadoc&quot;&gt;Introduction to Javadoc&lt;/a&gt;&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii, w której tworzę wpisy na podstawie wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Bloch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 53, 54, 55, 56 z rozdziału 8: Methods Item 49: Check parameters for validity Item 50: Make defensive copies when needed Item 51: Design method signatures carefully Item 52: Use overloading judiciously Item 53: Use varargs judiciously Item 54: Return empty collections or arrays, not nulls Item 55: Return optionals judiciously Item 56: Write doc comments for all exposed API elements Używanie varargs Co to są varargs? Jest to po prostu zmienna ilość parametrów zadeklarowana jako jeden argument. Można to porównać do tablicy - może przechowywać zero lub więcej argumentów. Pod spodem działa to tak że tworzona jest tablica wielkości liczby podanych elementów, a następnie te wartości są w niej umieszczane i do metody przekazywana jest tablica. Przykładowe proste użycie varargs: // Simple use of varargs static int sum(int... args) { int sum = 0; for (int arg : args) sum += arg; return sum; } Varargs deklaruje się za pomocą ... dodanym do typu. I np. sum(1, 2, 3) zwróci 6, a sum() zero. Myślę, że działanie jest dosyć jasne. Varargs nie nadają się jednak w przypadku, gdy chcemy mieć przynajmniej jeden argument, np. chcąc policzyć minimum. Musielibyśmy wtedy dodać specjalne sprawdzenie: // The WRONG way to use varargs to pass one or more arguments! static int min(int... args) { if (args.length == 0) throw new IllegalArgumentException(&quot;Too few arguments&quot;); int min = args[0]; for (int i = 1; i &amp;lt; args.length; i++) if (args[i] &amp;lt; min) min = args[i]; return min; } Jednak to rozwiązanie nie jest dobre: sprawdzenie odbywa się dopiero w runtime, więc nie widać błedu podczas pisania kodu jest brzydkie i nadmiarowe. Jest na to dużo lepszy sposób - zadeklarować metodę przyjmującą pierwszy argument, a jako drugi argument podać varargs: // The right way to use varargs to pass one or more arguments static int min(int firstArg, int... remainingArgs) { int min = firstArg; for (int arg : remainingArgs) if (arg &amp;lt; min) min = arg; return min; } W super ekstremalnych warunkach (w których prawdopodobnie nigdy nie będziesz), gdzie liczy się wydajność i wiemy, że np. 90% wywołań ma mniej niż 3 argumenty, możemy użyć kilku przeciążeń metody, aby uniknąć nadmiarowego tworzenia tablic: public void foo() { } public void foo(int a1) { } public void foo(int a1, int a2) { } public void foo(int a1, int a2, int a3) { } public void foo(int a1, int a2, int a3, int... rest) { } Statyczne fabryki dla EnumSet w standardowej bibliotece używają tej techniki. Zwracaj puste kolekcje, nie nulle Czasem można spotkać metody podobne do tej: // Returns null to indicate an empty collection. Don't do this! private final List&amp;lt;Cheese&amp;gt; cheesesInStock = ...; /** * @return a list containing all of the cheeses in the shop, * or null if no cheeses are available for purchase. */ public List&amp;lt;Cheese&amp;gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList&amp;lt;&amp;gt;(cheesesInStock); } Nie ma powodu, aby traktować puste kolekcje w specjalny sposób i zwracać null, jeśli są puste. Na pewno nie jest to też dobra praktyka. Dodatkowo zmusza to klienta, by obsłużyć tę sytuację w miejscach, gdzie normalnie by tego nie robił: List&amp;lt;Cheese&amp;gt; cheeses = shop.getCheeses(); if (cheesdes != null &amp;amp;&amp;amp; cheeses.contains(Cheese.STILTON)) System.out.println(&quot;Jolly good, just the thing.&quot;); Argumenty typu, że powinny być preferowane nulle, ponieważ wtedy nie alokujemy pamięci na pusty kontener, nie mają sensu w dzisiejszych aplikacjach. Martwienie się wydajnością na tym poziomie jest zbędną przedwczesną optymalizacją, która w 95% nie przyniesie żadnej korzyści. Ponadto używając niemutowalnych pustych kolekcji typu Collections.emptyList, Collections.emptySet czy Collections.emptyMap całkowicie eliminujemy ten problem, bo wtedy reużywamy jedną i tą samą pustą kolekcję. Podobnie wygląda sytuacja dla tablic, nie powinno się zwracać nulli zamiast pustej tablicy. Lekcja z tego tematu jest jasna - nie zwracaj nulli zamiast pustych kolekcji czy tablic. Pogarsza to tylko kod klienta i nie ma żadnych sensownych korzyści. Zwracanie Optional Przed Java 8 mieliśmy dwa sposoby na pisanie metod, które nie mogłyby zwrócić danej wartości w określonych warunkach. Można było albo rzucić wyjątkiem, albo po prostu zwrócić null (jeśli zwracany typ nie był prymitywem). Żaden z nich nie był idealnym sposobem. Wyjątki powinny być stosowane tylko w wyjątkowych sytuacjach, a do tego rzucanie wyjątku jest nieco kosztowne, bo wraz z wyjątkiem tworzony jest cały stack trace. Zwracanie nulla nie ma tych wad, jednak tak samo wymaga od klienta specjalnego obsłużenia, które czasem nie jest oczywiste. Od Javy 8 jest też trzeci wbudowany sposób - klasa Optional&amp;lt;T&amp;gt;. Reprezentuje ona niemutowalny kontener, który może przetrzymywać pojedynczą referencję do obiektu (która nie jest nullem) lub nic, czyli może być pusty. Więc gdy metoda zwraca T, ale jak pod jakimiś warunkami może nie być w stanie zwrócić T, to wtedy może zadeklarować zwracany typ jako Optional&amp;lt;T&amp;gt;. Metoda, która zwraca Optional jest nieco bardziej elastyczna i łatwiejsza w użyciu niż rzucanie i obsługa wyjątku czy zwracanie nulla + obsługa. Czasem może nie być oczywsite, że metoda może zwrócić null, zwłaszcza gdy nie mamy dostępu do dokumentacji lub jej po prostu nie ma. Dzięki Optional mamy tę informację bezpośrednio w API i jest jasne, że metoda może nie być w stanie zwrócić tej wartości. Przykładowe użycie: // Returns maximum value in collection as an Optional&amp;lt;E&amp;gt; public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; Optional&amp;lt;E&amp;gt; max(Collection&amp;lt;E&amp;gt; c) { if (c.isEmpty()) return Optional.empty(); E result = null; for (E e : c) if (result == null || e.compareTo(result) &amp;gt; 0) result = Objects.requireNonNull(e); return Optional.of(result); } Jak widać, jest to całkiem proste. Bez Optional metoda mogłaby rzucić IllegalArgumentException, gdyby kolekcja z parametru była pusta, jednak wtedy kod klienta nie byłby tak czysty w użyciu, bo wymagałby boilerplatu try catch. Jest też wariant, który może przyjąć null: Optional.ofNullable(value) i zwraca pusty Optional, jeśli został podany null. Użycie Optional można spotkać w standardowej blibliotece np. używając streamów. Czy zawsze jednak warto stosować Optional zamiast null czy rzucenia wyjątkiem? Optionale są podobne w założeniu co rzucanie checked exception - oba jasno informują klienta API, że wartość może być nie zwrócona, jednak te drugie wymagają od niego więcej boilerplate-u. Optionale oferują nam do dyspozycji kilka pomocnych metod, które pozwalają pisać zwięzły kod. Np.: możemy podać domyślną wartość: // Using an optional to provide a chosen default value String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;); lub rzucić wyjątkiem: // Using an optional to throw a chosen exception Toy myToy = max(toys).orElseThrow(TemperTantrumException::new); Zauważ, że podawana jest referencja do konstruktora, więc wyjątek nie zostanie utworzony, dopóki nie zajdzie taka potrzeba. Inne przykłady to orElseGet, który przyjmuje Supplier&amp;lt;T&amp;gt;, by uniknąć kosztu tworzenia obiektu zbyt wcześnie oraz filter, map, flatMap czy ifPresent. W Javie 9 dodano także or i ifPresentOrElse. Warto znać te inne metody, bo czasem można zwięźle zastąpić nimi zwykłe sprawdzania isPresent. Dla przykładu metoda, która pokazuje ID parenta danego procesu lub N/A, jeśli go nie ma: Optional&amp;lt;ProcessHandle&amp;gt; parentProcess = ph.parent(); System.out.println(&quot;Parent PID: &quot; + (parentProcess.isPresent() ? String.valueOf(parentProcess.get().pid()) : &quot;N/A&quot;)); A tak wygląda to samo z wykorzystaniem metody map: System.out.println(&quot;Parent PID: &quot; + ph.parent().map(h -&amp;gt; String.valueOf(h.pid())).orElse(&quot;N/A&quot;)); Optionalów nie powinno się używać do opakowywania kolekcji, podobnie jak w przypadku zwracania null, gdy są puste. Odpowiadając wreszcie na pytanie - Optionale są bardzo dobrą alternatywą dla nulli i rzucania wyjątków, gdy metoda nie może zwrócić danej wartości. Jedyna opcja gdzie mógłoby to być nieodpowiednie, to w sytuacjach, gdzie wydajność jest krytyczna i takie mikro optymalizacje mają sens, ale w 95% przypadkach tak nie jest. Dokumentacja Jeśli publiczne API ma być użyteczne, powinno być udokumentowane, dlatego zwieńczeniem naszej pracy powinna być dokumentacja. W Javie mamy narzędzie Javadoc, które ułatwia nam to, generując dokumentację API automatycznie z kodu źródłowego. Konwencje dokumentacji nie są częścią języka, jednak są swojego rodzaju API, które każdy programista powinien znać. Te konwencje są opisane na stronie How to Write Doc Comments jednak nie była ona updatowana od Javy 4 i nie ma opisanych kilku tagów dodanych w Javie: 9 - {@index} 8 - {@implSpec} 5 - {@literal}, {@code} Publiczne API powinno mieć udokumentowane co najmniej każdą publiczną klasę, interfejs, konstruktor, metodę i pole. Resztę szczegółów z tego tematu pozwoliłem sobie pominąć - jakby ktoś chciał zobaczyć przykłady i wprowadzenie w temat to odsyłam do Introduction to Javadoc</summary></entry></feed>