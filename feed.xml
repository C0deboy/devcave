<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://devcave.pl/feed.xml" rel="self" type="application/atom+xml" /><link href="https://devcave.pl/" rel="alternate" type="text/html" /><updated>2018-07-28T20:48:30+02:00</updated><id>https://devcave.pl/</id><title type="html">devcave.pl</title><subtitle>Devcave - blog programisty na tematy związane z branżą IT, a szczególnie z programowaniem. Pracuję głownie z językami Java i Javascript, ale na blogu nie zabraknie tematów ogólnych ;)</subtitle><entry><title type="html">Gettery i settery</title><link href="https://devcave.pl/effective-java/gettery-i-settery" rel="alternate" type="text/html" title="Gettery i settery" /><published>2018-07-28T10:00:00+02:00</published><updated>2018-07-28T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/gettery-i-settery</id><content type="html" xml:base="https://devcave.pl/effective-java/gettery-i-settery">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 16&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Classes and Interfaces&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/minimalizuj-dostepnosc-enkapsulacja&quot;&gt;Item 15: Minimize the accessibility of classes and members
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/gettery-i-settery&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 16: In public classes, use accessor methods, not public fields
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 17: Minimize mutability
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 18: Favor composition over inheritance
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 19: Design and document for inheritance or else prohibit it
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 20: Prefer interfaces to abstract classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 21: Design interfaces for posterity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 22: Use interfaces only to define types
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 23: Prefer class hierarchies to tagged classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 24: Favor static member classes over nonstatic
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 25: Limit source files to a single top-level class
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Czasem możemy potrzebować klasy, która jest niczym więcej niż zbiorem powiązanych pól. Na przykład:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Degenerate classes like this should not be public!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Przez to, że pola tej klasy są używane bezpośrednio (&lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;/code&gt; to porzucamy wszystkie zalety płynące z enkapsulacji, o której była mowa w poprzednim wpisie.&lt;/p&gt;

&lt;p&gt;W takich klasach nie możemy zmienić reprezentacji bez zmieniania API, nie możemy wymusić jej poprawności ani wykonać żadnej innej akcji, podczas gdy pole jest pobierane.&lt;/p&gt;

&lt;p&gt;Niektórzy powiedzieliby, że takie klasy zawsze powinny być zamienione na klasy z prywatnymi polami i getterami/setterami:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Encapsulation of data by accessor methods and mutators&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I rzeczywiście mają rację, jeśli mowa o publicznych klasach. Jeśli klasa jest dostępna poza pakietem, to warto zadeklarować jej pola jako prywatne i udostępnić &lt;em&gt;gettery&lt;/em&gt;. Dzięki temu mamy elastyczność, która pozwala na zmianę wewnętrznej reprezentacji klasy bez zmieniania API. Kiedy pola używane są bezpośrednio, to zmiana taka jest niemożliwa, bo uszkodzi to wszystkie klasy, które jej używają.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jednak trzeba dobrze rozważyć czy na pewno chcemy udostępniać &lt;em&gt;settery&lt;/em&gt;. Minimalizowanie zmienności (ang. &lt;em&gt;mutability&lt;/em&gt;) klasy jest preferowaną praktyką.&lt;/strong&gt; O tym będzie następny wpis.&lt;/p&gt;

&lt;p&gt;Jednak jeśli klasa jest &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; lub wewnętrzną prywatną klasą, to właściwie nie jest to nic złego. Takie podejście nie generuje zbędnego wizualnego zaśmiecenia kodu metodami dostępowymi i dużo łatwiej i czytelniej używa się taką klasę.&lt;/p&gt;

&lt;p&gt;Jeśli zajdzie potrzeba zmiany reprezentacji klasy to zmiany są ograniczone tylko do pakietu, w którym jest używana lub w przypadku wewnętrznej klasy - do klasy, która ją zawiera.&lt;/p&gt;

&lt;p&gt;W większości wypadków wystawianie publicznie pól klasy nie jest dobrym pomysłem, ale jest to mniej szkodliwe, jeśli są to pola &lt;em&gt;immutable&lt;/em&gt;. Nadal nie możemy zmienić reprezentacji bez zmieniania API, nadal nie możemy wykonać żadnej dodatkowej akcji, ale możemy wymusić tworzenie prawidłowych klas. Na przykład ta klasa zapewnia, że każda instancja będzie poprawną reprezentacją czasu:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Public class with exposed immutable fields - questionable&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOURS_PER_DAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MINUTES_PER_HOUR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOURS_PER_DAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hour: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MINUTES_PER_HOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Min: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hour&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;minute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Remainder omitted&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nie znaczy to jednak, że od tej pory powinniśmy wszystko deklarować jako &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; i wybierać w naszym IDE &lt;em&gt;“Genarate Getters and Setters”&lt;/em&gt; dla każdego pola. Nie, absolutnie nie. Gettery i settery są lepsze niż bezpośredni dostęp do pól, ale jeśli jest taka możliwość, to nie powinniśmy używać ani jednego, ani drugiego. Tzn. nie powinniśmy wystawiać na świat pola, które jest szczegółem implementacyjnym. Na tym polega enkapsulacja.&lt;/p&gt;

&lt;p&gt;Jeśli chodzi o kwestię nazewniczą getterów i setterów, to nie zawsze powinny to być nazwy zaczynające się od &lt;em&gt;set&lt;/em&gt; lub &lt;em&gt;get&lt;/em&gt;. Jeśli istnieje inne słowo, które lepiej pasuje do wykonywanej czynności, to powinniśmy je użyć. Jest to bardziej zgodne z OOP. Dla przykładu:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ball&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ma dużo więcej sensu niż:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setBall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ball&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;No może z wyjątkiem, gdy klasa (w tym przypadku &lt;code class=&quot;highlighter-rouge&quot;&gt;Dog&lt;/code&gt;) jest tylko rekordem w bazie danych.&lt;/p&gt;

&lt;p&gt;Podsumowując, publiczne klasy nigdy nie powinny wystawiać &lt;strong&gt;publicznych zmiennych&lt;/strong&gt; pól. Mniej szkodliwe jest wystawianie niezmiennych pól, jednak nadal problematyczne - w niektórych przypadkach. Jeśli rzeczywiście potrzebujemy taką klasę, to wtedy najlepiej ograniczyć taką klasę do pakietu lub jeśli jest możliwe - do jednej klasy.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 16 z rozdziału: Classes and Interfaces Item 15: Minimize the accessibility of classes and members Item 16: In public classes, use accessor methods, not public fields Item 17: Minimize mutability Item 18: Favor composition over inheritance Item 19: Design and document for inheritance or else prohibit it Item 20: Prefer interfaces to abstract classes Item 21: Design interfaces for posterity Item 22: Use interfaces only to define types Item 23: Prefer class hierarchies to tagged classes Item 24: Favor static member classes over nonstatic Item 25: Limit source files to a single top-level class</summary></entry><entry><title type="html">Minimalizowanie dostępności</title><link href="https://devcave.pl/effective-java/minimalizuj-dostepnosc-enkapsulacja" rel="alternate" type="text/html" title="Minimalizowanie dostępności" /><published>2018-07-21T10:00:00+02:00</published><updated>2018-07-21T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/minimalizuj-dostepnosc-enkapsulacja</id><content type="html" xml:base="https://devcave.pl/effective-java/minimalizuj-dostepnosc-enkapsulacja">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 15&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Classes and Interfaces&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/minimalizuj-dostepnosc-enkapsulacja&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 15: Minimize the accessibility of classes and members
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/gettery-i-settery&quot;&gt;Item 16: In public classes, use accessor methods, not public fields
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 17: Minimize mutability
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 18: Favor composition over inheritance
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 19: Design and document for inheritance or else prohibit it
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 20: Prefer interfaces to abstract classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 21: Design interfaces for posterity
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 22: Use interfaces only to define types
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 23: Prefer class hierarchies to tagged classes
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 24: Favor static member classes over nonstatic
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a herf=&quot;&quot; class=&quot;disabled&quot;&gt;Item 25: Limit source files to a single top-level class
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Enkapsulacja jest jednym z ważniejszych czynników określających dobry design i jego podstawą.&lt;/p&gt;

&lt;h1 id=&quot;czym-jest-enkapsulacja&quot;&gt;Czym jest enkapsulacja?&lt;/h1&gt;

&lt;p&gt;Enkapsulacja polega na ukrywaniu szczegółów implementacyjnych przed innymi komponentami. Dobrze zaprojektowane komponenty ukrywają je wszystkie, jasno rozdzielając jego API od jego implementacji. Wtedy, komponenty komunikują się przez swoje API i nie są świadome, co wykonywane jest pod spodem.&lt;/p&gt;

&lt;p&gt;Enkapsulacja jest ważne z wielu powodów, jednak najważniejszym z nich jest fakt, że rozdziela komponenty, które tworzą system. Sprawia to że mogą być rozwijane, testowane, optymalizowane, analizowane i modyfikowane w izolacji.
Dzięki temu możemy pracować na nich równolegle, bez ryzyka uszkodzenia innych komponentów, co znacznie przyspiesza proces rozwijania systemu.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Best practice: ograniczaj dostęp do klas, interfejsów i elementów klasy najbardziej jak jest to możliwe.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cytując dokumentację:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use the most restrictive access level that makes sense for a particular member. Use private unless you have a good reason not to.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mowa tu o mechanizmie &lt;em&gt;access control&lt;/em&gt;, dzięki któremu określamy dostępność do klas, interfejsów i elementów klasy na podstawie modyfikatorów dostępu, którymi są oznaczane.&lt;/p&gt;

&lt;h1 id=&quot;modyfikatory-dostępu&quot;&gt;Modyfikatory dostępu&lt;/h1&gt;

&lt;p&gt;W Javie dostępne mamy cztery modyfikatory dostępu: &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt;, który jest domyślny, tzn. wtedy kiedy nie podamy żadnego (&lt;strong&gt;z wyjątkiem elementów zadeklarowanych w interfejsie, które domyślnie są publiczne&lt;/strong&gt;).&lt;/p&gt;

&lt;h2 id=&quot;dla-klas-i-interfejsów&quot;&gt;Dla klas i interfejsów&lt;/h2&gt;

&lt;p&gt;Dla top-level (niewewnętrznych) klas i interfejsów możliwe są tylko dwa - &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; jest wtedy, gdy nie oznaczymy klasy modyfikatorem &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;, czyli domyślnie. Jeśli jest możliwość, żeby klasa lub interfejs był &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; to powinno tak się stać. Dzięki temu nasza klasa lub interfejs nie widnieje w API, a jest częścią implementacji i możemy ją dowolnie modyfikować, zastąpić czy nawet usunąć, bez uszkadzania istniejących klientów. Z kolei, jeśli nasza klasa lub interfejs jest publiczny, to jesteśmy zobowiązani wspierać go do końca, by zachować kompatybilność wsteczną.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Obecnie większość IDE przy tworzeniu nowych klas domyślnie wstawia modyfikator dostępu &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;. Warto to zmienić na &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; (czyli bez modyfikatora dostępu) i w miarę potrzeby deklarować &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; tylko wtedy kiedy jest to rzeczywiście potrzebne.&lt;/p&gt;

&lt;p&gt;Jeśli klasa lub interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; jest używany tylko przez jedną klasą, to możemy rozważyć przeniesienie jej do tej klasy jako wewnętrznej klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;private static&lt;/code&gt;. Redukuje to dostępność tej klasy w innych klasach w obrębie tego samego pakietu. Będzie o tym mowa w &lt;em&gt;Item 24&lt;/em&gt;. Jednak zdecydowanie ważniejsze jest redukowanie dostępu klas publicznych, jako że klasy &lt;em&gt;top-level&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; i tak są już częścią implementacji, a nie publicznego API.&lt;/p&gt;

&lt;h2 id=&quot;dla-elementów-klasy&quot;&gt;Dla elementów klasy&lt;/h2&gt;
&lt;p&gt;Poprzez “elementy klasy” mam na myśli pola, metody, wewnętrzne klasy i interfejsy. Mamy dla nich dostępne wszystkie cztery modyfikatory dostępu:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;private&lt;/strong&gt; — element jest dostępny tylko w klasie, w której jest zadeklarowany.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;package-private&lt;/strong&gt; — element jest dostępny z każdej klasy w obrębie tego samego pakietu.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;protected&lt;/strong&gt; — element jest również dostępny w klasach w obrębie tego samego pakietu oraz dodatkowo w podklasach klasy, w której jest zadeklarowany.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;public&lt;/strong&gt; — element jest dostępny wszędzie.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Łatwiej to zobrazować na podstawie tabelki:&lt;/p&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;

  &lt;table class=&quot;table table-condensed table-bordered&quot;&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Modyfikator&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Klasa&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Pakiet&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Podklasa&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Wszędzie&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;brak&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;Dla przykładu rozważmy, że mamy taką strukturę klas:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/effective-java/classes-access.png&quot; alt=&quot;modyfikatory przykład&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wtedy pola klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Alpha&lt;/code&gt; oznaczone danym modyfikatorem będą miały taką widoczność w innych klasach:&lt;/p&gt;

&lt;div class=&quot;table-wrapper&quot;&gt;

  &lt;table class=&quot;table table-condensed table-bordered&quot;&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Modyfikator&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Alpha&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Beta&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;AlphaSub&lt;/th&gt;
        &lt;th style=&quot;text-align: left&quot;&gt;Gamma&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;brak&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;TAK&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
        &lt;td style=&quot;text-align: left&quot;&gt;NIE&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;Duży przeskok w dostępności jest z &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; na &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;. Element oznaczony jako &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; jest już częścią API i musi być wspierany wiecznie. Jednak potrzeba ich stosowania powinna być sporadyczna.&lt;/p&gt;

&lt;p&gt;Czasem modyfikatory dostępu są z góry wymuszone, na przykład, kiedy nadpisujemy metodę z nadklasy, to nie może ona mieć bardziej restrykcyjnego dostępu niż w nadklasie. Również wtedy, gdy klasa implementuje interfejs, to implementowane metody będą zawsze &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pola klasy nie powinny być publiczne&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jeśli pole nie jest zadeklarowane jako &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; lub jest referencją do mutowalnego obiektu, to deklarując takie pole jako &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; umożliwiamy jego modyfikację lub podmianę. Ponadto podczas takiej modyfikacji możemy wykonać na nim jakąkolwiek akcję, więc &lt;strong&gt;klasy z publicznymi modyfikowalnymi polami nie są &lt;em&gt;thread safe&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To samo tyczy się statycznych pól, z wyjątkiem stałych, które są integralną częścią abstrakcji klasy. Takie pola zazwyczaj upubliczniamy za pomocą &lt;code class=&quot;highlighter-rouge&quot;&gt;public static final&lt;/code&gt; i przyjęło się je nazywać za pomocą drukowanych wyrazów rozdzielonymi podłogą, np.:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DAYS_IN_WEEK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Ważne jest to, żeby takie pola zawierały tylko prymitywy lub referencje do obiektów &lt;em&gt;immutable&lt;/em&gt;. Referencje do obiektów &lt;em&gt;mutable&lt;/em&gt; mają wszystkie wady pola niezadeklarowanego jako &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;. Referencja nie może być zmieniona, ale sam obiekt już może.&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;Tablice niezerowej długości są zawsze &lt;em&gt;mutable&lt;/em&gt;, więc tablice nigdy nie powinny być deklarowane jako &lt;code class=&quot;highlighter-rouge&quot;&gt;public static final&lt;/code&gt; ani klasa nie powinna udostępniać do niej &lt;em&gt;gettera&lt;/em&gt; w przypadku kiedy jest &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;.  W przeciwnym wypadku klient będzie mógł zmodyfikować taką tablicę.&lt;/p&gt;

&lt;p&gt;Możemy rozwiązać ten problem zwracając w getterze kopię tablicy.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRIVATE_VALUES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRIVATE_VALUES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jednak jeśli obiekt typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Thing&lt;/code&gt; jest &lt;em&gt;mutable&lt;/em&gt; to będzie trzeba wykonać &lt;em&gt;deep copy&lt;/em&gt;. Temat klonowania omawiałem dwa wpisy wcześniej.&lt;/p&gt;

&lt;p&gt;Podsumowując, powinniśmy redukować dostępność komponentów najbardziej jak to możliwe. Publiczne API nie powinno być zanieczyszczone klasami będącymi szczegółami implementacyjnymi innych klas. Publiczne klasy nie powinny mieć publicznych pól, z wyjątkiem stałych, które powinny być &lt;em&gt;immuatable&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;moduły-java-9&quot;&gt;Moduły Java 9&lt;/h1&gt;

&lt;p&gt;Java 9 daje nam nową abstrakcję ponad pakietami — moduły. Analogicznie tak jak pakiet jest zbiorem powiązanych klas, tak moduły są zbiorem powiązanych pakietów.&lt;/p&gt;

&lt;p&gt;System modułów daje nam to nowe możliwości określania dostępności danych komponentów. Domyślnie żaden pakiet w module nie jest publiczny (dostępność wewnątrz modułu się nie zmienia). Jeśli chcemy, aby dany pakiet był dostępny w innym module, to musimy o tym wyraźnie poinformować w &lt;em&gt;module descriptor&lt;/em&gt;. Jest to plik o nazwie &lt;span class=&quot;file&quot;&gt;module-info.java&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Jego struktura wygląda mniej więcej tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dzięki temu możemy udostępniać klasy między pakietami wewnątrz modułów bez udostępniania ich całemu światu.&lt;/p&gt;

&lt;p&gt;System modułów nie jest jeszcze szeroko używany w Javie i ciężko powiedzieć czy kiedykolwiek tak będzie.&lt;/p&gt;

&lt;p&gt;Jeśli chciałbyś więcej się dowiedzieć o tym mechanizmie, to polecam &lt;a href=&quot;http://www.baeldung.com/java-9-modularity&quot;&gt;baeldung.com/java-9-modularity&lt;/a&gt;.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 15 z rozdziału: Classes and Interfaces Item 15: Minimize the accessibility of classes and members Item 16: In public classes, use accessor methods, not public fields Item 17: Minimize mutability Item 18: Favor composition over inheritance Item 19: Design and document for inheritance or else prohibit it Item 20: Prefer interfaces to abstract classes Item 21: Design interfaces for posterity Item 22: Use interfaces only to define types Item 23: Prefer class hierarchies to tagged classes Item 24: Favor static member classes over nonstatic Item 25: Limit source files to a single top-level class</summary></entry><entry><title type="html">Interfejs Comparable i Comparator</title><link href="https://devcave.pl/effective-java/interfejs-comparable" rel="alternate" type="text/html" title="Interfejs Comparable i Comparator" /><published>2018-07-14T10:00:00+02:00</published><updated>2018-07-14T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/interfejs-comparable</id><content type="html" xml:base="https://devcave.pl/effective-java/interfejs-comparable">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 14&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Methods Common to All Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;Item 10: Obey the general contract when overriding equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-hashcode&quot;&gt;Item 11: Always override hashCode when you override equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-toString&quot;&gt;Item 12: Always override toString
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-clone&quot;&gt;Item 13: Override clone judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/interfejs-comparable&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 14: Consider implementing Comparable
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Do porównywania obiektów w Javie służy metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt;. W przeciwieństwie do innych metod w tym rozdziale serii nie jest zadeklarowana w &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;. Jest to osobna metoda zdefiniowana w interfejsie &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;comparable&quot;&gt;Comparable&lt;/h1&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Poza sprawdzaniem równości obiektów, tak jak w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, oferuje jeszcze określanie, czy jest mniejszy lub większy niż inny obiekt. Implementując interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; określamy domyślny porządek (ang. &lt;strong&gt;natural ordering&lt;/strong&gt;) klasy, według którego m.in będzie układana w kolekcjach i na którym polega wiele algorytmów w Javie.&lt;/p&gt;

&lt;p&gt;Aby posortować tablicę obiektów, które implementują &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;, wystarczy wywołać:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Podobnie łatwo można wykonać sortowanie kolekcji, wyciągnąć z nich skrajne wartości czy używać takich obiektów w automatycznie sortujących się kolekcjach.&lt;/p&gt;

&lt;p&gt;Dla przykładu, polegając na tym, że &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; implementuje interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Foo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Bar&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Andy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Shop&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//Shop&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//Andy&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//Collection for binary search needs to be sorted&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//[Andy, Bar, Foo, Shop]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Foo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//2&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Możemy też łatwo stworzyć zbiór posortowanych automatycznie wyrazów z wyeliminowanymi duplikatami, używając &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alphabeticalWordList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//[Andy, Bar, Foo, Shop]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli dodamy jakikolwiek string do tej kolekcji, to automatycznie zajmie swoje miejsce w alfabetycznym porządku.&lt;/p&gt;

&lt;p&gt;Jak widać dzięki zaimplementowaniu &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;, pozwalamy naszej klasie współdziałać z wieloma generycznymi algorytmami i kolekcjami, które polegają na tym interfejsie. Dostajemy wiele możliwości z małym nakładem pracy.&lt;/p&gt;

&lt;p&gt;Wszystkie klasy reprezentujące wartości i enumy w Javie implementują ten interfejs.&lt;/p&gt;

&lt;p&gt;Specyfikacja metody &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; jest następująca:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object. Throws &lt;code class=&quot;highlighter-rouge&quot;&gt;ClassCastException&lt;/code&gt; if the specified object’s type prevents it from being compared to this object.&lt;/p&gt;

  &lt;p&gt;In the following description, the notation &lt;code class=&quot;highlighter-rouge&quot;&gt;sgn&lt;/code&gt;(&lt;em&gt;expression&lt;/em&gt;) designates the mathematical  &lt;em&gt;signum&lt;/em&gt;  function, which is defined to return &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;1, 0, or 1, according to whether the value of  &lt;em&gt;expression&lt;/em&gt;  is negative, zero, or positive.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;The implementor must ensure that &lt;code class=&quot;highlighter-rouge&quot;&gt;sgn(x.compareTo(y)) == -sgn(y. compareTo(x))&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;. (This implies that &lt;code class=&quot;highlighter-rouge&quot;&gt;x.compareTo(y)&lt;/code&gt; must throw an exception if and only if &lt;code class=&quot;highlighter-rouge&quot;&gt;y.compareTo(x)&lt;/code&gt; throws an exception.)&lt;/li&gt;
    &lt;li&gt;The implementor must also ensure that the relation is transitive: &lt;code class=&quot;highlighter-rouge&quot;&gt;(x. compareTo(y) &amp;gt; 0 &amp;amp;&amp;amp; y.compareTo(z) &amp;gt; 0)&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;x.compareTo(z) &amp;gt; 0&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;Finally, the implementor must ensure that &lt;code class=&quot;highlighter-rouge&quot;&gt;x.compareTo(y) == 0&lt;/code&gt; implies that &lt;code class=&quot;highlighter-rouge&quot;&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/code&gt;, for all &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;It is strongly recommended, but not required, that &lt;code class=&quot;highlighter-rouge&quot;&gt;(x.compareTo(y) == 0) == (x.equals(y))&lt;/code&gt;. Generally speaking, any class that implements the &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; interface and violates this condition should clearly indicate this fact. The recommended language is “Note: This class has a natural ordering that is inconsistent with &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;.”&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Może się to wydawać skomplikowane, jednak wcale takie nie jest. W przeciwieństwie do metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; nie musi działać między różnymi typami. Jeśli jest taka sytuacja, to może spokojnie rzucić &lt;code class=&quot;highlighter-rouge&quot;&gt;ClassCastException&lt;/code&gt;. I zazwyczaj tak jest. Jednak jest dozwolone porównywanie międzyklasowe, które zazwyczaj jest zdefiniowane w interfejsie, który implementują klasy porównywane.&lt;/p&gt;

&lt;p&gt;W skrócie specyfikacja mówi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jeśli pierwszy jest mniejszy od drugiego, to drugi musi być większy od pierwszego i na odwrót.&lt;/li&gt;
  &lt;li&gt;Jeśli pierwszy obiekt jest równy drugiemu, to drugi musi być równy pierwszemu.&lt;/li&gt;
  &lt;li&gt;Jeśli pierwszy obiekt jest większy niż drugi i drugi jest większy niż trzeci, to pierwszy musi być większy niż trzeci.&lt;/li&gt;
  &lt;li&gt;Wszystkie obiekty, które przy porównywaniu są równe, muszą zwrócić ten sam rezultat, kiedy są porównywane z jakimkolwiek innym obiektem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ostatni warunek w specyfikacji &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; jest raczej sugestią niż wymaganiem. Mówi, że test na równość obiektów powinien zwracać taki sam wynik jak metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;. Wtedy mówimy, że &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; jest spójne z &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, a jeśli jest inaczej — niespójne.&lt;/p&gt;

&lt;p&gt;Dla przykładu metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt; jest niespójna z &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;. Jeśli stworzymy pusty &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; i dodamy do niego &lt;code class=&quot;highlighter-rouge&quot;&gt;new BigDecimal(&quot;1.0&quot;)&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;new BigDecimal(&quot;1.00&quot;)&lt;/code&gt;, to w secie znajdą się obydwa. Dzieje się tak, gdyż obie instancje &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt; nie są równe, jeśli sprawdzamy je za pomocą &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;. Z kolei, jeśli powtórzymy to samo dla &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;, który polega na &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt;, to wtedy będziemy mieć tylko jedną wartość, bo według &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; są równe. Dlatego &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; jest niespójne z &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; w tym przypadku.&lt;/p&gt;

&lt;p&gt;Sprawdzając równość obiektów, mamy ten sam problem, co w przypadku &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, który &lt;a href=&quot;/effective-java/metoda-equals#problem-z-dziedziczeniem&quot;&gt;omówiłem w poście&lt;/a&gt; na temat tej metody. Tutaj możemy zastosować to samo obejście, stosując zasadę &lt;a href=&quot;/notatnik-juniora/zasady-projektowania-kodu#composition-over-inheritance&quot;&gt;composition over inheritance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tak samo jak zła implementacja &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; lub jej brak może popsuć klasy, które zależą od hashowania, tak samo niepoprawna implementacja &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; może spowodować nieprawidłowe działanie klas, które polegają na porównywaniu obiektów. Należą do tego m.in. kolekcje &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt; i klasy &lt;em&gt;utillity&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays&lt;/code&gt;, które zawierają algorytmy sortowania i wyszukiwania.&lt;/p&gt;

&lt;p&gt;W przeciwieństwie do &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; nie musimy sprawdzać typów ani castować, a to dlatego, że interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; jest parametryzowany.&lt;/p&gt;

&lt;p&gt;Porównując prymitywy, powinniśmy używać do tego metody &lt;code class=&quot;highlighter-rouge&quot;&gt;compare&lt;/code&gt; z ich wrapperów, np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Double.compare&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Float.compare&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.compare&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Jeśli porównujemy kilka znaczących pól, oczywiście powinniśmy zacząć od najbardziej znaczącego. Jeśli wynik jest różny od zera, wystarczy zwrócić wynik pierwszego porównania. Np. dla klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; z poprzednich wpisów mogłaby wyglądać tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Multiple-field Comparable with primitive fields&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Porównując pola z referencjami do obiektów, wywołujemy rekursywnie &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; tych obiektów, a jeśli nie implementują &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; lub chcemy użyć niestandardowego porównywania, to możemy użyć klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;comparator&quot;&gt;Comparator&lt;/h1&gt;

&lt;p&gt;Możemy napisać swój własny lub wykorzystać już istniejące. Np. klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; ma &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;, który ignoruje wielkość liter:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CASE_INSENSITIVE_ORDER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Od Javy 8, interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt; dostał zestaw metod, które umożliwiają jego płynne tworzenie. Jest to dużo bardziej zwięzłe rozwiązanie. Używając do tego statycznych importów, dostajemy całkiem przejrzysty kod. Odpowiednik powyższej metody &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; z wykorzystanie comparatora wygląda tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Comparable with comparator construction methods&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMPARATOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;comparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenComparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenComparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMPARATOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ta implementacja tworzy komparator w czasie inicjalizacji klasy. Pierwsza statyczna metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;comparingInt&lt;/code&gt; przyjmuje lambde, która wyciąga &lt;code class=&quot;highlighter-rouge&quot;&gt;areaCode&lt;/code&gt; (klucz) i zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&amp;lt;PhoneNumber&amp;gt;&lt;/code&gt;, który porządkuje numery według ich &lt;code class=&quot;highlighter-rouge&quot;&gt;areaCode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Oczywiście metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo&lt;/code&gt; zachowuje się identycznie jak w wariancie napisanym ręcznie. Jeśli dwa numery mają taki sam &lt;code class=&quot;highlighter-rouge&quot;&gt;areaCode&lt;/code&gt;, to dopiero wtedy kolejne porównania z &lt;code class=&quot;highlighter-rouge&quot;&gt;thenComparingInt&lt;/code&gt; zostaną wywołane.&lt;/p&gt;

&lt;p&gt;Warto zwrócić uwagę, że pierwsza lambda określa typ parametru (&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber pn&lt;/code&gt;), bo w takiej sytuacji inferencja typów w Javie nie jest na tyle inteligenta, żeby to wywnioskować, więc musimy jej z tym pomóc.&lt;/p&gt;

&lt;p&gt;Jeśli klasa udostępnia gettery do pól, to można użyć referencji do nich, co jest nieco bardziej czytelnym rozwiązaniem:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMPARATOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;comparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;PhoneNumber:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getAreaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenComparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;PhoneNumber:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPrefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenComparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;PhoneNumber:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Analogiczne metody do &lt;code class=&quot;highlighter-rouge&quot;&gt;comparingInt&lt;/code&gt; znajdziemy dla innych prymitywów jak &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;. Wersje dla &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; mogą zostać użyte dla mniejszych typów danych jak &lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt; - tak jak w przykładzie z &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt;. I podobnie, wersja dla &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; może być użyta dla &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dla obiektów mamy odpowiadającą statyczną metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;comparing&lt;/code&gt;, która ma dwa warianty:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Podajemy tylko klucz i używany jest jego domyślny porządek (ang. natural ordering).&lt;/li&gt;
  &lt;li&gt;Podajemy zarówno klucz, jak i komparator, który będzie używany na tym kluczu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I trzy warianty dla &lt;code class=&quot;highlighter-rouge&quot;&gt;thenComparing&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Podajemy tylko komparator, który określa drugorzędną kolejność.&lt;/li&gt;
  &lt;li&gt;Podajemy kolejny klucz i używamy jego domyślnego porządek (ang. natural ordering).&lt;/li&gt;
  &lt;li&gt;Podajemy zarówno kolejny klucz, jak i komparator, który będzie używany na tym kluczu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Takie płynne budowanie komparatora często przydaję się przy streamach. Jeśli na przykład chcemy posortować elementy, to możemy to zrobić w całkiem dynamiczny sposób:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ranking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;comparing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;RankingEntry:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chcemy odwróconą kolejność? Wystarczy dodać &lt;code class=&quot;highlighter-rouge&quot;&gt;reversed()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ranking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;comparing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;RankingEntry:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reversed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W rezultacie dostaniemy posortowane elementy według pola &lt;code class=&quot;highlighter-rouge&quot;&gt;score&lt;/code&gt; z klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;RankingEntry&lt;/code&gt;, które są w liście rankingowej &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;RankingEntry&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podsumowując, implementując interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt; uaktywnimy sporo użytecznych funkcji i kolekcji, z którymi nasza klasa może współpracować. Dzięki komparatorom możemy tworzyć różne niestandardowe porównywania obiektów, a od Javy 8, płynne API do dynamicznego tworzenia komparatorów z wykorzystaniem lambd znacznie ułatwia sprawę. Jeśli nasza klasa będzie miała jeden standard porównywania obiektów, to warto użyć interfejsu &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;, który określa domyślny porządek (ang. &lt;strong&gt;natural ordering&lt;/strong&gt;). Jeśli z kolei przewidujemy, że nasza klasa będzie porównywana na kilka sposobów lub chcemy użyć innego zamiast domyślnego, to przydadzą się komparatory.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 14 z rozdziału: Methods Common to All Objects Item 10: Obey the general contract when overriding equals Item 11: Always override hashCode when you override equals Item 12: Always override toString Item 13: Override clone judiciously Item 14: Consider implementing Comparable</summary></entry><entry><title type="html">Klonowanie w Javie</title><link href="https://devcave.pl/effective-java/metoda-clone" rel="alternate" type="text/html" title="Klonowanie w Javie" /><published>2018-07-07T10:00:00+02:00</published><updated>2018-07-07T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/metoda-clone</id><content type="html" xml:base="https://devcave.pl/effective-java/metoda-clone">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 13&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Methods Common to All Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;Item 10: Obey the general contract when overriding equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-hashcode&quot;&gt;Item 11: Always override hashCode when you override equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-toString&quot;&gt;Item 12: Always override toString
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/metoda-clone&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 13: Override clone judiciously
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejs-comparable&quot;&gt;Item 14: Consider implementing Comparable
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;interfejs-cloneable&quot;&gt;Interfejs Cloneable&lt;/h1&gt;

&lt;p&gt;W Javie do klonowania został stworzony interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;, którym oznacza się klasę, dla której ma być dozwolone klonowanie. Jednak nie jest to idealne rozwiązanie. Interfejs ten nie zawiera żadnych metod, a metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; jest &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt;, więc nie możemy wywołać metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;, tylko dlatego, że klasa implementuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Interfejs ten zmienia tylko zachowanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; w &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; - jeśli klasa implementuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt; to zwracana jest kopia pole po polu obiektu, a w przeciwnym wypadku rzucany jest wyjątek &lt;code class=&quot;highlighter-rouge&quot;&gt;CloneNotSupportedException&lt;/code&gt;. Jest to trochę nietypowe wykorzystanie interfejsu — zamiast mówić klientowi co klasa może zrobić, zmienia zachowanie metody nadklasy i do niczego więcej się nie przyda.&lt;/p&gt;

&lt;p&gt;Z interfejsu to nie wynika, ale klasa implementująca interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt; powinna dostarczyć poprawnie funkcjonująca metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Kontrakt dla metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; w specyfikacji jest następujący:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Creates and returns a copy of this object. The precise meaning of
“copy” may depend on the class of the object. The general intent is
that, for any object &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, the expression&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;will be &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, and the expression&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;will be &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, but these are not absolute requirements. While it is
typically the case that&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;will be &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, this is not an absolute requirement.&lt;/p&gt;

  &lt;p&gt;By convention, the object returned by this method should be obtained
by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt;. If a class and all of its superclasses
(except &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;) obey this convention, it will be the case that&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;By convention, the returned object should be independent of the object
being cloned. To achieve this independence, it may be necessary to
modify one or more fields of the object returned by &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt;
before returning it.&lt;/p&gt;

  &lt;p&gt;This mechanism is vaguely similar to constructor chaining, except that
it isn’t enforced: if a class’s &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; method returns an instance
that is &lt;em&gt;not&lt;/em&gt; obtained by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt; but by calling a
constructor, the compiler won’t complain, but if a subclass of that
class calls &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt;, the resulting object will have the wrong
class, preventing the subclass from &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; method from working
properly. If a class that overrides &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; is final, this
convention may be safely ignored, as there are no subclasses to worry
about. But if a final class has a &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; method that does not
invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt;, there is no reason for the class to implement
&lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;, as it doesn’t rely on the behavior of &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;’s clone
implementation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Czyli z grubsza — nie mamy zdefiniowanej definicji kopii ani co możemy z nią robić — wszystko zależy od nas.&lt;/p&gt;

&lt;p&gt;W rezultacie mamy dosyć niestabilny i niebezpieczny mechanizm, który pod spodem tworzy obiekty bez wywoływania konstruktora.&lt;/p&gt;

&lt;h1 id=&quot;implementacja&quot;&gt;Implementacja&lt;/h1&gt;

&lt;p&gt;Najpierw musimy wywołać &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt;. Dostaniemy w pełni funkcjonalną kopię obiektu. Wszystkie wartości będą identyczne jak w oryginale i co ważne — będą to referencje do tych samych obiektów. Jeśli obiekt zawiera tylko prymitywy i referencje do niezmiennych obiektów, to w zasadzie dostaniemy to, co chcemy i nie musimy robić nic więcej niż:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Clone method for class with no references to mutable state&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassWithNoMutableReferences&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassWithNoMutableReferences&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloneNotSupportedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Can't happen&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Z kolei, jeśli obiekt sam w sobie jest niezmienny, to po co nam by było klonowanie? Klasy niezmienne z pewnością nie powinny udostępniać metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;, bo jedynie co by to robiło, to zachęcało do zbędnego klonowania.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Wywołanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone&lt;/code&gt; jest opakowane w blok &lt;code class=&quot;highlighter-rouge&quot;&gt;try-catch&lt;/code&gt;, ponieważ &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; deklaruje, że jego metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; rzuca wyjątek &lt;code class=&quot;highlighter-rouge&quot;&gt;CloneNotSupportedException&lt;/code&gt;, który jest wyjątkiem typu &lt;em&gt;checked&lt;/em&gt;. Jeśli nasz obiekt implementuje interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt; to wiemy, że wyjątek ten nigdy nie zostanie rzucony. Ten zbędny &lt;em&gt;boilerpalte&lt;/em&gt; wskazuje na to, że &lt;code class=&quot;highlighter-rouge&quot;&gt;CloneNotSupportedException&lt;/code&gt; powinno być wyjątkiem typu &lt;em&gt;unchecked&lt;/em&gt;, no ale tak się nie stało.&lt;/p&gt;

&lt;p&gt;Jeśli jednak nasz obiekt ma referencje do zmiennych obiektów, to taka prosta implementacja metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; jest zgubna. Weźmy na przykład implementację klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt; ze wcześniejszych wpisów:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ensureCapacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EmptyStackException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Eliminate obsolete reference&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Ensure space for at least one more element.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ensureCapacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli będziemy chcieli dać możliwość klonowania takiej klasie i w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; wywołamy tylko &lt;code class=&quot;highlighter-rouge&quot;&gt;super.clone()&lt;/code&gt;, to sklonowana instancja &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt; będzie miała odpowiednie pole &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; (bo jest to prymityw), ale tablica &lt;code class=&quot;highlighter-rouge&quot;&gt;elements&lt;/code&gt; będzie referencją do tej samej tablicy co w oryginale. &lt;strong&gt;W rezultacie modyfikując kopię, będziemy modyfikować też oryginał.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;W takiej sytuacji, aby dostać odizolowaną kopię od oryginału, musimy ręcznie wywołać metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; na tablicy:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Clone method for class with references to mutable state&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloneNotSupportedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I tak z każdym polem tego typu.&lt;/p&gt;

&lt;p&gt;Problemem w tym rozwiązaniu jest to, że wtedy pole (w tym przypadku &lt;code class=&quot;highlighter-rouge&quot;&gt;elements&lt;/code&gt;) nie może być zadeklarowane jako &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Kolejny problem pojawia się wtedy, kiedy elementy w tablicy są zmienne. Jeśli zmienimy stan jednego z obiektu będącego w tablicy, to zawartość obu tablic zostanie zmodyfikowana. To dlatego, że obie zawierają referencje do tych samych obiektów, a metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; wykonuje płytkie kopiowanie (shallow copy).&lt;/p&gt;

&lt;p&gt;Żeby uzyskać w pełni odizolowane od siebie obiekty wraz ze wszystkimi obiektami wewnątrz, musimy wykonać głębokie kopiowanie (deep copy) - utworzyć nową tablicę i skopiować do niej wszystkie elementy listy.&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; w &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; nie jest zsynchronizowana, więc w środowisku wielowątkowym będzie trzeba napisać jej zsynchronizowany odpowiednik.&lt;/p&gt;

&lt;p&gt;Jednak czy ten mało zgrabny mechanizm klonowania jest niezbędny? Jeśli rozszerzasz klasę, która już implementuje &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt; to tak, nie ma innego wyboru. W innym przypadku warto skorzystać z alternatywnych rozwiązań.&lt;/p&gt;

&lt;h1 id=&quot;copy-constructor&quot;&gt;Copy constructor&lt;/h1&gt;
&lt;p&gt;Jest to konstruktor, który przyjmuje jako argument klasę zawierającą ten konstruktor, np.:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Copy constructor&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;copy-factory&quot;&gt;Copy factory&lt;/h1&gt;

&lt;p&gt;Jest to analogiczny odpowiednik konstruktora w postaci &lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;static method factory&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Copy factory&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Następnie ręcznie tworzymy nowy obiekt, kopiując wszystkie pola:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Oba te rozwiązania mają wiele korzyści w stosunku do &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nie polegamy na nieznanym mechanizmie tworzenia obiektów, który nie używa konstruktora i mamy pełną kontrolę nad tym procesem.&lt;/li&gt;
  &lt;li&gt;nie jesteśmy uzależnieni od żadnych słabo zdefiniowanych konwencji&lt;/li&gt;
  &lt;li&gt;nie ma konfliktu z polami &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;nie rzucają zbędnych wyjątków&lt;/li&gt;
  &lt;li&gt;nie wymagają castowania&lt;/li&gt;
  &lt;li&gt;nie skażamy klasy i wszystkich podklas interfejsem, który jest tylko &lt;em&gt;markerem&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ponadto w tych rozwiązaniach argument może być interfejsem implementowanym przez tę klasę. Na przykład implementacje kolekcji w Javie udostępniają konstruktor, który ma argument typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;. Są to tak zwane &lt;em&gt;conversion constructors&lt;/em&gt; i &lt;em&gt;conversion factories&lt;/em&gt;, które pozwalają klientowi wybrać typ kopii, zamiast wymuszać oryginalny typ. Na przykład mamy &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet s&lt;/code&gt; i możemy łatwo skopiować go jako &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt; używając &lt;code class=&quot;highlighter-rouge&quot;&gt;new TreeSet&amp;lt;&amp;gt;(s)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podsumowując, te dwa rozwiązania są zdecydowanie lepsze od skażania klasy interfejsem &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;, więc powinny być preferowanym sposobem implementowania klonowania w Javie. Jedynym wyjątkiem od tej zasady są tablicę, gdzie powinniśmy używać metody &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;, bo jest to najszybszy sposób klonowania tablic.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 13 z rozdziału: Methods Common to All Objects Item 10: Obey the general contract when overriding equals Item 11: Always override hashCode when you override equals Item 12: Always override toString Item 13: Override clone judiciously Item 14: Consider implementing Comparable</summary></entry><entry><title type="html">Metoda toString</title><link href="https://devcave.pl/effective-java/metoda-toString" rel="alternate" type="text/html" title="Metoda toString" /><published>2018-06-30T10:00:00+02:00</published><updated>2018-06-30T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/metoda-toString</id><content type="html" xml:base="https://devcave.pl/effective-java/metoda-toString">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 12&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Methods Common to All Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;Item 10: Obey the general contract when overriding equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-hashcode&quot;&gt;Item 11: Always override hashCode when you override equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/metoda-toString&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 12: Always override toString
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-clone&quot;&gt;Item 13: Override clone judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejs-comparable&quot;&gt;Item 14: Consider implementing Comparable
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; jest zdefiniowana w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;, dzięki czemu wszystkie obiekty dostają jej domyślną implementację. Służy do zwracania tekstowej, czytelnej dla człowieka reprezentacji obiektu. Jednak domyślna implementacja nie jest zbyt użyteczna, bo wygląda tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'@'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toHexString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;czyli zwracana jest nazwa klasy + @ + heksadecymalna reprezentacja &lt;em&gt;hash code&lt;/em&gt;, np. &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber@163b91&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podobnie jak w przypadku metod &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; jej zachowanie najczęściej powinniśmy nadpisać, aby zrobić z niej użytek.&lt;/p&gt;

&lt;p&gt;Dla przykładu z klasy reprezentującej numer telefonu chcielibyśmy, żeby było zwracane coś typu &lt;code class=&quot;highlighter-rouge&quot;&gt;707-867-530&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nie jest to tak ważna metoda, jak &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, jednak &lt;strong&gt;dostarczanie dobrej implementacji metody &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; sprawia, że klasy są przyjemniejsze w użyciu, a aplikacja łatwiejsza do debugowania&lt;/strong&gt;, nawet jeśli ty sam bezpośrednio z niej nie korzystasz.&lt;/p&gt;

&lt;p&gt;Dzieje się tak dlatego, że metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; jest automatycznie wywoływana w wielu miejscach:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gdy podajemy obiekt do &lt;code class=&quot;highlighter-rouge&quot;&gt;println&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;podczas konkatenacji stringów&lt;/li&gt;
  &lt;li&gt;w komunikatach o asercjach podczas testowania&lt;/li&gt;
  &lt;li&gt;podczas podglądania obiektu w debugerze.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Często przydaję się to do logowania informacji. Jeśli dostarczymy dobrą implementację &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; dla przykładowej klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt;, to wystarczy podać obiekt:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failed to connect to &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Nie trzeba za każdym razem ręcznie wyciągać i sklejać numeru z klasy.&lt;/p&gt;

&lt;p&gt;Również podglądając kolekcje zobaczymy jej ładną reprezentację. Chyba jasne jest, że wolelibyśmy zobaczyć &lt;code class=&quot;highlighter-rouge&quot;&gt;{Jenny=707-867-5309}&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;{Jenny=PhoneNumber@163b91}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Oczywiście są przypadki gdzie metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; nie ma sensu. Na przykład w statycznej klasie typu &lt;em&gt;utility&lt;/em&gt;. Również nie ma potrzeby definiowania jej w klasach typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Enum&lt;/code&gt;, bo dostarcza ją już standardowa implementacja.&lt;/p&gt;

&lt;p&gt;W przypadku klas abstrakcyjnych może czasem się przydać, jeśli podklasy mają wspólną reprezentację. Na przykład, większość konkretnych klas kolekcji dziedziczy metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; z odpowiednich klas abstrakcyjnych kolekcji.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; powinna zawierać wszystkie kluczowe informacje zawarte w obiekcie&lt;/strong&gt;. Nie chcielibyśmy, żeby coś było pominięte i na przykład podczas testowania zobaczyć taki błąd:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Assertion failure: expected {abc, 123}, but was {abc, 123}.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Ważnym aspektem metody &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;, który trzeba rozważyć to to, czy będzie miała określony stały format i będzie on określony w dokumentacji.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;W przypadku klas, które reprezentują jakąś wartość, np. &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt;, warto to zrobić. Dzięki temu będziemy mieli jednoznaczną, czytelną dla człowieka reprezentację obiektu, która może posłużyć do odtworzenia obiektu ze stringa. Wtedy taką reprezentację możemy z łatwością używać jako &lt;em&gt;input/output&lt;/em&gt; w czytelnych dla człowieka plikach przechowujących dane (np. pliki CSV). Wtedy warto też udostępnić &lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;static method factory&lt;/a&gt; lub konstruktor, który umożliwi na podstawie stringa stworzyć ten obiekt.&lt;/p&gt;

&lt;p&gt;Takie podejście zastosowano w wielu klasach z podstawowej biblioteki Javy, np. &lt;code class=&quot;highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BigDecimal&lt;/code&gt; i większość innych klas opakowujących prymitywy.&lt;/p&gt;

&lt;p&gt;Dla przykładu klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt; udostępnia konstruktor z argumentem typu &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Z drugiej strony, jeśli zdecydujemy się na stały format i nasza klasa będzie szeroko używana (np. jeśli jest częścią publicznej biblioteki), to jesteśmy z nim uwięzieni do końca życia i nie mamy opcji go zmienić. Jeśli w kolejnej aktualizacji zmienilibyśmy format, to popsulibyśmy każdą aplikację, która używała naszej klasy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dlatego warto jasno udokumentować nasze intencje wcześniej.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ponadto &lt;strong&gt;do wszystkich informacji zawartych w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; powinny być udostępnione gettery&lt;/strong&gt;, aby nie wymuszać parsowania stringa, które jest dodatkową, zbędną i mało wydajną operacją. Również takie rozwiązanie jest narażone na błędy, bo jeśli zmieni się format, to parsowanie przestanie działać. Jeśli dane są widoczne w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;, to znaczy, że powinniśmy mieć do nich metody dostępowe.&lt;/p&gt;

&lt;p&gt;Jak w pozostałych przypadkach, IDE oraz biblioteka Lombok również pozwalają na automatyczne wygenerowanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;, jednak nie we wszystkich przypadkach jest ona odpowiednia. Np. przykładowy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; składa się z co najmniej 3 pól i automatycznie wygenerowana metoda w postaci pole=wartość, pole=wartość nie jest preferowana, bo numer ma swoją standardową reprezentację typu 707-867-530. Jednak wygenerowana metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt; i tak jest lepsza niż ta, którą dostajemy domyślnie.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 12 z rozdziału: Methods Common to All Objects Item 10: Obey the general contract when overriding equals Item 11: Always override hashCode when you override equals Item 12: Always override toString Item 13: Override clone judiciously Item 14: Consider implementing Comparable</summary></entry><entry><title type="html">Metoda hashCode</title><link href="https://devcave.pl/effective-java/metoda-hashcode" rel="alternate" type="text/html" title="Metoda hashCode" /><published>2018-06-23T10:00:00+02:00</published><updated>2018-06-23T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/metoda-hashcode</id><content type="html" xml:base="https://devcave.pl/effective-java/metoda-hashcode">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 11&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Methods Common to All Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;Item 10: Obey the general contract when overriding equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/metoda-hashcode&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 11: Always override hashCode when you override equals
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-toString&quot;&gt;Item 12: Always override toString
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-clone&quot;&gt;Item 13: Override clone judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejs-comparable&quot;&gt;Item 14: Consider implementing Comparable
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;co-to-jest-hashcode&quot;&gt;Co to jest hashCode&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; to metoda, która powinna zawierać algorytm hashujący, który na podstawie danych obiektu wylicza liczbę całkowitą (hash), reprezentujący ten obiekt.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hash&lt;/em&gt; jest wykorzystywany pod spodem przez niektóre kolekcje (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;) do przechowywania referencji do obiektów, co w rezultacie daję bardzo wydajną kolekcję o stałym czasie dostępu do danych. Ten czas w dużej mierze zależy od wydajności naszego algorytmu hashującego, więc warto na to zwracać uwagę.&lt;/p&gt;

&lt;p&gt;W poprzednim &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;poście&lt;/a&gt; podkreśliłem, że &lt;strong&gt;niezbędne jest nadpisywanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; za każdym razem, gdy nadpisujesz &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jest to spowodowane tym, że między nimi zawarty jest nienaruszalny kontrakt. Jeśli zostanie naruszony, to obiekty nie będą działać prawidłowo w kolekcjach takich jak &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; czy w każdej innej klasie, która polega na &lt;em&gt;hash&lt;/em&gt; kodach obiektów.&lt;/p&gt;

&lt;p&gt;Kontrakt dla samej metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; jest następujący:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jeśli informacje używane w &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; nie są modyfikowane, to metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; musi zawsze konsekwentnie zwracać tę samą wartość.&lt;/li&gt;
  &lt;li&gt;Jeśli metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; stwierdzi, że dwa obiekty są równe, to wywoływanie &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; na obu tych obiektach musi zwrócić tę samą wartość.&lt;/li&gt;
  &lt;li&gt;Jeśli dwa obiekty nie są równe według metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, to &lt;strong&gt;nie&lt;/strong&gt; jest wymagane, aby &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; na każdym z obiektów zwracał różne wyniki. Jednak jest to pożądane, bo ma to znaczenie wydajnościowe dla hash tablic (jeśli będą dwa takie same hashe, to będzie musiała wywołać metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, aby rozróżnić obiekty).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Szczególnie ważny jest 2 punkt.&lt;/strong&gt; - jeśli nie nadpiszemy również metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; wraz z &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; to według metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; dwa obiekty są sobie równe, a dla metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; te same obiekty nie mają nic ze sobą wspólnego. Zwracane są dwa różne numery, zamiast dwóch identycznych.&lt;/p&gt;

&lt;p&gt;Teraz dla przykładu załóżmy, że będziemy chcieli użyć &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; z poprzedniego postu jako klucze w &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; bez definiowania &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;707&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;867&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5309&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Jenny&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wydawałoby się, że wywołując:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;707&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;867&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5309&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dostaniemy &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Jenny&quot;&lt;/code&gt;, ale tak się nie stanie, bo dostaniemy &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;. Zauważ, że są używane dwie instancje &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt;. Są one identyczne, ale z punktu widzenia &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, na którym bazuje &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, nie są.&lt;/p&gt;

&lt;p&gt;Napisanie poprawnej implementacji &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; dla &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; rozwiązuje problem.&lt;/p&gt;

&lt;h1 id=&quot;jak-poprawnie-napisać-metodę-hashcode&quot;&gt;Jak poprawnie napisać metodę hashCode?&lt;/h1&gt;

&lt;p&gt;Podobnie jak pisałem we wcześniejszym poście, jeśli nie potrzebujesz specyficznej implementacji, to możesz zdać się na automatyczne wygenerowanie tej metody przez IDE czy odpowiednią bibliotekę jak np. Lombok.&lt;/p&gt;

&lt;p&gt;Dobra metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; powinna dawać różne hash kody, dla różnych obiektów. Osiągniecie tego może być trudne, ale możemy uzyskać przybliżony efekt.&lt;/p&gt;

&lt;p&gt;Od Javy 7, mamy klasę &lt;code class=&quot;highlighter-rouge&quot;&gt;Objects&lt;/code&gt;, która posiada statyczną metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;. Przyjmuje ona dowolną liczbę argumentów i zwraca dla nich &lt;em&gt;hash code&lt;/em&gt;. Pozwala to napisać implementację metody hashującej w jednej linijce. Dla przykładowej klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; będzie wyglądać tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// One-line hashCode method - mediocre performance&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jej jakość jest podobna do tych napisanych ręcznie według przepisu, który zaraz przedstawię, jednak jest delikatnie mniej wydajna, jeśli częstotliwość jej wywołań jest wysoka i używane są wartości prymitywne. Spowodowane jest to tym, że pod spodem używana jest tablica, a prymitywy muszą być autoboxowane. Jednak w większości wypadków, gdy wydajność nie ma dla nas aż takiego znaczenia, możemy śmiało tego używać.&lt;/p&gt;

&lt;p&gt;Jeśli zdecydujemy się na ręczne napisanie implementacji metody &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, to tu jest przepis:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zadeklaruj zmienną &lt;code class=&quot;highlighter-rouge&quot;&gt;int result&lt;/code&gt; i zainicjuj ją hash kodem &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; dla pierwszego znaczącego pola.&lt;/li&gt;
  &lt;li&gt;Dla &lt;strong&gt;każdego&lt;/strong&gt; pozostałego znaczącego pola &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;, &lt;strong&gt;które jest używane w metodzie &lt;em&gt;equals&lt;/em&gt;&lt;/strong&gt; :
    &lt;ol&gt;
      &lt;li&gt;Przelicz hash code&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;:
        &lt;ul&gt;
          &lt;li&gt;Jeśli jest to prymityw używaj &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;, gdzie&lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt; to odpowiednia klasa opakowująca. Np. dla int - &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
          &lt;li&gt;Jeśli pole jest obiektem i w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; jest wywoływane &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; tego obiektu, to analogicznie powinniśmy wywołaś &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; tego obiektu.&lt;/li&gt;
          &lt;li&gt;Jeśli pole jest &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; to użyj&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; .&lt;/li&gt;
          &lt;li&gt;Jeśli pole jest tablicą, to przelicz hash code dla każdego znaczącego elementu. Jeśli tablica nie ma znaczących pól, użyj stałej (ale nie&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;). Jeśli wszystkie elementy są znaczące użyj &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Połącz hash code&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;policzony w kroku 2.1 z &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; w następujący sposób &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Zwróć &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Upewnij się, że obiekty równe sobie mają takie sam &lt;em&gt;hash code&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mnożenie z kroku 2.2 zapewnia, że kolejność pól ma znaczenie. Jeśli pominęlibyśmy to, to np. w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; wszystkie anagramy miałyby identyczny &lt;em&gt;hash code&lt;/em&gt;.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Dlaczego 31? Bo jest to nieparzysta liczba pierwsza. Gdyby była to liczba parzysta i mnożenie skutkowałoby przepełnieniem, to informacje zostałyby utracone, bo mnożenie przez 2 jest tym samym, co przesuniecie bitowe w lewo. (np. &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;/code&gt;). Używanie liczby pierwszej jest mniej uzasadnione, ale to już tradycja. Fajną właściwością liczby 31 jest to, że mnożenie może być zastąpione przez przesunięcie bitowe w lewo i odejmowanie &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;/code&gt;, co ma wpływ na wydajność. Tego typu optymalizacje są robione automatycznie przez nowoczesne wirtualne maszyny.&lt;/p&gt;

&lt;p&gt;Aplikując powyższe wskazówki metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; będzie wyglądać tak:&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Typical hashCode method&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;W tej prostej implementacji jasno widać, że identyczne klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneNumber&lt;/code&gt; będą miały identyczny &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ten przepis na &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; daje nam całkiem dobre funkcje hashujące, odpowiednie dla większości użyć, jednak nie są one perfekcyjne. Jeśli będziesz mieć naprawdę dobry powód, żeby twoje hash code-y miały jeszcze mniejsze prawdopodobieństwo na kolizję, zobacz rozwiązanie od &lt;a href=&quot;https://memberservices.informit.com/my_account/webedition/9780134998060/html/epub/oebps/html/ref.xhtml#rGuava&quot;&gt;Guava&lt;/a&gt; -&lt;code class=&quot;highlighter-rouge&quot;&gt;com.google.common.hash.Hashing&lt;/code&gt;.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Jeśli klasa jest &lt;em&gt;immutable&lt;/em&gt;, można rozważyć cachowanie hash kodu w zmiennej, zamiast przeliczać go za każdym razem od nowa.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 11 z rozdziału: Methods Common to All Objects Item 10: Obey the general contract when overriding equals Item 11: Always override hashCode when you override equals Item 12: Always override toString Item 13: Override clone judiciously Item 14: Consider implementing Comparable</summary></entry><entry><title type="html">Metoda equals</title><link href="https://devcave.pl/effective-java/metoda-equals" rel="alternate" type="text/html" title="Metoda equals" /><published>2018-06-16T10:00:00+02:00</published><updated>2018-06-16T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/metoda-equals</id><content type="html" xml:base="https://devcave.pl/effective-java/metoda-equals">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 10&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Methods Common to All Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/metoda-equals&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 10: Obey the general contract when overriding equals
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-hashcode&quot;&gt;Item 11: Always override hashCode when you override equals
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-toString&quot;&gt;Item 12: Always override toString
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/metoda-clone&quot;&gt;Item 13: Override clone judiciously
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/interfejs-comparable&quot;&gt;Item 14: Consider implementing Comparable
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;W tym rozdziale serii omawiane będą wszystkie metody &lt;em&gt;non-final&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;, oprócz &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize&lt;/code&gt; - o której była już mowa w poście &lt;a href=&quot;/effective-java/unikaj-finalizerow-i-cleanerow&quot;&gt;unikaj finalizerow i cleanerów&lt;/a&gt;) z klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;, która jest klasą bazową każdej klasy (każda klasa domyślnie rozszerza tę klasę).&lt;/p&gt;

&lt;p&gt;Metody te mają swoje domyślne zachowania, ale najczęściej, jeśli ich potrzebujemy, to je nadpisujemy. &lt;strong&gt;Prawidłowa implementacja tych metod jest szczególnie ważna, bo wiele innych klas na nich polega, dlatego warto poświęcić im chwilę.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;W tym wpisie zajmiemy się metodą &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;, która, jak sama nazwa wskazuje, służy do określania czy dany obiekt jest równy innemu, według określonych przez nas warunków.&lt;/p&gt;

&lt;p&gt;Domyślnie implementacja wygląda tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Czyli zwracane jest &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; tylko wtedy, gdy &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; odnoszą się do tego samego obiektu (wskazują na to samo miejsce w pamięci). Inaczej mówiąc — domyślnie (kiedy nie nadpiszemy zachowania metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;) instancja klasy jest równa tylko sobie.&lt;/p&gt;

&lt;h1 id=&quot;kiedy-nie-nadpisywać-metody-equals&quot;&gt;Kiedy nie nadpisywać metody equals?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Każda instancja klasy jest unikatowa w systemie (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Logiczne porównywanie klasy nie ma sensu i jest zbędne (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Pattern&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Jeśli istnieje nadklasa, która nadpisuje już &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; i to zachowanie jest poprawne dla naszej klasy (np. większość implementacji &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; dziedziczy implementację metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; odpowiednio z &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractList&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractMap&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Kiedy klasa sama zarządza swoimi instancjami i zapewnia, że istnieje co najwyżej jedna instancja tej klasy (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;Enum&lt;/code&gt; należy do tej kategorii).&lt;/li&gt;
  &lt;li&gt;Klasa jest &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;package-private&lt;/code&gt; i jesteśmy pewni, że &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; nie zostanie nigdy wywołane.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeśli chcemy być ekstremalnie ostrożni, to możemy się upewnić, że metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; nie zostanie nigdy wywołana (zgodnie z założeniami):&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Method is never called&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Dzięki temu, jeśli gdzieś zostanie wywołana, to od razu zostaniemy poinformowani, że ktoś wcześniej założył, że nie powinno to mieć miejsca. Unikniemy przez to niespodziewanego zachowania klas zależnych od &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Częściej jednak metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; jest kluczowa i będziemy nadpisywać jej zachowanie.&lt;/p&gt;

&lt;h1 id=&quot;kiedy-nadpisywać-metodę-equals&quot;&gt;Kiedy nadpisywać metodę equals?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Kiedy klasa nadaje się do logicznego porównywania, które nie polega tylko na unikatowym identyfikatorze i nie istnieje nadklasa, która już to robi w poprawny sposób.&lt;/li&gt;
  &lt;li&gt;Kiedy klasa reprezentuje wartość (np. klasy takie jak &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Również wiele klas zależy od metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; i jej dobra implementacja jest wymagana do poprawnego funkcjonowania tych klas.&lt;/p&gt;

&lt;p&gt;Dla przykładu jest to niezbędne, aby używać obiekty jako klucze w mapach czy dodawać je do setów.&lt;/p&gt;

&lt;h1 id=&quot;co-equals-musi-spełniać&quot;&gt;Co equals musi spełniać?&lt;/h1&gt;

&lt;p&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; dla każdej wartości &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; różnej od &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; powinna być:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Reflexive&lt;/strong&gt; - czyli dla &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; musi zwrócić &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Symmetric&lt;/strong&gt; - czyli dla &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; musi zwrócić &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; wtedy i tylko wtedy gdy &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Transitive&lt;/strong&gt; - czyli jeśli &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; i &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; to &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; też musi zwracać &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Consistent&lt;/strong&gt; - czyli wielokrotne wywołanie &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; bez zmiany parametrów używanych w &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; zawsze konsekwentnie zwraca &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; lub &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;“Non-nullity”&lt;/strong&gt; - czyli dla &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt; musi zostać zwrócone &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jest to &lt;strong&gt;kontrakt&lt;/strong&gt;, który metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; musi spełniać.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jeśli te warunki nie zostaną spełnione, to wszystkie klasy, które polegają na metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; obiektów (np. klasy kolekcji), będą zachowywać się nieregularnie, niepoprawnie i powodować błędy, dla których może być ciężko znaleźć przyczynę.&lt;/strong&gt;&lt;/p&gt;

&lt;p id=&quot;problem-z-dziedziczeniem&quot;&gt;Trzeba się też zastanowić, czy klasy, które rozszerzają inną klasę (również, gdy dodają wartość, która ma znaczenie w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;), powinny móc być równe nadklasom?&lt;/p&gt;

&lt;p&gt;Joshua Bloch w swojej książce mówi, że tak — co jest zgodne z zasadą &lt;a href=&quot;/notatnik-juniora/zasady-projektowania-kodu#l---liskov-substitution-principle&quot;&gt;Liskov substitution&lt;/a&gt;. Ponadto mówi, że nie ma sposobu, aby rozszerzyć instancjowalną klasę i dodać do niej wartość zachowując kontrakt &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, chyba że, chcemy zrezygnować z zalet obiektowych abstrakcji.&lt;/p&gt;

&lt;p&gt;Z drugiej strony, przeciwne głosy idą za tym, że możemy zachować kontrakt &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; używając sprawdzenia z &lt;code class=&quot;highlighter-rouge&quot;&gt;getClass&lt;/code&gt; zamiast &lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;. Dla przykładu, dla prostej klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; będzie to wyglądać tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Broken - violates Liskov substitution principle (page 43)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Co skutkuje tym, że obiekty są równe tylko wtedy, gdy mają również taką samą klasę. Jednak Joshua Bloch twierdzi, że jest to nieakceptowalne, bo narusza to zasadę &lt;a href=&quot;/notatnik-juniora/zasady-projektowania-kodu#l---liskov-substitution-principle&quot;&gt;Liskov substitution&lt;/a&gt;. Uzasadnia to tym, że podtyp danego obiektu jest nadal tym obiektem (Np. &lt;code class=&quot;highlighter-rouge&quot;&gt;ColorPoint&lt;/code&gt; rozszerzając &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; jest nadal &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt;-em ) i powinien funkcjonować jak ten obiekt, jednak nie jest to możliwe w tym podejściu. Wtedy nawet klasa, która rozszerza inną klasę i nie dodaje wartości, która ma znaczenie w &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;, nie będzie jej równa.&lt;/p&gt;

&lt;p&gt;Joshua Bloch wypowiedział się na ten temat też dodatkowo poza książką &lt;a href=&quot;https://www.artima.com/intv/bloch17.html&quot;&gt;tutaj&lt;/a&gt;, jako że jest to dosyć kontrowersyjny temat w jego książce.&lt;/p&gt;

&lt;p&gt;Jako obejście tego problemu można zastosować &lt;a href=&quot;/notatnik-juniora/zasady-projektowania-kodu#composition-over-inheritance&quot;&gt;Composition Over Inheritance&lt;/a&gt; (będzie też osobny wpis na ten temat w rozdziale 3 serii). Zamiast rozszerzać &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt;, dać klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;ColorPoint&lt;/code&gt; pole prywatne &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; oraz udostępniając metodę dostępową do tego pola:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Adds a value component without violating the equals contract&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ColorPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
    * Returns the point-view of this color point.
    */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;asPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ColorPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ColorPoint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ColorPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Remainder omitted&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Według mnie to, czy dany obiekt powinien być równy innemu, nawet jeśli jest jego podklasą to sprawa indywidualna. Na pewno znajdą się przypadki, kiedy &lt;code class=&quot;highlighter-rouge&quot;&gt;ColorPoint&lt;/code&gt; powinien móc być równy &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; jak i takie, kiedy nie powinno mieć to miejsca.&lt;/p&gt;

&lt;h1 id=&quot;jak-poprawnie-zaimplementować-metodę-equals&quot;&gt;Jak poprawnie zaimplementować metodę equals?&lt;/h1&gt;

&lt;p&gt;Kiedy nie mamy potrzeby definiowania jakiegoś specyficznego zachowania metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; to najczęściej najlepiej zdać się na jej automatyczne wygenerowanie. Umożliwiają nam to IDE i bibloteki takie jak np. &lt;a href=&quot;https://projectlombok.org/&quot;&gt;Lombok&lt;/a&gt;. Poprawność implementacji wtedy zrzucamy na IDE lub bibliotekę, przez co czasem możemy uniknąć naszych ludzkich błędów.&lt;/p&gt;

&lt;p&gt;Nawiązując jeszcze do poprzedniego problemu, np. w InteliJ mamy do wyboru, czy podtypy klasy powinny być akceptowane w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;Equals&lt;/code&gt; czy nie.&lt;/p&gt;

&lt;p&gt;W projekcie &lt;a href=&quot;https://projectlombok.org/&quot;&gt;Lombok&lt;/a&gt; również jest dostępna adnotacja, dzięki której zostanie wygenerowana dla nas implementacja &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; - &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@EqualsAndHashCode&lt;/span&gt;&lt;/code&gt;. Obecnie Lombok łamie zasadę &lt;a href=&quot;/notatnik-juniora/zasady-projektowania-kodu#l---liskov-substitution-principle&quot;&gt;Liskov substitution&lt;/a&gt; i jest to zrobione świadomie, a &lt;a href=&quot;https://groups.google.com/forum/#!topic/project-lombok/jmhrTo0nAx8&quot;&gt;tutaj&lt;/a&gt; można przeczytać dyskusję na ten temat.&lt;/p&gt;

&lt;p&gt;Jeśli jednak zamierzmy samemu zadbać o implementację metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; to można sugerować się tym przepisem:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Argument powinien być zawsze typu &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Użyj operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; żeby sprawdzić, czy argument jest referencją do obiektu. Jeśli tak zwróć &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Użyj operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt; żeby sprawdzić, czy argument jest odpowiedniego typu. Jeśli nie jest, zwróć &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Rzutuj argument na odpowiedni typ.&lt;/li&gt;
  &lt;li&gt;Dla każdego znaczącego pola w tym obiekcie sprawdź, czy to pole jest równe odpowiadającemu polu w argumencie. Jeśli wszystkie pola się zgadzają, zwróć &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, w przeciwnym wypadku &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;Dla prymitywów z wyjątkiem &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; i &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; używaj operatora &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; do porównywania.&lt;/li&gt;
      &lt;li&gt;Dla pól przechowujących referencje do obiektów wywołuj ich &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Dla pól typu &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; używaj metody &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;/code&gt;, a dla &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; używaj &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Dla tablic stosuj te wskazówki dla każdego elementu. Jeśli każdy element tablicy ma znaczenie, użyj metody &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Niektóre z pól mogą być &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;. Aby uniknąć &lt;code class=&quot;highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt; użyj do porównywania &lt;code class=&quot;highlight language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Wydajność metody &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; zależy od kolejności kolejnych sprawdzeń. Aby uzyskać najlepszą wydajność, najpierw sprawdzaj pola, które najczęściej będą się różnić i ich porównywanie jest mniej kosztowne.&lt;/li&gt;
      &lt;li&gt;Nie porównuj obiektów, które nie są częścią stanu logicznego obiektu.&lt;/li&gt;
      &lt;li&gt;Nie porównuj pól, które są pochodnymi innych (ich wynik zależy od innych pól, które już sprawdzasz).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sprawdź, czy twoja metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; spełnia wszystkie 5 warunków (kontrakt)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Przykład poprawnej implementacji:&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Class with a typical equals method&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;areaCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;999&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;area code&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;999&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;prefix&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineNum&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;9999&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;line num&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;areaCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areaCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Remainder omitted&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Nadpisując metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt; musimy zawsze nadpisać również metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, ale o niej w następnym wpisie.&lt;/strong&gt;&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 10 z rozdziału: Methods Common to All Objects Item 10: Obey the general contract when overriding equals Item 11: Always override hashCode when you override equals Item 12: Always override toString Item 13: Override clone judiciously Item 14: Consider implementing Comparable</summary></entry><entry><title type="html">Preferuj try-with-resources</title><link href="https://devcave.pl/effective-java/preferuj-try-with-resources" rel="alternate" type="text/html" title="Preferuj try-with-resources" /><published>2018-06-09T10:00:00+02:00</published><updated>2018-06-09T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/preferuj-try-with-resources</id><content type="html" xml:base="https://devcave.pl/effective-java/preferuj-try-with-resources">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 9&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Creating and Destroying Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;Item 1: Consider static factory methods instead of constructors
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-builder&quot;&gt;Item 2: Consider a builder when faced with many constructor parameters
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-singleton&quot;&gt;Item 3: Enforce the singleton property with a private constructor or an enum type
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/klasy-nieinstancjowalne&quot;&gt;Item 4: Enforce noninstantiability with a private constructor
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wstrzykiwanie-zaleznosci&quot;&gt;Item 5: Prefer dependency injection to hardwiring resources
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;Item 6: Avoid creating unnecessary objects
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wycieki-pamieci-w-javie&quot;&gt;Item 7: Eliminate obsolete object references
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/unikaj-finalizerow-i-cleanerow&quot;&gt;Item 8: Avoid finalizers and cleaners
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/preferuj-try-with-resources&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 9: Prefer try-with-resources to try-finally
                    &lt;/a&gt;
                &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;W Javie wiele klas wymaga zamknięcia używanych przez nie zasobów wywołując metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;. Są to np. &lt;code class=&quot;highlighter-rouge&quot;&gt;FileInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FileOutputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExectuor&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;java.sql.Connection&lt;/code&gt;. Zamknięcie zasobów jest często niedopilnowane, co może wpływać na wydajność aplikacji. Wiele z tych klas używa finalizerów jako “siatki bezpieczeństwa”, jednak jak wiemy z poprzedniego postu - nie działa to zbyt dobrze.&lt;/p&gt;

&lt;p&gt;Kiedyś (przed Java 7), najlepszym sposobem na poprawne zamknięcie zasobów było &lt;em&gt;try-finally&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// try-finally - No longer the best way to close resources!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;firstLineOfFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Blok &lt;em&gt;finally&lt;/em&gt; jest odpalany nawet wtedy, kiedy w bloku &lt;em&gt;try&lt;/em&gt; wystąpi wyjątek czy operacja &lt;em&gt;return&lt;/em&gt;, dlatego był dobrym miejscem na zamknięcie zasobów.&lt;/p&gt;

&lt;p&gt;Nie wygląda to źle, ale z każdym kolejnym zasobem jest coraz gorzej:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// try-finally is ugly when used with more than one resource!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;InputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;OutputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOutputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Czytelność spada drastycznie.&lt;/p&gt;

&lt;p&gt;Z &lt;em&gt;try-finally&lt;/em&gt; jest też inny problem. Zarówno w bloku &lt;em&gt;try&lt;/em&gt; jak i &lt;em&gt;finally&lt;/em&gt; może wystąpić wyjątek. Np. jeśli w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;firstLineOfFile&lt;/code&gt;, przy wywołaniu metody &lt;code class=&quot;highlighter-rouge&quot;&gt;readLine&lt;/code&gt; wystąpi wyjątek w związku z błędem na fizycznym urządzeniu, to również wywołanie metody &lt;code class=&quot;highlighter-rouge&quot;&gt;close&lt;/code&gt; rzuci wyjątkiem z tego samego powodu. W takiej sytuacji drugi wyjątek przesłoni pierwszy i nie będziemy o tym wiedzieć. Nie zobaczymy go w &lt;em&gt;stack trace&lt;/em&gt;, co może utrudnić debugowanie, bo zazwyczaj to pierwszy rzucony wyjątek chcemy ujrzeć. Jest możliwe, aby stłumić drugi wyjątek na rzecz pierwszego, ale w praktyce nikt tego nie robi, bo jest to rozwlekłe rozwiązanie.&lt;/p&gt;

&lt;p&gt;Wszystkie te problemy zostały rozwiązane wraz z przyjściem w Javie 7 &lt;em&gt;try-with-resources&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Aby nasz zasób mógł być używany z &lt;em&gt;try-with-resources&lt;/em&gt; musi implementować interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;AutoCloseable&lt;/code&gt;, czyli metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;. Teraz wiele klas i interfejsów z bibliotek Javy implementuje ten interfejs. Jest to poniekąd standard. Więc jeśli piszesz klasę, która reprezentuje zasób, który musi być zamknięty, to powinna implementować &lt;code class=&quot;highlighter-rouge&quot;&gt;AutoCloseable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Drugi przykład (który wraz z kolejnym zasobem robił się coraz brzydszy), z &lt;em&gt;try-with-resources&lt;/em&gt; wygląda tak:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// try-with-resources on multiple resources - short and sweet&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InputStream&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;OutputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileOutputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jak widać, jest to dużo bardziej zwięzłe i czytelne rozwiązanie. Co więcej, jeśli wystąpią wyjątki tak jak wcześniej opisałem, to te następujące po pierwszym stają się &lt;em&gt;suppressed&lt;/em&gt;, pozostawiając na wierzchu ten, który chcemy zobaczyć - czyli pierwszy jaki wystąpił.&lt;/p&gt;

&lt;p&gt;Wyjątki &lt;em&gt;suppressed&lt;/em&gt; nie są pomijane - mamy informację o nich w &lt;em&gt;stack trace&lt;/em&gt; i możemy się do nich dostać z kodu wywołując metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;getSuppresed()&lt;/code&gt;, dostępną od Javy 7 na każdym &lt;code class=&quot;highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Oczywiście do &lt;em&gt;try-with-resources&lt;/em&gt; możemy dodać blok &lt;em&gt;catch&lt;/em&gt; tak jak w normalnym &lt;em&gt;try&lt;/em&gt;, co pozwala obsłużyć wszystkie wyjątki bez kolejnych zagnieżdżeń.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Catch&lt;/em&gt; może też służyć do innych celów. Np. w przypadku wystąpienia wyjątku w &lt;em&gt;try&lt;/em&gt; - zwrócenie domyślnej wartości. Dla przykładu:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;firstLineOfFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FileReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Zatem używajmy tylko &lt;em&gt;try-with-resources&lt;/em&gt;, aby kod był bardziej zwięzły, czytelniejszy, a rzucane wyjątki bardziej użyteczne. Jeśli tylko napotkasz w systemie kilka zagnieżdżeń &lt;em&gt;try-finally&lt;/em&gt;, zamień je na &lt;em&gt;try-with-resources&lt;/em&gt;, aby żyło nam się lepiej ;)&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 9 z rozdziału: Creating and Destroying Objects Item 1: Consider static factory methods instead of constructors Item 2: Consider a builder when faced with many constructor parameters Item 3: Enforce the singleton property with a private constructor or an enum type Item 4: Enforce noninstantiability with a private constructor Item 5: Prefer dependency injection to hardwiring resources Item 6: Avoid creating unnecessary objects Item 7: Eliminate obsolete object references Item 8: Avoid finalizers and cleaners Item 9: Prefer try-with-resources to try-finally</summary></entry><entry><title type="html">Finalizery i Cleanery</title><link href="https://devcave.pl/effective-java/unikaj-finalizerow-i-cleanerow" rel="alternate" type="text/html" title="Finalizery i Cleanery" /><published>2018-06-02T10:00:00+02:00</published><updated>2018-06-02T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/unikaj-finalizerow-i-cleanerow</id><content type="html" xml:base="https://devcave.pl/effective-java/unikaj-finalizerow-i-cleanerow">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 8&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Creating and Destroying Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;Item 1: Consider static factory methods instead of constructors
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-builder&quot;&gt;Item 2: Consider a builder when faced with many constructor parameters
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-singleton&quot;&gt;Item 3: Enforce the singleton property with a private constructor or an enum type
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/klasy-nieinstancjowalne&quot;&gt;Item 4: Enforce noninstantiability with a private constructor
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wstrzykiwanie-zaleznosci&quot;&gt;Item 5: Prefer dependency injection to hardwiring resources
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;Item 6: Avoid creating unnecessary objects
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wycieki-pamieci-w-javie&quot;&gt;Item 7: Eliminate obsolete object references
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/unikaj-finalizerow-i-cleanerow&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 8: Avoid finalizers and cleaners
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/preferuj-try-with-resources&quot;&gt;Item 9: Prefer try-with-resources to try-finally
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;finalizery&quot;&gt;Finalizery&lt;/h1&gt;
&lt;p&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt; jest zdefiniowana w &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; i jest tzw. &lt;em&gt;finalizerem&lt;/em&gt;. Możemy nadpisać jej zachowanie w dowolnym obiekcie. Została stworzona głównie do tego, aby wykonać jakąś akcję na danym obiekcie (np. zwolnić wykorzystywane przez niego zasoby), kiedy ten zostanie usunięty z pamięci .&lt;/p&gt;

&lt;p&gt;Metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt; jest więc odpalana wtedy, kiedy &lt;em&gt;garbage collector&lt;/em&gt; stwierdzi, że nie ma już referencji do danej klasy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;W praktyce może to nigdy nie nastąpić&lt;/strong&gt;, dlatego nasz program nigdy nie powinien polegać na metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;. To kiedy &lt;em&gt;garbage collector&lt;/em&gt; zostanie odpalony, jest uzależnione od konkretnej implementacji JVM, jak i systemu.  Dlatego jej zachowanie jest nieprzewidywalne i źle wpływa na przenośność programu (różne zachowanie na różnych systemach). Ma też negatywny wpływ na wydajność, bo JVM musi wykonać dużo więcej operacji podczas tworzenia i usuwania obiektów, które mają nadpisaną metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Kolejnym problemem jest to, że finalizery nie kontrolują wyjątków — jeśli finalizer rzuci wyjątek, to jego proces zostaje przerwany, wyjątek zostaje zignorowany, a nasz obiekt pozostawiony w niepoprawnym stanie bez żadnej informacji.&lt;/p&gt;

&lt;p&gt;Ponadto używanie finalizerów jest często zbędne.&lt;/p&gt;

&lt;p&gt;Swoją drogą, od Javy 9 metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt; jest &lt;em&gt;deprecated&lt;/em&gt; - głównie z wymienionych przeze mnie powodów, a w miejsce finalizerów powstały cleanery. Jako dowód zostawiam oficjalne uzasadnienie:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Finalizers are inherently problematic and their use can lead to performance issues, deadlocks, hangs, and other problematic behavior&lt;/em&gt;.
Furthermore, the timing of finalization is unpredictable with no guarantee that a finalizer will be called. Classes whose instances hold non-heap resources should provide a method to enable explicit release of those resources, and they should also implement  &lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.AutoCloseable&lt;/code&gt;  if appropriate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;cleanery&quot;&gt;Cleanery&lt;/h1&gt;
&lt;p&gt;Cleanery są mniej niebezpieczne niż finalizery (np. rozwiązują problem finalizerów z kontrolowaniem wyjątków), jednak nadal są nieprzewidywalne, wolne i również często zbędne.&lt;/p&gt;

&lt;p&gt;Czy w takim razie cleanery i finalizery są do czegoś w ogóle potrzebne? Jednym z niewielu przypadków, kiedy ich użycie może być uzasadnione, to gdy służą jako “siatka bezpieczeństwa” - czyli w przypadku, gdy metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt; nie zostanie wywołana na zasobie przez jego właściciela. Nie jest zagwarantowane kiedy to się stanie, ale lepiej późno niż wcale.&lt;/p&gt;

&lt;p&gt;Jednak zanim się na to zdecydujemy, trzeba się dobrze zastanowić, czy jest to warte kosztu takiego rozwiązania.&lt;/p&gt;

&lt;p&gt;Niektóre klasy standardowe Javy (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;FileInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FileOutputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExectuor&lt;/code&gt; czy &lt;code class=&quot;highlighter-rouge&quot;&gt;java.sql.Connection&lt;/code&gt;) mają finalizery, które służą właśnie jako taka “siatka bezpieczeństwa”.&lt;/p&gt;

&lt;p&gt;Spróbujmy zobrazować to na przykładzie klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Room&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Room&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AutoCloseable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleaner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Resource that requires cleaning. Must not refer to Room!&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Number of junk piles in this room&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;numJunkPiles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Invoked by close method or cleaner&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Cleaning room&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// The state of this room, shared with our cleanable&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Our cleanable. Cleans the room when it’s eligible for gc&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Cleanable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleanable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numJunkPiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cleanable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cleanable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Klasa implementuje interfejs &lt;code class=&quot;highlighter-rouge&quot;&gt;AutoCloseable&lt;/code&gt;, a jako szczegół implementacyjny metody &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt; używany jest &lt;code class=&quot;highlighter-rouge&quot;&gt;Cleaner&lt;/code&gt;. Jest to poniekąd zaleta cleanerów, że nie widnieją w publicznym API klasy, więc można w dowolnym momencie zmienić implementację.&lt;/p&gt;

&lt;p&gt;Klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt; odgrywa rolę zasobu, który wymaga czyszczenia. Implementuje ona &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; i jest rejestrowana w cleanerze. Jej metoda &lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt; jest wywoływana przez metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;clean()&lt;/code&gt;, którą klient może użyć bezpośrednio lub jeśli tego nie zrobi — przez nasz &lt;code class=&quot;highlighter-rouge&quot;&gt;Cleaner&lt;/code&gt; (miejmy nadzieję) - kiedy klasa &lt;code class=&quot;highlighter-rouge&quot;&gt;Room&lt;/code&gt; stanie się dostępna dla &lt;em&gt;garbage collectora&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;“Miejmy nadzieję” to słowo klucz, bo nie jest to zagwarantowane.&lt;/p&gt;

&lt;p&gt;Używając takiej klasy z &lt;em&gt;try-with-resources&lt;/em&gt; nie będzie problemu i automatyczne czyszczenie nie będzie nigdy potrzebne:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myRoom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Goodbye&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Najpierw zobaczymy komunikat “Goodbye”, a następnie “Cleaning”. Jednak jeśli klient tego nie zrobi, zachowanie jest nieprzewidywalne:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myRoom2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Room&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Peace out&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Pojawi się komunikat “Peace out”, ale w moim przypadku “Cleaning” nigdy się nie uruchomi. I to jest ta nieprzewidywalność, o której była mowa.&lt;/p&gt;

&lt;p&gt;Dopiero dorzucenie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sprawia, że u mnie “Cleaning” się uruchomi, ale to również nie gwarantuje takiego samego zachowania na każdej maszynie ani nie jest dobrą praktyką.&lt;/p&gt;

&lt;p&gt;Podsumowując, unikaj stosowania clenearów i przed Java 9 - finalizerów.&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Cleanerów i finalizerów nie można porównywać do destruktorów, np. znanych z C++. Destruktory używane są do zwalniania zasobów z pamięci powiązanych z danym obiektem. W Javie tym się zajmuje &lt;em&gt;garbage collector&lt;/em&gt;.  Destruktory z C++ służą też do zwalniania innych zasobów (nie z pamięci). W Javie w tym celu jest używane &lt;em&gt;try-finally&lt;/em&gt; lub &lt;em&gt;try-with-resources&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;co-zamiast-nich&quot;&gt;Co zamiast nich?&lt;/h1&gt;

&lt;p&gt;Jak zwalniać zatem zasoby z obiektów, jeśli nie za pomocą finalizerów i cleanerów?&lt;/p&gt;

&lt;p&gt;Ano sprawić, żeby nasza klasa implementowała &lt;code class=&quot;highlighter-rouge&quot;&gt;AutoCloseable&lt;/code&gt; i wywoływać metodę &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt; bezpośrednio, kiedy zasób nie jest już potrzebny, lub &lt;strong&gt;bardziej preferowany sposób&lt;/strong&gt; - używać z &lt;em&gt;try-with-resources&lt;/em&gt;, o którym będzie kolejny wpis.&lt;/p&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 8 z rozdziału: Creating and Destroying Objects Item 1: Consider static factory methods instead of constructors Item 2: Consider a builder when faced with many constructor parameters Item 3: Enforce the singleton property with a private constructor or an enum type Item 4: Enforce noninstantiability with a private constructor Item 5: Prefer dependency injection to hardwiring resources Item 6: Avoid creating unnecessary objects Item 7: Eliminate obsolete object references Item 8: Avoid finalizers and cleaners Item 9: Prefer try-with-resources to try-finally</summary></entry><entry><title type="html">Wycieki pamięci w Javie</title><link href="https://devcave.pl/effective-java/wycieki-pamieci-w-javie" rel="alternate" type="text/html" title="Wycieki pamięci w Javie" /><published>2018-05-26T10:00:00+02:00</published><updated>2018-05-26T10:00:00+02:00</updated><id>https://devcave.pl/effective-java/wycieki-pamieci-w-javie</id><content type="html" xml:base="https://devcave.pl/effective-java/wycieki-pamieci-w-javie">&lt;p class=&quot;note&quot;&gt;
  Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat.
&lt;/p&gt;

&lt;p&gt;Ten wpis nawiązuje do tematu z &lt;i&gt;Item 7&lt;/i&gt; z rozdziału:&lt;/p&gt;

&lt;p class=&quot;m0&quot;&gt;Creating and Destroying Objects&lt;/p&gt;

&lt;ul class=&quot;fa-ul custom&quot;&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/static-factory-method-zamiast-konstruktora&quot;&gt;Item 1: Consider static factory methods instead of constructors
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-builder&quot;&gt;Item 2: Consider a builder when faced with many constructor parameters
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wzorzec-projektowy-singleton&quot;&gt;Item 3: Enforce the singleton property with a private constructor or an enum type
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/klasy-nieinstancjowalne&quot;&gt;Item 4: Enforce noninstantiability with a private constructor
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/wstrzykiwanie-zaleznosci&quot;&gt;Item 5: Prefer dependency injection to hardwiring resources
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;Item 6: Avoid creating unnecessary objects
                &lt;/a&gt;
            &lt;/li&gt;&lt;li style=&quot;list-style-type: none;&quot;&gt;
                    &lt;a href=&quot;/effective-java/wycieki-pamieci-w-javie&quot;&gt;
                        &lt;i class=&quot;fa-li fa fa-arrow-right&quot;&gt;&lt;/i&gt;Item 7: Eliminate obsolete object references
                    &lt;/a&gt;
                &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/unikaj-finalizerow-i-cleanerow&quot;&gt;Item 8: Avoid finalizers and cleaners
                &lt;/a&gt;
            &lt;/li&gt;&lt;li&gt;
                &lt;a href=&quot;/effective-java/preferuj-try-with-resources&quot;&gt;Item 9: Prefer try-with-resources to try-finally
                &lt;/a&gt;
            &lt;/li&gt;&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;Java posiada &lt;em&gt;garbage collector&lt;/em&gt;, który zajmuję się za nas zarządzaniem pamięcią. Można by pomyśleć, że możemy całkowicie zapomnieć o zarządzaniu pamięcią, jednak nie do końca.&lt;/p&gt;

&lt;h1 id=&quot;wycieki-pamięci&quot;&gt;Wycieki pamięci&lt;/h1&gt;

&lt;p&gt;Czym są wycieki pamięci? Wyciek pamięci następuje wtedy, kiedy dane obiekty nie są już używane przez aplikację, ale &lt;em&gt;garbage collector&lt;/em&gt; nie jest w stanie ich usunąć, ponieważ w naszej aplikacji nadal są przechowywane do nich referencje. W rezultacie zużywane jest coraz więcej zasobów znacząco spowalniając naszą aplikację, aż do momentu, kiedy ich braknie i rzucony zostanie &lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Jednak brak &lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt; nie jest jednoznaczne z tym, że nie mamy do czynienia z wyciekiem pamięci. Wyciek pamięci może mieć miejsce bez żadnych zgłoszonych errorów. Po prostu skończy się na tym, że gwałtownie spadnie wydajność naszej aplikacji ze względu nadmiernej pracy &lt;em&gt;garbage collectora&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Wycieki pamięci nie dają o sobie znać w oczywisty sposób.  Są zazwyczaj wykrywane podczas ostrożnego przeglądania kodu lub z pomocą narzędzi do debugowania znanych jako &lt;em&gt;heap profiler&lt;/em&gt;. Dlatego warto jest poznać temat i zapobiegać takim sytuacją wcześniej.&lt;/p&gt;

&lt;p&gt;Tutaj jest przykładowa implementacja klasy &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;, która pozornie wygląda w porządku, jednak może prowadzić do wycieków pamięci:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ensureCapacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EmptyStackException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;cm&quot;&gt;/**
	* Ensure space for at least one more element, roughly
	* doubling the capacity each time the array needs to grow.
	*/&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ensureCapacity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Problem jest w metodzie &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;. Obiekty, które zostały już pobrane ze stosu, nie są zbierane przez &lt;em&gt;garbage collector&lt;/em&gt;, nawet jeśli stos już ich nie używa.  Dzieje się tak dlatego, że nieumyślnie zachowujemy referencje do nieużywanych już obiektów w tablicy &lt;code class=&quot;highlighter-rouge&quot;&gt;elements&lt;/code&gt;. Po angielsku nazywamy je &lt;em&gt;obsolate references&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ponadto wszystkie referencje do innych obiektów, które są w nich przetrzymywane również są wykluczone z &lt;em&gt;garbage collection&lt;/em&gt;, co może powodować, że wiele obiektów może nie być zebranych przez &lt;em&gt;garbage collector&lt;/em&gt;, powodując potencjalny spadek wydajności aplikacji.&lt;/p&gt;

&lt;h3 id=&quot;nullowanie-nieużywanych-referencji&quot;&gt;Nullowanie nieużywanych referencji&lt;/h3&gt;

&lt;p&gt;Problem można naprawić dosyć łatwo - nullować niepotrzebne już referencje do obiektów.&lt;/p&gt;

&lt;p&gt;Poprawna implementacja metody &lt;code class=&quot;highlighter-rouge&quot;&gt;pop()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EmptyStackException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Eliminate obsolete reference&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Dodatkowym plusem jest to, że jeśli potem przez pomyłkę znów program chciałby uzyskać do niej dostęp, to od razu wyrzuci &lt;code class=&quot;highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt;, zamiast po cichu robić coś nieplanowanego.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nie oznacza to jednak, że powinniśmy nullować każdą możliwą referencję do obiektu, jeśli program przestał jej już używać. Należy to robić tylko w wyjątkowych sytuacjach.&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Nieużywane referencje do obiektów są automatycznie zbierane przez &lt;em&gt;garbage collector&lt;/em&gt;, gdy zmienna przechowująca referencję wypada z zasięgu. &lt;br /&gt;  &lt;br /&gt;
&lt;strong&gt;Best practice:&lt;/strong&gt; definiuj zmienne w najmniejszym możliwe &lt;em&gt;scope-ie&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kiedy więc nullować referencje? Dlaczego w klasie &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt; powinniśmy to robić?&lt;/p&gt;

&lt;p&gt;A no dlatego, że sama zarządza swoją pamięcią. W tym przykładzie &lt;em&gt;storage pool&lt;/em&gt; składa się z elementów tablicy &lt;code class=&quot;highlighter-rouge&quot;&gt;elements&lt;/code&gt;. Tylko te elementy, które są w aktywnej części tablicy (czyli te o indeksach mniejszych od wielkości stosu) są ważne, a pozostałe są wolne i nie będą już nigdy użyte. Ale nie ma opcji, żeby &lt;em&gt;garbage collector&lt;/em&gt; o tym wiedział. Tylko programista o tym wie, dlatego powinien dać o tym znać &lt;em&gt;garbage collectorowi&lt;/em&gt; poprzez nullowanie nieużywanych już obiektów w tablicy &lt;code class=&quot;highlighter-rouge&quot;&gt;elements&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zatem powinniśmy nullowac referencję tylko wtedy, kiedy klasa sama zarządzająca swoją pamięcią.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;W innych przypadkach jest to zbędne i tylko zaśmieca kod.&lt;/p&gt;

&lt;h2 id=&quot;cachowanie&quot;&gt;Cachowanie&lt;/h2&gt;

&lt;p&gt;Innym źródłem wycieków pamięci jest cachowanie.  Najprostszym typem danych w którym możemy trzymać dane w cachu  jest &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;. W wielowątkowych zastosowaniach będzie to &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Kiedy dodamy obiekt do &lt;em&gt;cache&lt;/em&gt; łatwo jest o nim zapomnieć i trzymać go w nim długo po tym jak jest potrzebny. Jest kilka rozwiązań tego problemu:&lt;/p&gt;

&lt;p&gt;Jeśli obiekt w &lt;em&gt;cache&lt;/em&gt; jest ważny tylko przez czas kiedy na zewnątrz są referencje do klucza tego obiektu - użyj &lt;code class=&quot;highlighter-rouge&quot;&gt;WeakHashMap&lt;/code&gt; , bo tak właśnie działa &lt;code class=&quot;highlighter-rouge&quot;&gt;WeakHashMap&lt;/code&gt;.&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;Referencje do samego obiektu nie są ważne, liczy się tylko referencja do klucza.&lt;/p&gt;

&lt;p&gt;Częściej jednak to, czy obiekt jest już bezużyteczny, nie jest tak łatwo zdefiniowane. Może np. tracić na wartości z czasem. W takich przypadkach &lt;em&gt;cache&lt;/em&gt; powinien być zwalniany okazjonalnie z obiektów, które już od jakiegoś czasu wyszły z użycia. Możemy to zrobić używając wątku w tle (np. &lt;code class=&quot;highlighter-rouge&quot;&gt;ScheduledThreadPoolExecutor&lt;/code&gt;) lub wtedy, kiedy dodajemy nowy obiekt do &lt;em&gt;cache&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tego drugiego sposobu używa np. &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt; ze swoją metodą &lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry&lt;/code&gt;, którą możemy nadpisać z naszą logiką określającą, czy powinniśmy usunąć najstarszy obiekt w mapie:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_ENTRIES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_ENTRIES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;75&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eldest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_ENTRIES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;H&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;E&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;L&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;L&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;O&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lhm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//{2=L, 3=L, 4=O}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;W tym przykładzie działa to tak, że jeśli mapa przekroczy określoną wielkość (w tym przypadku 3) to zostanie z niej usunięta najstarsza wartość. Jak widać z pięciu włożonych elementów &lt;code class=&quot;highlighter-rouge&quot;&gt;H, E, L, L, O&lt;/code&gt; zostały 3 najnowsze &lt;code class=&quot;highlighter-rouge&quot;&gt;L, L, O&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;W książce autor pisze, że dla bardziej złożonych &lt;em&gt;cache&lt;/em&gt;-y można użyć klas z pakietu &lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.ref&lt;/code&gt;, które reprezentują różne typy referencji do obiektów, jednak implementowanie swojego &lt;em&gt;cache&lt;/em&gt; zazwyczaj jest złym pomysłem. Mamy do tego gotowe rozwiązania jak &lt;a href=&quot;http://www.baeldung.com/guava-cache&quot;&gt;Guava Cache&lt;/a&gt;, &lt;a href=&quot;http://www.baeldung.com/ehcache&quot;&gt;Ehcache&lt;/a&gt; czy mechanizm cachowania w Springu.&lt;/p&gt;

&lt;p&gt;Jako rozszerzenie tego tematu polecam prezentację &lt;a href=&quot;https://www.youtube.com/watch?v=wfPl_aNj4Pc&quot;&gt;On-heap cache vs Off-heap cache w Javie - Radek Grębski&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;listenery-i-inne-callback-i&quot;&gt;Listenery i inne callback-i&lt;/h2&gt;

&lt;p&gt;Jest to kolejne popularne źródło wycieków pamięci. Jeśli implementujesz API, gdzie klient rejestruje &lt;em&gt;callback&lt;/em&gt;, ale nie wyrejestrowuje ich bezpośrednio, to będą się gromadzić dopóki nie wykonasz jakiejś akcji. Jednym sposobem na zagwarantowanie, że zostaną one zebrane przez &lt;em&gt;garbage collector&lt;/em&gt; jak nie będą już potrzebne, jest przechowywane tylko ich &lt;em&gt;weak references&lt;/em&gt; np. przechowując je jako klucze w &lt;code class=&quot;highlighter-rouge&quot;&gt;WeakHashMap&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;inne-drogi-do-wycieków-pamięci&quot;&gt;Inne drogi do wycieków pamięci&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;deklarowanie “ciężkiego” obiektu lub kolekcji jako &lt;em&gt;static&lt;/em&gt; - cykl życia obiektu zadeklarowanego jako &lt;em&gt;static&lt;/em&gt; jest równy cyklu życia JVM, czyli nigdy nie zostanie zebrany przez GC.&lt;/li&gt;
  &lt;li&gt;Niezamknięte streamy i inne &lt;code class=&quot;highlighter-rouge&quot;&gt;Closeable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Dodawanie obiektów bez &lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt; i  &lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt; do &lt;em&gt;hash&lt;/em&gt; kolekcji np. &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; - metody takie jak &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt; itd. nie będą działać poprawnie. Również próby dodania duplikatów zakończą się sukcesem, co nie powinno mieć miejsca w przypadku &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;. Będzie o tym też mowa w kolejnych postach z rozdziału &lt;em&gt;Methods Common to All Objects&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Autoboxing, czyli mieszanie typów prostych i ich wraperów w pętlach - przykład był w &lt;a href=&quot;/effective-java/unikaj-tworzenia-niepotrzebnych-obiektow&quot;&gt;poprzednim poście&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Codeboy</name></author><category term="Effective-Java" /><category term="Notatnik-Juniora" /><category term="Dobre-praktyki" /><category term="Java" /><category term="Effective-Java" /><summary type="html">Ten wpis jest częścią serii (nowy wpis co sobotę), w której tworzę wpisy w formie notatki z wybranego tematu z książki Effective Java (3rd edition 2018), której autorem jest Joshua Blosch. Jest to uaktualnione wydanie pod Jave 9 jednej z najlepszych książek o Javie. Nie ograniczam się jednak tylko do książki, więc czasem temat będzie rozbudowany i trafią się informacje z innych źródeł na ten sam temat. Ten wpis nawiązuje do tematu z Item 7 z rozdziału: Creating and Destroying Objects Item 1: Consider static factory methods instead of constructors Item 2: Consider a builder when faced with many constructor parameters Item 3: Enforce the singleton property with a private constructor or an enum type Item 4: Enforce noninstantiability with a private constructor Item 5: Prefer dependency injection to hardwiring resources Item 6: Avoid creating unnecessary objects Item 7: Eliminate obsolete object references Item 8: Avoid finalizers and cleaners Item 9: Prefer try-with-resources to try-finally</summary></entry></feed>